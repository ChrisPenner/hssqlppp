
= Current TODO list

TODOs in rough order that they are intended to be done

run through and finish or note missing bits for select expressions:
group by, having
order by
limit, offset
combineselect
joinon expression
natural and using fields check
natural xor join expression in joins
some missing expression bits:
exists
inpredicate
windowfn
scalarsubquery
rowctor
casts

selects should all be typable at this point. run through pg manual and
fill in all the gaps, get test sql files working for selects
(modify show types to look inside create functions)
- then we can run a roundtrip process which adds all the types as
   comments to have a look at

write type checking support that reads a given database for the
   defaultscope rather that using the hard coded template1 scope
- can start to actually type check real sql at this point

maybe before finishing selects, (partially) do create statements, and
   fix it so e.g. a source file with a create table followed by a
   select from that table type checks

chain scope lookups instead of unioning them since unioning is too
   slow - or maybe use maps/sets, but need to quickly scan whole lists
   e.g. for function lookup, which can't really use any sort of key
   based lookup, where the key the function lookup uses is the same as the
   key the map/set uses.

think about working on dot qualification
think about doing null and not null aspects

================================================================================

some disorganised syntax todo:

------------
add support for following sql syntax (+ type checking)
alter table, common variations
create index
create rule
create trigger
+ drops for all creates
+ maybe alters?
ctes
loop, exit, labels
easy ones: transactions, savepoints, listen
prepare, execute + using
some more:
create or replace
alter table
transactions: begin, checkpoint, commit, end, rollback
cursors: declare, open, fetch, move, close, where current of
copy - parse properly
create database
create index
create rule
create trigger + plpgsql support
grant,revoke
listen, notify, unlisten
prepare, execute
savepoint, release savepoint, rollback to savepoint
set, reset
set constraints
set role
set transaction

plpgsql

blocks which aren't at the top level of a function
% types
strict on intos
not null for var defs
exception
execute using
get diagnostics
return query execute
raise missing bits
out params
elsif
loop
exit
labels
reverse, by in for
for in execute

expressions:
process string escapes, support dollar quoting and other quoting more
   robustly in the pretty printer
full user operator support (?)
fix expression parser properly to handle things like between - see
   grammar in pg source for info on how to do this
[:] array slices
aggregate: all and distinct
multi dimensional arrays: selectors and subscripting
missing keyword operators
datetime extract
time zone
subquery operators: any, some, all
in general, parsing operators is wrong, the lexer needs to be able to
   lex sequences of symbols into single/multiple operators correctly,
   what happens at the moment is a kludge, also, general operator
   parsing will change how operators are represented in the ast

================================================================================

rough milestones for release 0.1:
work through pg manual part II, add test plus parse and type check
   support for everything mentioned. follow some links to sql
   reference and add tests for stuff there also.
figure out what to do about tricky operator precedence parsing, etc.
ability to type check all of chaos sql
get type info for ? style sql strings
generate typesafe db access wrapper for selects and function calls,
   plus other ? style sql strings?
example for generating sql code from haskell using the ast
get database loader and typesafe access generators good enough to use
   in chaos
example usage of each of these

incorporate pg regression test sql into parsing and type checking
   tests

================================================================================

some other random ideas:

write a show for parsec errors which formats the lex tokens and
   expected lists properly (was broken when moved to the separate
   lexer)

add haddock docs to public api

write some example programs with plenty of comments - will this mainly
   be used as a library or as a utility though?

redo cabal file to add compile time options: exes, pg support, tests
 or split into separate packages?

make a subfolder hierarchy/put code in a well named modules

work on error reporting, add tests for malformed sql

add token location info to ast nodes, modify for type checking, etc
   support.

want to report multiple parse errors, perhaps can bodge this because
   of the property that ';' can only appear inside a string or
   comment, or otherwise at the end of a statement, so add some code
   to jump to the next end of statement looking ';' and continue to
   parse to end of file in an attempt to catch at least some further
   syntax errors

improve tests:
identify each bit of syntax and make sure there is a test for it
add some bigger tests: lots of sql statements, big functions
look for possible corner cases and add tests

get property checker working again - one problem is that the pretty
   printer will reject some asts (which the parser cannot
   produce), and the parser will probably reject some invalid sql that
   the pretty printer will happily produce from some asts.

plpgsql on 'roids:
write libraries in haskell, and then write syntax extensions for
   plpgsql using the extension mechanism to access these libs from
   extended plpgsql e.g. ui lib written in haskell, accessed by syntax
   extensions in plpgsql then can write the database and ui all in the
   same source code in the same language, with first class support for
   properly typed relation valued expressions, avoiding multiple
   languages and mapping/'impedance mismatch' between database types
   and types in the language you write the ui in. A bit like Access
   but with a non numpty dbms.
