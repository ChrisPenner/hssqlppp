add support for partial expressions: e.g. used in case:
case a
   when = 3 then
   ...
and in check constraints

create table x (
  f text check (in ['a','b'])
...

add a exe to help checking the parse/pretty print round trip
using postgresl - take a sql script, parse and pretty print it to a
   separate file, then load the original and the pretty printed into
   empty databases, check no errors, then to a pg dump of each to two
   files then you can eyeball a diff to see how similar they
   look. Probably will have to do some work on cutting down the amount
   of parentheses that the pretty printer produces to make the diffs
   useful

identify the biggest missing bits and create table of supported and
   unsupported elements
work on error reporting, add tests for malformed sql
lex things properly?

put code in a well chosen module

add switch to support other sql dialects in the future

change the parsing to produce a parse tree with source locations for
   tokens
add support for passes over this tree to find additional errors which
   the initial parsing misses
transform this tree into an ast and add things like type checking

add a macro system for code generation, etc.

find a parser that supports better error messages, particularly
something which can report multiple errors

improve tests:
identify each bit of syntax and make sure there is a test for it
add some bigger tests: lots of sql statements, big functions
look for possible corner cases and add tests

get property checker working again - one problem is that the pretty
   printer will reject some parse trees (which the parser cannot
   produce), and the parser will probably reject some invalid sql that
   the pretty printer will happily produce from some parse trees.


some sql to do:
updates to existing parsers:
create table: finish constraints (see placeholder text in tests)
select: all, distinct on, having, window
  order by desc and using
  offset, for update/sahre
delete from
update using

new? parsers

create or replace
alter table
transactions: begin, checkpoint, commit, end, rollback
cursors: declare, open, fetch, move, close, where current of
copy - parse properly
create database
create index
create rule
create trigger + plpgsql support
drops for all supported creates
grant,revoke
listen, notify, unlisten
prepare, execute
savepoint, release savepoint, rollback to savepoint
set, reset
set constraints
set role
set transaction
truncate

plpgsql

blocks
% types
perform
strict on intos
not null for var defs
exception
execute using
get diagnostics
return query execute
raise missing bits
out params
elsif
when exp,exp
loop
exit
labels
reverse, by in for
for in execute

expressions:
process string escapes
full user operator support
fix expression parser properly to handle things like between
[:] array slices
aggregate: all and distinct
multi dimensional arrays: selectors and subscripting
isnull, notnull, is [ not ] distinct from, is unknown, is not unknown
ops: |/ ||/ ! !! $ | # ~ << >>
substring regex variants
position(in), trim(both from), overlay
like, ilike, ~~ , etc.
similar to
matches: ~ ~* !~ !~*
datetime extract
time zone
geometric, text search, array operators <- should be covered by user
   operator stuff
any, some, all subquery ops

