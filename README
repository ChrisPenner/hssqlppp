A very rough parser and pretty printer for postgresql sql and plpgsql

Partially supports:
select statements (selectlists (*, qualified, aliased, expressions)
       window functions
       distinct
       from (with explicit joins - natural, inner, cross, left, right,
       full outer, on and using, aliases, from functions)
       where, group by, order by, limit
       except, intersect, union

expressions: subselects, in, row ctors, strings + dollar strings,
             integers, case, exists, boolean literals, null, arrays
             and subscripting (slightly limited), function calls,
             identifiers, cast(x as y), between (quite limited),
             substring(x from a for b)

also partially supports:
insert (with multiple values and select support), update, delete with returning
create table, type, view, domain
constraints: not null, null, unique (inline and row), inline check
drop function
sort of skips copy statements instead of erroring
create function for sql and plpgsql functions

plpgsql statements:
        select into
        null
        continue
        perform
        execute
        assignment
        if
        return, return next, return query
        raise
        for (select and integer variants)
        while
        case statement

Many things are missing at the moment, in particular
  selects: having, cte, implicit joins, like expressions
  joins in updates
  constraints: pk, separate row check, references
  alter and drop statements apart from drop function
  transaction commands
  triggers and trigger functions
  loop statement
  error trapping
  cursors
This is a non-exhaustive list.

Other current downsides:

The parse tree node types aren't well designed, it produces a tree
which is more like a ast than a parse tree, which contains no location
information.

No work has been done on correctly rejecting invalid sql and no
thought has been put into error messages and error reporting.

No thought has been given in respects to supporting other sql dialects.


Trying it out

The main thing you can do is try to parse a file of sql and see what
fails. To do this run the ParseFile (.lhs) script and pass the
filename of the sql file to it. It will attempt to parse the file, and
if it succeeds, pretty print then reparse the pretty printed text.

To add support for missing syntax or alter existing support/ fix bugs,
I recommend first altering Tree.lhs to add/change the tree node data
type(s), then altering the pretty printer to output these nodes,
altering the parser to parse them (add new statements to sqlStatement
or plPgsqlStatement function, new expressions to the factor function),
and add one or more test cases to Tests.lhs. This already has
structure set up to parse:

*  fully formed sql (including plpgsql inside create function
   statements)
*  individual/ multiple plpgsql statements without having to use
   createfunction
*  single expressions


Homepage

The project is hosted on launchpad
http://launchpad.net/hssqlppp/

You can get the latest code using bzr:
bzr branch lp:~jakewheat/hssqlppp/trunk

Contact

Let me know if you're using/ interesting in using the library, if you
have any problems or suggestions, etc.

jakewheatmail@gmail.com
