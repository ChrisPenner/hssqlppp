here are some queries that need investigating, and possibly posted to
the appropriate mailing list.

= postgresql questions

is a null literal treated as a unknown string for the purposes of
function resolution, resultset resolution, etc.?

how does the function resolution work for polymorphic functions

what situations can an empty array type check successfully, and when
is it rejected.

is it possible to create a full view of all the casts that are used in
implicit, etc., resolution, i.e. including the ones that aren't in pg_cast

is it correct to use the resolve result set type algo when determining
the type of common fields in a natural or using join?

looking at postgresql-doc-8.4/html/query-path.html, it is unclear
where type checking occurs - is it mainly in a separate stage, or
intermingled in with the other stages

is the way the keyword operators are typed correct (using the function
call match algo to sort the implicit casts)?

how does the parser handle parsing operators without knowing whether
they are prefix, postfix or binary until later

when is the b_expr parser used (should just need a grep over the
grammar file)

is the handling of between, coalesce, greatest, and least correct
(delegating the checks to <= operators or whatever, coalesce uses
resultsetresolution)

why doesn't this work:
select
    att.oid,
    cls.oid,
    cls.relkind,
    cls.relname,
    att.typname
  from pg_type att
  inner join pg_class cls using(oid);

-- column "oid" specified in USING clause does not exist in left table


casting, etc.:
what operator is being used when comparing two composite types for
equality: used to have to create this manually but now works without
this (briefly caused an error but now works either way)
