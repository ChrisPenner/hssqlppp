= TODOs


New todo for next release:

get chaos rewrite mostly done, a few more extensions, etc., to serve
   as example code. rough plan on hssqlppp side is: module extension
   work?, insert extension, actions? stack tables? custom syntax? more
   quasiquoting?, inclusions, readonly triggers, botify, system
   implementation objects and generate documentation from module info
add docs to show chaos as example code
   plus add rendering of type checking process, catalog, and things
   like that
write wrappers and sort out small example code
tidy hssqlsystem, not sure about moving to the new exe style
nav for website, get the copyright notices only appearing at the
   bottom - it seems a bit loony at the moment
extension usage tests - in client code?
error handling work
not going to start working much on missing syntax and type checks
maybe typeinfo conversion
database connection settings
catalog extras for chaos
roundtrip work
lots of the little fixes below
not going to work on markup and rendering of source much
not planning on doing nullability, however, this is a major
   feature. Not that much point until the hlist wrapper is working
   again



some of the small fixes:

web site: add links from the examples generate from the test files to
   the pandoc'd version of the respective test file source

idea for example code in haddock: put the example code in self
   contained lhs files which can be compiled and run, then either link
   or include this source into the haddock. otherwise this stuff goes
   stale which is really bad to serve as an example.

for the web site: for each file generated from source, txt, sql, lhs,
   etc., link to the actual source code file.



This file is a complete disorganised mess.
----------

add flag to parser to switch between parsing splices or not
convert error to either in conversion from anti to regular ast

sort out documentation:
fix data: make hssqlsystem nicer, work on wrapper examples and
  library source files
nav: create a 'sitemap' thing, and nav bar and breadcrumbs to each
   page
work on rendering source - issues with markdown, embedded sql, etc.

getting a catalog from a database involves reading the updates then
   applying them, which is bizarre, sort it out

add tests for extensions actually working by using them in a database

focus: website/documentation, examples
       missing catalog elements: triggers, sequences, constraints, indexes, defaults
       do command line wrapper generator thing for hssqlsystem
       do examples processor for hssqlsystem
       work on extensions for chaos - get completed, change how tests
         are done, etc., sort out chaos code itself. One idea, robbed
         from makelabels in hlist, is to write an example bit of
         target sql for each extension, parse this, then use generics to swap in
         the correct identifiers - like a poor mans quasi-quoting.
         find a way to get listen working from haskell
       work on roundtrip tests - get working for chaos
doc work todos:
check pandoc & haddock slowness with defaulttemplate1catalog
check pandoc hang with big ast in hssqlsystem example, other places
tidy code, get rendering nicely with pandoc

also:
get returning * working, count *
fix how implicit joins type check now that code has been refactored to
   make this easy

then:
make list of loose ends, syntax and missing type checks - lots of
   missing checks when updating catalog
convert type to Maybe TypeInfo, add a bunch of newtypes, typedefs,
   etc., separate out types and add some sum types to make more
   typesafe, investigate first
error handling
nullability inference
find a way of doing database connections better: full command line
   options, ability to prompt for password, config file support, and
   support for full connection options, e.g. host and port as well as
   db name.
look into pretty printing: type errors, annotations, cat diffs are big
   areas which are currently crap

-----------
old New approach:
list todos for next release or next few releases
lists todos for first alpha release
list future plans/ ideas

for alpha release
review unsupported syntax and make list to be done for alpha and what
   will not be done
typechecking - want all parsable syntax to type check properly as much
   as possible
fix lexing of symbols, e.g. =? doesn't work
add parsing and typechecking support at least for all operators in
   default catalog

future plans:
much more annotations - account of function match lookup process,
   inferred types, references to definition point e.g. for local
   identifiers, and all sorts
better extensions to plpgsql
better macro system for plpgsql
support for typeclasses, monads, algebraic datatypes and pattern matching?
possibly break into multiple packages
documentation generator for plpgsql and database

notes about parse tree:
would like to support things like making not null the default for
   table columns rather than null.
can't do this at the moment since implicit null and explicit null both
   look the same in the ast after parsing
so, go whole hog: think about parsing to a modified ast which tries to
   accurately represent the source code itself, so we can pretty print
   back and e.g. not add implicit defaults, add parens, etc.
then have a canonicalize process which adds in all the defaults
think about how flexible this should be:
1) force all type checked trees to be canonicalized -> nice and simple
2) allow typechecking of non canonicalized trees -> will make type
   checking more complicated, but also remove the need for a separate
   set of data types for the parse tree and the aast.
what about putting explicit parenthesis in this parse tree, this might
   make it feasible to support the full range of operators that
   postgresql supports, and support e.g. the creation of an operator
   followed by it's use

some other ideas

show used catalog, work with module extension as well
better pretty printers for annotation types
extensions code tidy?
annotation generics style
non sql syntax extensions work - need a set of hooks, a separate
   module which exposes all the parser combinators, and some extended
   parse functions //or preprocessor of some sort

convert ag files into lag for consistency - no support for birdfeet
   style in uuagc?

plpgsql stuff: blocks, assignments in declarations, strict into,
   labels,loops,continue
look into running test suite from cabal

=== types and internal errors handling

look at all the places where type lists are wrapped in
   unnamedcomposite and get rid of most of them - just use the type
   list directly.
Look at all the contexts where pg types can be used, and split into
   separate haskell types, and use sums to put them back together
   to use the haskell type system better e.g. different set of types
   can be used for an attribute in a table, for a function parameter,
   function return type, variable declaration, etc. - want to use the
   haskell type system to enforce this and get rid of a load of
   runtime checks (mainly the unwrap setof, etc. in typetype). - or is
   there a better way of doing this?

=== parse/typecheck errors to user

investigate alternative parser libs which can e.g. continue parsing
   after an error to provide more parse errors at once.
write a show for parsec errors which formats the lex tokens and
   expected lists properly (was broken when moved to the separate
   lexer)

=== schemas

think of a way to handle schemas, what about changes to schema search
   path mid code.

=== catalog and bindings annotation

Add the current bindings as annotation everywhere, this can be used by
   the ambiguous identifier checks, etc., and to understand errors
also: add annotations to the catalog so we can see where an entity in
   the catalog has come from, what update and what source
   line. similar for localbindings - use
   this for a command than can make hyperlinked source

=== casting annotation

for each casting operation, add a log which explains what the relevant
   algorithm has done to either find the appropriate cast or what it's
   considered before failing. (e.g. can provide a list of steps taken
   with the candidate lists in the findcallmatch routine, might be
   useful for errors when it can't find a match, and if it is calling
   an unexpected function instead of the one you want).

null treatment
Basic motivation is to keep nulls carefully walled off, controlled,
   and be able to catch them when they sneak back into expressions,
   etc.. For each value, etc. we determine statically if it might be
   null. This can be done for return types of functions, fields in a
   select expression, etc.. (will do mappings e.g. if a functions
   inputs are all non null, then the output is non null, etc.). Once
   this is working ok, the second stage is to implement the anti null
   warnings/ errors.
Allow nulls in tables, outer joins, in coalesce, to be produced by
   selects (maybe add or remove from this allowed list, maybe make it
   configurable on a per project basis).
Never allow nulls to be an argument to a function call, (including
   ops, keyword ops, etc.). So every time you have a field being used
   in an expression and it cannot be statically verified to be non
   null, you have to insert a coalesce or fix it in some other way.
So nulls can still be used to represent optional values, n/a,
   etc.. and output to clients doing selects, but there is no need to
   grapple with:
* 3vl (or whatever it is that sql uses instead),
* what the result of a function call is if the some or all the
  arguments are null,
* what the result of a sum aggregate is if some of the values are null,
* etc.,
because none of these things are allowed.

=== shadowed identifier test

use the bindings annotation to add warnings

=== modules extension

stage 1: set the current module with a function call
do creating the module and adding objects to the current module using
   extension instead of the sql functions used at the moment
find a way to annotate the source with modules stuff, want to use it
   for documentation
stage 2: add import/export stuff and check this

=== other extensions for chaos
mark generated code with annotation: make annotation types open with type
   class or something? - can get rid of typeerrora, statementinfoa
   wrappers this way
check for all ddl, etc. run in functions/executes and turn into
   extensions so the type checker can see these things
out of order definitions: want to write defs in any order and
   have the extension reorder them into something which can be loaded
   into postgres
finish create_var extension: add constraints
constraint system: make a bunch of stuff automatic, like using 'pg
   accelerators'
add notify triggers automatically, including for views
convert the sql tests (maybe some of the haskell tests) into static
   checks on the ast
find a better way to work with the tables with null fields:
  initial values - the copy statements are completely unreadable and
   uneditable
  what else? - what combinations of fields can be null at the same
   time?
crufty bits to try and simplify: turn sequence progression, action
   valid tables, ai
see if can make the multiple update hack more automatic

=== development/deployment support:
build file for development, just lists sql files in order, and lists
   which extensions are used - this will be a haskell/ config file,
   which uses a library to make it executable
deployment: use system to load all sql via extensions into pg, then
to a regular pg dump which can then be deployed - have automated thing
   for this

think about where can use quickcheck

=== testing
work on making the tests more comprehensive, want a test for each
   branch/option where feasible - get some coverage testing on, don't
   know how well this will work with uuagc generated code - maybe add
   a cull unused uuagc generated code utility

=== precedence and operator parsing
add missing operators to parser
see if @ as prefix and infix just works in parsec
some a_expr and b_expr support properly by looking at pg grammar file

---------
some random notes

literal sql mode, with workspace idea: can write code/sql inline
in the source, and run it against a database and view the results
inline like in some text books where code is executed then the results
printed inline into the result - so this is a partial replacement for
   ghci, emacs haskell-mode ghci, psql, maybe bash, maybe ide, and
   also a runtime diagnosis tool which can be embedded into production
   exes. Pretty ambitious, need to focus on useful and easy features.

variant:
hssqlppp workspace: text view can type in commands and get results
   back, create multiple workspaces and they're persistent, maybe
   a wrapper round ghci but not conventional repl style, more like
   entering elisp and evaluating it in emacs? want to use
   as replacement for the ghci thing in emacs, and as a shell for working with
   the ast stuff and actual databases

use template haskell to simplify generics in extensions: cases and
   replacements are a bit verbose and difficult to write and read?


= parse and/or type check todo list:
(rough/incomplete)
"identifier"
6.5e-5
type 'string' style type cast
[:] slice
missing keyword ops
default template1 operators should all parse
agg(all expr) agg(distinct expr), agg(*)
window frame clauses, named windows
parse inside string literals when cast, for common types
multidimensional arrays
default values
serial
make sure can type check everything that parses
constraint names
provide list of keys in info for create/alter table: include unique
   not null and serials
type check fks, and other constraints
alter table: add/remove column
                        constraint
                        default value
                        column type
                        rename column
                        rename table
what other alters/creates
views, functions, operators, types, domains, triggers, rules
selects:
implicit joins
group by, having + group by with unaggregated and aggregated fields
distinct, on
order by - do properly
limit, offset
with queries
type modifiers
data type names with spaces in them
timestamps
schemas
alternative text for true and false
enums
geometric types weird syntax
composites: selector variants, rowctors, component get/update
do all keyword and template1 operators
any/some/all subqueries and arrays
check over rowwise comparisons
indexes: create/alter/drop

another todo list:
catalog:
constraints, pg_constraint
triggers
rules
indexes
add drops for all creates
review which alters to add
default columns values + insert checking
support pks,fks better
support serial properly
type modifiers
sequences
enums
listen, notify, pg_listener
blocks in plpgsql, assignments in declarations, not null checking
strict in into
lables, loops, exit, continue
raise % counts
create schema

once all this is done, work on documenting precisely what is supported
   and what isn't.

================================================================================

some syntax todo, not organised:

------------
add support for following sql syntax (+ type checking)
alter table, common variations
create index
create rule
create trigger
+ drops for all creates
+ maybe alters?
ctes
loop, exit, labels
easy ones: transactions, savepoints, listen
prepare, execute + using
some more:
create or replace
alter table
transactions: begin, checkpoint, commit, end, rollback
cursors: declare, open, fetch, move, close, where current of
copy - parse properly
create database
create index
create rule
create trigger + plpgsql support
grant,revoke
listen, notify, unlisten
prepare, execute
savepoint, release savepoint, rollback to savepoint
set, reset
set constraints
set role
set transaction
correlated subquery attrs

plpgsql

blocks which aren't at the top level of a function
% types
strict on intos
not null for var defs
exception
execute using
get diagnostics
return query execute
raise missing bits
out params
elsif
loop
exit
labels
reverse, by in for
for in execute

expressions:
process string escapes, support dollar quoting and other quoting more
   robustly in the pretty printer
full user operator support (?)
fix expression parser properly to handle things like between - see
   grammar in pg source for info on how to do this
[:] array slices
aggregate: all and distinct
multi dimensional arrays: selectors and subscripting
missing keyword operators
datetime extract
time zone
subquery operators: any, some, all
in general, parsing operators is wrong, the lexer needs to be able to
   lex sequences of symbols into single/multiple operators correctly,
   what happens at the moment is a kludge, also, general operator
   parsing will change how operators are represented in the ast

----

plpgsql on 'roids:
write libraries in haskell, and then write syntax extensions for
   plpgsql using the extension mechanism to access these libs from
   extended plpgsql e.g. ui lib written in haskell, accessed by syntax
   extensions in plpgsql then can write the database and ui all in the
   same source code in the same language, with first class support for
   properly typed relation valued expressions, avoiding multiple
   languages and mapping/'impedance mismatch' between database types
   and types in the language you write the ui in.
