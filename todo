= next release, 0.5.0

complete basic typechecking for queryexpr and scalexpr
add typechecking for dml
parameterized query typechecking + get param type util fn
go through old tests and redo most of them?
-> want to get much better coverage of typechecking

rough todo for exprs:
scalar expr:
liftapp
queryexpr:
withqueryexpr
combineQueryExpr
values
funtrefs

fix order by env (see add qualifiers on tpch sql order bys)
group by qualifier issue

error messages are broken for lexing,parsing? when used in quoting

get ghc 6.12.x working again: think it is just adding the
   control.monad.error stuff back it


idea for :: cast

-> parse typenames as scalarexpressions by embeding them in
   numberlits (hacky but should be unambiguous) - or antictors?
then transform to cast after parsing. This can then use the proper
precedence in buildExpressionParser to parse ::. Also produce parse
errors if after parsing, you try to cast to something which isn't a
typename

could do something similar for other operators: '.', [], in?

add support for enum types

= 'arcs'

== continue with rewrite of catalog and typeconversion

typeconversion code is a complete mess

== alpha version

high quality postgresql dialect parsing for most sql and plpgsql
good enough typechecking for select,insert,update,delete:
  the goal is high quality result types for correct sql, but not
  neccessarily catching all errors for incorrect sql
definitely include typesafe embedded sql lib

possibly good enough typechecking for ddl and plpgsql to handle chaos?

then for version 2 can target high quality with errors, plus good
support for ddl, and reasonable support for plpgsql (will always
reject some correct plpgsql)

todo: make detailed todo list for this

== out of tree builds

make file build out of tree

== names

support schema qualification, and check the existing use of names
carefully

== localenv

finish off new typechecking for crud.

== ddl and plpgsql

typechecking has regressed to zero for these, bring them back up

== typesafe wrapper

write typesafe wrapper for haskell accessing database
want to use extensible records, not sure what the options are:
could use haskell records or fc-labels and not use extensible records?
other possible options are hlist, haskelldb records
can fc-labels or a competitor be used with extensible records?

nullability inference would be useful here, also possibly single
column in result specialisation, and static check of single tuple in
result (e.g. where on key, or non grouped aggregates).


== api

review api names, docs and other aspects, lots of suspect/bizarrely
named types and ctors

== website nav

especially useful when source, chaos example working again

== examples

add compilation of examples to automated tests, also add tests in the
documentation

=== adding syntax example

provide some more hacking examples and support in the code:
add a new ctor to existing node
add a new kind of node
include simple instructions to fail gracefully at typechecking, so new
  syntax plus parsing and pretty printing can be easily added
review parsing code and try to make it clearer for the confusing bits,
  also the lexer

== uuagc ?postprocessor

docs: write a preprocessor for the .hs produced from the .ag
want to add the LANGUAGE directives
and also add the haddock docs which get stripped out
and also convert some of the data type definitions to use record syntax
want to do this automatically, not sure how can parse the original ag
  though?

have explicit list of data types in astinternal that want to do this for
start with annotation as example:
find the complete definition of annotation in astinternal.hs
want to replace part of this, would like to avoid killing other
comments in astinternal.hs
find the original definition of annotation in the ag files
a) parse out the haddock string for each field
b) parse out the field name and type for each field
replace the def in astinternal with the replacement:
include haddock strings
use record syntax for data def

what to do this for:
ctor with lots of components in the ast -> particularly queryexpr
annotation is really poor without docs


== nullablity inference in type checker

== syntax refactoring

lots of messy bits in the syntax:

some renames - try to follow the sql standard reference better

split out the plpgsql statements to separate ast node

more faithful representation of source code? This is mainly for
defaults, e.g. can't tell after parsing if an order by element was
explicitly asc, or implicitly asc. This might be useful for lint
checking e.g.. Also might make it easier to handle different sql
dialects with different defaults.

== ag - review code add fixmes

review ag code (and other code?) add fixme notes

== ag - preprocessing?

want to add the language pragma in the make file to simplify the ghc
calls and manual compilation
also would like to use record syntax for a lot of the data types in
the ag, and not lose the haddock documentation.

not sure if uuagc supports this, it would be easy to add to uuagc, or
if a separate preprocessor which runs on the ag and the hs after uuagc
is the easiest way

== typechecking regressions fix
lots of disabled tests, get them all passing again

== chaos

work on the chaos example
* get it typechecking OK again - lots of work on typechecker needed
* get the unit tests running again: maybe quickest is to port to new haskelldb
* get the ui running again so you can actually see it running
* maybe port these over to hssqlppp typesafe access for dogfooding
* fix the documentation generator which shows the translated sql -
  fair few prerequisites to this
* use new custom syntax stuff
* use the sql documentation generator (from the catalog)

add parsing and typechecking chaos (+ others?) to automated tests

== doctool

get the standalone doctool working. Get the website documentation
generator working again

== h7c

work on the functionality. want to get it working as a library to
compile chaos without needing to look at the hssqlppp lib
internals. The main blocker is fixing the syntax and then exposing the
parser internals for extension use.

== catalog work

the catalog holds pretty limited information at the moment, and
doesn't use that information to type check ddl very well (e.g. reject
drop on non existent objects, don't allow two tables with same name,
etc.)
so
* add much better error checking
* add much more information to support error checking
* track more types of objects, e.g. triggers, indexes
* add more information to support documentation generator, e.g. view
  source, function source, cross-linked hypertext sources

== quasiquote work

want to add a lot more quasiquotes. Good start would be to review all
the extensions, and translation examples, codegen, etc.. and make sure
you never need to write asts out explicitly, and can always use
quasiquotes.

Another thing to add is full haskell syntax inside quasiquotes. No
idea how to do this but the language-c-quote package does this so can
look at the source there.

== refactoring

review the code and refactor the crufty bits. Also want much better
documentation in the .lhs. Main code to completely rewrite is
TypeConversion.lhs which was written when I didn't know haskell (or
postgresql typechecking) very well.

== error handling

review to eliminate any errors being hidden, or calls to 'error'

== custom syntax plugins

want to be able to plugin new syntax into parser - so alter syntax
tree as well. maybe start with the ability to add new statement types,
and new expressions types only.

== work through pg manual to get more complete coverage of sql syntax

== roundtrip testing

use postgresql to help with testing:

parse ddl, get catalog
load sql into postgresql, read catalog from pg
compare
dump database, parse dump and check catalog from hssqlppp is the same

parse sql
load into postgresql
dump
parse again
check is equivalent (might be very hard in general case)

some quickcheck style testing:
generate random ast
(maybe stick to scalar expression to start with?)
typecheck with hssqlppp
load into postgresql and get type out
check types are the same

== report generator

the idea is to have the following for experimentation, evaluate how
   well hssqlppp supports some existing sql, support while developing
   sql (possibly with syntax extensions), and generating
   documentation:
take source sql:
standard postgresql sql in text files
sql taken from postgresql dump from live db
syntax extended sql in text files
do some or all of the following:
parse and type check - report problems
parse, pretty print, reparse and check
generate documentation, catalog
load into postgresql and double check catalog from typechecker
load and dump postgresql, reparse and typecheck for changes

== documentation generator for sql codebases

== fix operator parsing
fix expression parsing and custom operators: stage one is to do a hack
which supplies the parser with the operator details at run time so
there is some flexibility

full dynamic support: e.g. create operators in sql then able to parse
use of them ... standard way of dealing with operator precedence is to
parse them all as left associative then adjust the tree after, not
sure this will be enough -> perhaps can reuse the haskell-src-exts
fixity thing for rewriting trees - will have to add parens explicitly
to the ast and parser, which might be tricky for sql?

== write extensions?

materialized view, temporal data, generalized inclusions, order
independent ddl source, show used catalog, modules for sql source

== lint

lint tool framework - so want to make it easy to add new rules

== better annotation approach?

maybe try to parameterize on annotation type? lots of other techniques
