{-


This file contains the type checking code for the expression ast data
type.


attributes:
annotatedTree - usual
backTree - usual
loc.tpe - usual
The bottom up types (the usual type checking) are in uType (as well as in the annotatedTree
loc.prototype: the matched prototype for a function call

-}

--gather the backtree, type errors and types together and add annotations
SEM ScalarExpr
    | IntegerLit StringLit FloatLit BooleanLit NullLit FunCall Identifier
      QIdentifier
      Exists Case CaseSimple Cast InPredicate ScalarSubQuery LiftOperator
      PositionalArg Placeholder WindowFn TypedStringLit Interval
        lhs.annotatedTree = updateAnnotation
                              (setTypeAddErrorsA @loc.tpe
                               . \a -> a {fnProt = @loc.prototype
                                         ,infType = msum [@lhs.expectedType -- from parameterized statements
                                                         ,etmt @loc.tpe
                                                         ,Nothing]}) @loc.backTree
        loc.tpe : Et

SEM ScalarExpr
    | IntegerLit StringLit FloatLit BooleanLit NullLit Identifier
      QIdentifier
      Exists Case CaseSimple Cast InPredicate ScalarSubQuery LiftOperator
      PositionalArg Placeholder WindowFn TypedStringLit Interval
        loc.prototype : {Maybe FunctionPrototype}
        loc.prototype = Nothing

ATTR ScalarExpr [|| uType : {Maybe Type}]

SEM ScalarExpr
    | IntegerLit StringLit FloatLit BooleanLit NullLit FunCall Identifier QIdentifier
      Exists Case CaseSimple Cast InPredicate ScalarSubQuery LiftOperator
      PositionalArg Placeholder WindowFn TypedStringLit Interval
        lhs.uType = etmt @loc.tpe

SEM ScalarExprList
    | Cons lhs.uType = @hd.uType : @tl.uType
    | Nil lhs.uType = []


ATTR ScalarExprListList [||uType : {[[Maybe Type]]}]

ATTR ScalarExprList [||uType : {[Maybe Type]}]


SEM ScalarExprListList
    | Cons lhs.uType = @hd.uType : @tl.uType
    | Nil lhs.uType = []


ATTR MaybeScalarExpr  [||uType : {Maybe Type}]

SEM MaybeScalarExpr
    | Just lhs.uType = @just.uType
    | Nothing lhs.uType = Nothing

-- maybe bool expression: if present, then check its type is bool

SEM MaybeBoolExpr
    | Just
        lhs.annotatedTree = let t = @just.uType
                            in if t `elem` [Nothing,Just typeBool]
                               then Just @just.annotatedTree
                               else Just $ addTypeErrors [ExpressionMustBeBool] @just.annotatedTree

{-
== literals

pretty straightforward
-}

SEM ScalarExpr
     | IntegerLit loc.tpe = Right typeInt
     | StringLit loc.tpe = Right UnknownType
     | FloatLit loc.tpe = Right typeNumeric
     | BooleanLit loc.tpe = Right typeBool
     -- I think a null has the same type resolution as an unknown string lit
     | NullLit loc.tpe = Right UnknownType

SEM ScalarExpr
    | IntegerLit
        loc.backTree = IntegerLit @ann @i
    | StringLit
        loc.backTree = StringLit @ann @value
    | FloatLit
        loc.backTree = FloatLit @ann @d
    | BooleanLit
        loc.backTree = BooleanLit @ann @b
    | NullLit
        loc.backTree = NullLit @ann

SEM ScalarExpr
    | Interval loc.tpe = Right $ ScalarType "interval"
               loc.backTree = Interval @ann @value @field @prec


{-

== cast expression

all the work is done in the typename node
-}

SEM ScalarExpr
    | Cast loc.tpe = lmt @tn.namedType
           loc.backTree = Cast @ann @expr.annotatedTree @tn.annotatedTree

SEM ScalarExpr
    | TypedStringLit
         loc.tpe = lmt @tn.namedType
         loc.backTree = TypedStringLit @ann @tn.annotatedTree @value


{-
== operators and functions
-}
SEM ScalarExpr
    | FunCall
        (loc.tpe
        ,loc.prototype) = either (\e -> (Left e, Nothing)) id $ do
                          args <- mapM lmt @args.uType
                          efp <- findCallMatch @lhs.cat
                                               @funName
                                               args
                          let (_,_,r,_) = efp
                          return (Right r, Just efp)


        loc.backTree = FunCall @ann @funName @args.annotatedTree


   | WindowFn
        loc.tpe = lmt @fn.uType
        loc.backTree = WindowFn @ann
                                @fn.annotatedTree
                                @partitionBy.annotatedTree
                                @orderBy.annotatedTree
                                @dir
                                @frm
{-
lifted operator:
pretty much the same as haskell 'any (lhs [op]) rhss' (or all instead of any)
where lhs is the first argument and rhss is the second argument
which must be an array

pg allows the rhss to also be a subselect, this is a todo

-}

SEM ScalarExpr
    | LiftOperator
        loc.tpe = do
                  at <- mapM lmt @args.uType
                  errorWhen (length at /= 2)
                            [AnyAllError $ "must have two args, got " ++ show at]
                  let [aType,bType] = at
                  errorWhen (not $ isArrayType bType)
                            [AnyAllError $ "second arg must be array, got " ++ show at]
                  elemType <- unwrapArray $ bType
                  resType <- fmap (\(_,_,r,_) -> r) $ findCallMatch @lhs.cat
                                                                    @oper
                                                                    [aType,elemType]
                  errorWhen (resType /= typeBool)
                            [AnyAllError $ "operator must have bool return, got " ++ show resType]
                  return resType
        loc.backTree = LiftOperator @ann @oper @flav @args.annotatedTree


{-
== case expression

for non simple cases, we need all the when expressions to be bool, and
then to collect the types of the then parts to see if we can resolve a
common type

for simple cases, we need to check all the when parts have the same type
as the value to check against, then we collect the then parts as above.

-}

ATTR CaseScalarExprListScalarExprPairList [||whenTypes : {[[Maybe Type]]}
                                             thenTypes : {[Maybe Type]}]
SEM CaseScalarExprListScalarExprPairList
  | Cons lhs.whenTypes = @hd.whenTypes : @tl.whenTypes
         lhs.thenTypes = @hd.thenType : @tl.thenTypes
  | Nil lhs.whenTypes = []
        lhs.thenTypes = []

ATTR CaseScalarExprListScalarExprPair [||whenTypes : {[Maybe Type]}
                                         thenType : {Maybe Type}]

SEM CaseScalarExprListScalarExprPair
    | Tuple lhs.whenTypes = @x1.uType
            lhs.thenType = @x2.uType


SEM ScalarExpr
    | Case CaseSimple
        loc.whenTypes = @cases.whenTypes
        loc.thenTypes = @cases.thenTypes ++ maybe [] ((:[]) . Just) @els.uType

SEM ScalarExpr
    | Case
        loc.tpe = do
                  wt <- mapM lmt $ concat @loc.whenTypes
                  -- probably the when types shoule be checked inside each when node
                  -- and type errors attach there, and ignored here
                  errorWhen (any (/= typeBool) wt)
                      [WrongTypes typeBool wt]
                  tt <- mapM lmt @loc.thenTypes
                  resolveResultSetType @lhs.cat tt
        loc.backTree = Case @ann @cases.annotatedTree @els.annotatedTree


SEM ScalarExpr
    | CaseSimple
        loc.tpe =
          do
          wt <- mapM lmt $ concat @loc.whenTypes
          vt <- lmt @value.uType
          _ <- resolveResultSetType @lhs.cat (vt : wt)
          tt <- mapM lmt @loc.thenTypes
          resolveResultSetType @lhs.cat tt
        loc.backTree = CaseSimple @ann
                                  @value.annotatedTree
                                  @cases.annotatedTree
                                  @els.annotatedTree

{-
== identifiers
pull id types out of cat for identifiers

-}

SEM ScalarExpr
   | Identifier
        loc.tpe = case lookupLocalBinding @lhs.lib "" @i of
                                        Right Nothing -> Left []
                                        Right (Just t) -> Right t
                                        Left e -> Left e
                     -- unwrapLookup <$> lbLookupID @lhs.lib [@i]
        loc.backTree = Identifier @ann @i
   | QIdentifier
        loc.tpe = case @loc.qid of
                            Nothing -> Left [InternalError "dot selection not implemented"] --byT
                            Just q -> case lookupLocalBinding @lhs.lib q @i of
                                        Right Nothing -> Left []
                                        Right (Just t) -> Right t
                                        Left e -> Left e

                            --either (const byT) Right $ unwrapLookup <$> lbLookupID @lhs.lib [q,@i]
                  {-where
                    byT = do
                      (t::Type) <- lmt @qual.uType --unwrapLookup <$> lbLookupID @lhs.lib [q]
                      unwrapLookup <$> lbLookupIDInType @lhs.cat @lhs.lib t @i-}
        loc.qid : {Maybe String}
        loc.qid = case @loc.backTree of
                     QIdentifier _ (Identifier _ q) _ -> Just q
                     _ -> Nothing
        loc.backTree = QIdentifier @ann @loc.qAnnTreeNoUnrec @i

        loc.qAnnTreeNoUnrec = updateAnnotation (\a -> a {errs = []}) @qual.annotatedTree

SEM ScalarExpr
    | PositionalArg
        loc.tpe = unwrapLookup <$> lbLookupID @lhs.lib ['$':show @p]
        loc.backTree = PositionalArg @ann @p


SEM ScalarExpr
    | Placeholder
        loc.tpe = Right UnknownType
        loc.backTree = Placeholder @ann

-- exists: will work on any subselect so we don't need to do any checking
SEM ScalarExpr
    | Exists
        loc.tpe = Right typeBool
        loc.backTree = Exists @ann @sel.annotatedTree


{-
== scalar subquery
1 col -> type of that col
2 + cols -> row type
-}

SEM ScalarExpr
    | ScalarSubQuery
        loc.tpe =
            do
            selType <- lmt (map snd <$> @sel.uType)
            case length selType of
              0 -> Left [InternalError "no columns in scalar subquery?"]
              1 -> Right $ head selType
              _ -> Right $ AnonymousRecordType selType

        loc.backTree = ScalarSubQuery @ann @sel.annotatedTree
{-
== inlist
todo: make the ast and typechecking a special case of lifted operator
-}

SEM ScalarExpr
    | InPredicate
        loc.tpe = do
                  lt <- @list.listType
                  expt <- lmt @expr.uType
                  _ <- resolveResultSetType @lhs.cat [expt, lt]
                  return typeBool
        loc.backTree = InPredicate @ann
                                   @expr.annotatedTree
                                   @i
                                   @list.annotatedTree


ATTR InList [||listType : {Either [TypeError] Type}]

SEM InList
    | InList
        lhs.listType = mapM lmt @exprs.uType >>= resolveResultSetType @lhs.cat
    | InQueryExpr
        lhs.listType =
            do
            st <- lmt (map snd <$> @sel.uType)
            case length st of
                      0 -> Left [InternalError
                                 "got subquery with no columns? in inselect"]
                      1 -> Right $ head st
                      _ -> Right $ AnonymousRecordType st
