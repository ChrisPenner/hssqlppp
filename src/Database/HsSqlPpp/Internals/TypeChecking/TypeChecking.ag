
-- public api functions
{

-- | some options when typechecking
data TypeCheckingFlags =
    TypeCheckingFlags
    { -- | add qualifiers to unqualified ids where possible
     tcfAddQualifiers :: Bool
     -- | add full aliases to every tableref and subselect
    ,tcfAddFullTablerefAliases :: Bool
     -- | add explicit aliases to all select items
    ,tcfAddSelectItemAliases :: Bool
     -- | expand stars in select lists to explicit list columns
    ,tcfExpandStars :: Bool}
    deriving (Show,Eq)


-- | reasonable defaults for type checking, doesn't add anything
-- optional
defaultTypeCheckingFlags :: TypeCheckingFlags
defaultTypeCheckingFlags =
    TypeCheckingFlags
    {tcfAddQualifiers = False
    ,tcfAddFullTablerefAliases = False
    ,tcfAddSelectItemAliases = False
    ,tcfExpandStars = False}

-- | Typechecks the ast, and returns the updated catalog (which
-- includes changes from any ddl statements in the ast).
typeCheckStatements :: TypeCheckingFlags -> Catalog -> [Statement] -> (Catalog,[Statement])
typeCheckStatements f cat sts =
    let t = sem_Root (Root sts)
        ta = wrap_Root t Inh_Root {cat_Inh_Root = cat
                                  ,flags_Inh_Root = f
                                  {-,lib_Inh_Root = emptyBindings
                                  ,idenv_Inh_Root = emptyIDEnv "tcs"-}}
        tl = annotatedTree_Syn_Root ta
        cat1 = cat --producedCat_Syn_Root ta
    in case tl of
         Root r -> (cat1,r)
-- | Typecheck a query expr
typeCheckQueryExpr :: TypeCheckingFlags -> Catalog -> QueryExpr -> QueryExpr
typeCheckQueryExpr f cat qe =
   let (_,[QueryStatement _ qe']) = typeCheckStatements f cat [QueryStatement emptyAnnotation qe]
   in qe'

-- | Not working yet. Typechecks a statement possibly containing ?
-- placeholders. These are annotated with the 'inferred type', and the
-- stType annotation on the return value can be used to get this info
-- easily. Returns Left if the statement is not a query,insert,update or delete
-- statement
typeCheckParameterizedStatement :: TypeCheckingFlags -> Catalog -> Statement -> Either String Statement
typeCheckParameterizedStatement f cat st =
    case st of
      QueryStatement _ _ -> tc
      Insert _ _ _ _ _ -> tc
      Update _ _ _ _ _ _ -> tc
      Delete _ _ _ _ _ -> tc
      _ -> Left "requires select, update, insert or delete statement"
    where
      tc = let tl = typeCheckStatements f cat [st]
           in case tl of
                (_,[st1]) -> Right st1
                _ -> error "impossible happened in typeCheckPS!"


-- | type check a scalar expr
typeCheckScalarExpr :: TypeCheckingFlags -> Catalog -> ScalarExpr -> ScalarExpr
typeCheckScalarExpr f cat ex =
    let t = sem_ScalarExprRoot (ScalarExprRoot ex)
        rt = (annotatedTree_Syn_ScalarExprRoot
              (wrap_ScalarExprRoot t Inh_ScalarExprRoot {cat_Inh_ScalarExprRoot = cat
                                                        ,flags_Inh_ScalarExprRoot = f
                                                        {-,lib_Inh_ScalarExprRoot = emptyBindings
                                                        ,idenv_Inh_ScalarExprRoot = emptyIDEnv "t
cse"-}}))
    in case rt of
         ScalarExprRoot e -> e

}

{-

main global attributes

-}

attr AllNodes Root ScalarExprRoot Annotation
  inh cat :: Catalog
     ,flags :: TypeCheckingFlags
  syn annotatedTree :: SELF -- annotated tree is the output tree with the types added
     ,originalTree :: SELF -- this is the original tree, should not be changed

-- the types and errors are pulled out of the attributes, which
-- are set by the sem for each type/ ctor in the various files in
-- TypeChecking/ and put into the annotated tree output

attr Annotation
  inh tpe :: {Either [TypeError] Type}

attr AllNodes Annotation
  inh imCast :: {Maybe Type}

sem Root
   | Root
       statements.imCast = Nothing
sem ScalarExprRoot
   | ScalarExprRoot
       expr.imCast = Nothing

sem Annotation
  | Annotation
      lhs.annotatedTree =
          let t = either (const Nothing) Just @lhs.tpe
              es = either id (const []) @lhs.tpe
          in Annotation @anSrc t es @lhs.imCast @anCatUpd


include "TypeChecking/ScalarExprs.ag"
include "TypeChecking/QueryExprs/QueryExprs.ag"
include "TypeChecking/Misc.ag"
include  "TypeChecking/Statements.ag"

{

-- | run on a typechecked tree. Finds all the places where an implicit
-- cast has been used in the typechecking and inserts an explicit cast
addExplicitCasts :: Data a => a -> a
addExplicitCasts = transformBi removeDoubleCasts . transformBi addCast
  where
    addCast :: ScalarExpr -> ScalarExpr
    addCast e = fromMaybe e $ do
                  t <- anImplicitCast (getAnnotation e)
                  n <- nameOfType t
                  return $ Cast emptyAnnotation e n
    -- addCast isn't very smart, so remove any unneeded casts
    -- that it has inserted
    -- not sure if this is correct, are there legitimate
    -- uses of double casts?
    -- one possible solution is to not add the implicit cast
    -- annotation to items immediately in a cast
    -- this might clash with the intended approach of typeing
    -- parameterized statements?
    removeDoubleCasts :: ScalarExpr -> ScalarExpr
    removeDoubleCasts e = case e of
      (Cast a (Cast _ e' _t1) t) -> Cast a e' t
      e' -> e'

nameOfType :: Type -> Maybe TypeName
nameOfType (ScalarType t) = Just $ SimpleTypeName emptyAnnotation (Name emptyAnnotation [Nmc t])
nameOfType (DomainType t) = Just $ SimpleTypeName emptyAnnotation (Name emptyAnnotation [Nmc t])
nameOfType (EnumType t) = Just $ SimpleTypeName emptyAnnotation (Name emptyAnnotation [Nmc t])
nameOfType (NamedCompositeType t) = Just $ SimpleTypeName emptyAnnotation (Name emptyAnnotation [Nmc t])
nameOfType _ = Nothing

}