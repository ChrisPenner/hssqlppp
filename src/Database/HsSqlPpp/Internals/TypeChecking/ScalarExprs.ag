{-

type checking scalar exprs

annotations to get are the type and type errors, and the implicit cast
The implicit cast is determined by the parent node and comes through
in an attribute

the implicit cast says if an implicit cast is used, what type is being
cast to.

not applicable: parameterizedstatementtype, catalog update

plus also store the matched functionprototype for functions. Is this
to help with getting the type of ? placeholders, and for inserting

-}

sem ScalarExpr
    | NumberLit StringLit NullLit BooleanLit TypedStringLit Interval
      Extract PositionalArg Placeholder Cast Star QStar Identifier
      QIdentifier Case CaseSimple Exists App AggregateApp
      WindowApp InPredicate LiftApp ScalarSubQuery
      BinaryOp PrefixOp PostfixOp SpecialOp
        ann.tpe = @loc.tpe
        lhs.upType = either (const Nothing) Just @loc.tpe

sem ScalarExpr
    | AntiScalarExpr
        lhs.upType = either (const Nothing) Just @loc.tpe


attr ScalarExpr
  inh downEnv :: Environment -- the environment from the parent
  syn upType :: {Maybe Type} -- the type of this node made available to the parent node


-- collect the uptypes for a list of scalarexprs

attr ScalarExprList
  inh downEnv :: Environment
  syn upTypes :: {[Maybe Type]}

sem ScalarExprList
    | Cons lhs.upTypes = @hd.upType : @tl.upTypes
    | Nil lhs.upTypes = []


{-
each ctor has its own typechecking code

this sets loc.tpe with either the succesfully determined type, or the
type errors. The typechecking is shortcircuited so that if a node
needs the type of another node which is unable to type check, then no
additional type errors are produced, this is represented in the
annotation for the type as Nothing, and in loc.tpe as Left []

not sure it's worth the indirection of writing to loc.tpe then to
ann.tpe

-}

{-

------------------------------------------------

simple literals

-}

sem ScalarExpr
    | BooleanLit
        loc.tpe = Right typeBool

    | NumberLit
        -- numbers - a bit hacky, maybe should follow haskell
        -- and represent as integers and rationals instead of strings
        -- here just sets as int if there is no decimal place
        -- probably the support for different syntax for numbers
        -- needs to improve a lot then this won't be possible any
        -- more (e.g. 10e-5)
        loc.tpe = Right $ if all (`elem` @loc.digChars) @d
                          then typeInt
                          else typeNumeric
        loc.digChars = concatMap show [(0::Int)..9]

    | StringLit
        -- string lit type comes from the context
        loc.tpe = Right UnknownType
    -- I think a null has the same type resolution as an unknown string lit
    | NullLit
         loc.tpe = Right UnknownType

{-

----------------------------------
simplish ctors

-}

    | TypedStringLit Cast
         loc.tpe = maybe (Left []) Right @tn.namedType
    | Interval
         loc.tpe = Right $ ScalarType "interval"
    | Extract
         loc.tpe = -- check the argument is a date
                   do
                   x <- maybe (Left []) Right @e.upType
                   if x == typeDate
                     then Right typeFloat8
                     else Left [NoMatchingOperator "extract" [x]]
    | Placeholder
         loc.tpe = Right UnknownType
{-

---------------------------------------
identifiers

-}
    | Identifier
         loc.elkp = envLookupIdentifier [@i] @lhs.downEnv
         loc.tpe = fmap snd @loc.elkp
         lhs.annotatedTree =
           fromMaybe @annotatedTree $ do
               case tcfAddQualifiers @lhs.flags of
                 False -> Nothing
                 True -> do
                        ((q,i),_) <- either (const Nothing) Just @loc.elkp
                        -- todo: quote identifiers if needed
                        return $ QIdentifier @ann.annotatedTree [Nmc q, Nmc i]

    | QIdentifier
         loc.tpe = fmap snd $ envLookupIdentifier @is @lhs.downEnv


{-

---------------------------------------

op calls, fn calls, etc.

-}


    | App
         loc.tpe =
           case @originalTree of
             (App _ (Name _ [Nmc "count"]) [Star _]) ->
                 tcAppLike @lhs.cat @funName.originalTree [Just UnknownType]
             _ -> tcAppLike @lhs.cat @funName.originalTree @args.upTypes
    | BinaryOp
         loc.tpe = tcAppLike @lhs.cat @opName.originalTree [@arg0.upType,@arg1.upType]
    | PrefixOp
         loc.tpe = tcAppLike @lhs.cat @opName.originalTree [@arg.upType]
    | PostfixOp
         loc.tpe = tcAppLike @lhs.cat @opName.originalTree [@arg.upType]
    | SpecialOp
         loc.tpe = tcAppLike @lhs.cat @opName.originalTree @args.upTypes
    | AggregateApp
         loc.tpe =
           case @fn.originalTree of
             (App _ fnm@(Name _ [Nmc "count"]) [Star _]) ->
                 tcAppLike @lhs.cat fnm [Just UnknownType]
             _ -> maybe (Left []) Right @fn.upType

{
tcAppLike :: Catalog -> Name -> [Maybe Type] -> Either [TypeError] Type
tcAppLike cat anm args = do
  -- get the types of the arguments
  -- then lookup in TypeConversion.matchApp
  tys <- mapM (maybe (Left []) Right) args
  let Name _ ns = anm
  (_,rt) <- matchApp cat ns tys
  return rt

}
{-
--------------------------------------------

case

-}

{-
---------------------------------

subqueries

-}

-- exists: will work on any subselect so no checking needed
sem ScalarExpr
    | Exists
        loc.tpe = Right typeBool

{-
== scalarsubquery
1 col -> type of that col
2 + cols -> row type with those components
-}

sem ScalarExpr
    | ScalarSubQuery
        loc.tpe =
            do
            selType <- maybe (Left []) Right @sel.upType
            case length selType of
              0 -> Left [InternalError "no columns in scalar subquery?"]
              1 -> Right $ snd $ head selType
              _ -> Right $ AnonymousCompositeType $ map snd selType

        -- support for correlated subqueries
        sel.outerDownEnv = Just @lhs.downEnv
    | Exists
        sel.outerDownEnv = Just @lhs.downEnv

{-
-----------------------------------------------
fallback for unimplemented ctors

-}

-- temp
sem ScalarExpr
    | PositionalArg Star QStar
      Case CaseSimple
      WindowApp InPredicate LiftApp AntiScalarExpr
        loc.tpe = Left []
