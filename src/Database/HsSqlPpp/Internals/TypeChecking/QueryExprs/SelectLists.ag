
{-
select lists:

select lists have to gather the column names of the select items along
with their types, this is to produce the type and environment to the
parent

also have to deal with optionally expanding stars and adding explicit
aliases

The main work is done in the scalarexpr nodes:
each node produces:

a column name which is used if the node appears directly in a
selectitem that select item has no explicit alias

a maybe type (this is just the uptype attr duplicated)

a scalar expr copy

but since we have to handle stars, which produce a list of these, it
produces a list of (name,type,expr) triples (so this is why the type
and the expr itself are duplicated)

These lists of triples are only used by selectitems.

-}

attr ScalarExpr
  syn colExprs :: {[(String,Maybe Type,ScalarExpr)]}


sem ScalarExpr
    | NumberLit StringLit NullLit BooleanLit TypedStringLit Interval
      Extract PositionalArg Placeholder Cast Identifier
      QIdentifier Case CaseSimple Exists App AggregateApp
      WindowApp InPredicate LiftApp ScalarSubQuery
      BinaryOp PrefixOp PostfixOp SpecialOp
      Star QStar
      lhs.colExprs =
          let a = @ann.originalTree --save the source position in the generated nodes
              doStar is = -- todo: quote identifiers if needed
                map (\((q,n),t) ->
                      -- have to typecheck manually here since the generate nodes
                      -- don't participate in the ag
                  let a' = setAtype (Just t) a
                      -- expanded stars always output qualifier
                  in (n, Just t, QIdentifier a' [Nmc q,Nmc n])
                  ) is
          in case @originalTree of
              Star _ | Right is <- envExpandStar Nothing @lhs.downEnv ->
                 doStar is
              QStar _ q | Right is <- envExpandStar (Just q) @lhs.downEnv ->
                 doStar is
              -- for everything other than star and qstar, just lift
              -- the single expr info into a list
              _ -> [(columnName @originalTree,@upType,@annotatedTree)]

{-
select items:

1. adjust the colExprs data if the select item has an explicit column
alias

2. add an explicit column alias if there isn't one and the option to
add them is set

-}

sem SelectItem
  | SelectItem
      lhs.colExprs =
        case @ex.colExprs of
          [(_,t,e)] -> [(ncStr @name, t,e)]
          x -> x --todo: error if there is an alias and more that one col
  | SelExp
      lhs.annotatedTree =
        if tcfAddSelectItemAliases @lhs.flags
        then case @ex.colExprs of
               [(n,_,_)] -> SelectItem @ann.annotatedTree @ex.annotatedTree (Nmc n)
               _ -> -- todo: is this possible? what should happen?
                    @annotatedTree
        else @annotatedTree
{-
select item list:

this is where the expanded stars are spliced back into the annotated
tree attributes if that option is enabled
-}
sem SelectItemList
  | Nil lhs.annotatedTree = []
  | Cons lhs.annotatedTree =
      if tcfExpandStars @lhs.flags
      then flip map @colExprs $ \(n,_t,e) ->
          -- todos: add sourceposition annotation
          -- this adds aliases for all columns
          -- want to keep the original select items
          -- for each col which doesn't come from a star expand
          -- and when add column aliases option is off
          -- hack currently used probably isn't accurate:
          -- check if adding an explicit column name changes the
          -- name of a column then add it, otherwise use implicit
            if n == columnName e && not (tcfAddSelectItemAliases @lhs.flags)
            then SelExp emptyAnnotation e
            else SelectItem emptyAnnotation e (Nmc n)
      else @annotatedTree


attr SelectItem
  syn colExprs :: {[(String,Maybe Type,ScalarExpr)]}
  inh downEnv :: Environment

attr SelectItemList SelectList
  inh downEnv :: Environment
  syn colExprs :: {[(String,Maybe Type,ScalarExpr)]}
  syn upType :: {Maybe [(String,Type)]}
  syn upEnv :: Environment


{-

select item list: just concat the colExprs to produce the new colExprs
used if this is the tail of a select item list

create the uptype from the local colexprs used if this is the head of
a select item list

-}
sem SelectItemList
  | Nil lhs.colExprs = []
        loc.upType = Nothing
  | Cons
        loc.colExprs = @hd.colExprs ++ @tl.colExprs
        lhs.colExprs = @loc.colExprs
        loc.upType = sequence $ flip map @loc.colExprs
                     $ \(n,t,_) -> fmap (n,) t
  | Nil Cons
      lhs.upType = @loc.upType
      lhs.upEnv = case fmap envSelectListEnvironment @loc.upType of
                    (Just (Right e)) -> e
                    _ -> emptyEnvironment


-- temporary, lots of possible errors above which are currently
-- dropped on the floor have to find their way into the tree

sem SelectList
    | SelectList
      ann.tpe = Left []
sem SelectItem
    | SelectItem SelExp
      ann.tpe = Left []

{

-- | thet name to choose for a column in a select list which doesn't
-- have an explicit name - these are postgresql's rules
columnName :: ScalarExpr -> String
columnName (Identifier _ i) = nm i
columnName (QIdentifier _ is) = nm $ last is
columnName (App _ (Name _ ncs) _) = nm $ last ncs
columnName (Cast _ _ (SimpleTypeName _ (Name _ ncs))) = nm $ last ncs
columnName (WindowApp _ (App _ (Name _ ncs) _) _ _ _) = nm $ last ncs
columnName (AggregateApp _ _ (App _ (Name _ ncs) _) _) = nm $ last ncs
columnName _ = "?column?"
-- quick hack together
nm :: NameComponent -> String
nm (Nmc n) = map toLower n
nm (QNmc n) = n
}
