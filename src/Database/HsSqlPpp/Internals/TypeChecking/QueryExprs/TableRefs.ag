
-- upenv is the environment produced by the tablerefs

attr TableRefList
     syn upEnv :: Environment

attr TableRef
     syn upEnv :: Environment

-- combine a tref list using cross joins

sem TableRefList
  | Nil lhs.upEnv = emptyEnvironment
  | Cons
      lhs.upEnv = if isEmptyEnv @tl.upEnv
                  then @hd.upEnv
                  else --problem: where to put the error?
                         either (error . show) id $
                         createJoinTrefEnvironment @lhs.cat @hd.upEnv @tl.upEnv $ Just []


-- boilerplate: pass any error from the env to the annotation
-- pass any successful env in the upEnv
sem TableRef
  | Tref JoinTref SubTref FunTref
      loc.eEnv :: {Either [TypeError] Environment}
      loc.eEnv2 =
        case @alias.originalTree of
          NoAlias _ -> @loc.eEnv
          TableAlias _ t ->
            fmap (createTrefAliasedEnvironment (ncStr t) Nothing)
                 @loc.eEnv
          FullAlias _ t cs ->
            fmap (createTrefAliasedEnvironment (ncStr t)
                                               (Just $ map ncStr cs))
                 @loc.eEnv

      -- pass any errors to the annotation
      ann.tpe = either Left (const $ Left []) @loc.eEnv
      -- todo: what to do here?
      lhs.upEnv = either (const brokeEnvironment) id @loc.eEnv2

  | JoinTref SubTref FunTref
      -- try to add a full table alias if possible
      -- not possible for some joins
      alias.newAlias =
        if tcfAddFullTablerefAliases @lhs.flags
        then do
          env <- either (const Nothing) Just @loc.eEnv2
          cs <- either (const Nothing) Just $ envExpandStar Nothing env
          let qs = map (fst . fst) cs
          if all (== head qs) qs
            then return (head qs, map (snd.fst) cs)
            else Nothing
        else Nothing
  | Tref
      -- special case for tref, the expand star will give the
      -- system columns too, which we don't want
      alias.newAlias =
        if tcfAddFullTablerefAliases @lhs.flags
        then do
          (n,cs,_) <- either (const Nothing) Just
                        $ catLookupTableAndAttrs @lhs.cat
                        (nameComponents @tbl.originalTree)
          return (n, (map fst cs))
        else Nothing

attr TableAlias
  inh newAlias :: {Maybe (String,[String])}

sem TableAlias
  | NoAlias TableAlias FullAlias
      lhs.annotatedTree =
        case @lhs.newAlias of
          Nothing -> @annotatedTree
          Just (t,cs) -> underAlias @annotatedTree t cs

{
underAlias :: TableAlias -> String -> [String] -> TableAlias
underAlias (NoAlias a) t cs = FullAlias a (Nmc t) (map Nmc cs)
underAlias (TableAlias a t) _ cs = FullAlias a t (map Nmc cs)
underAlias a@(FullAlias {}) _ _  = a
}

-- actual environment creation - this is the interesting bit in this file
sem TableRef
  | Tref
      -- if the referenced table doesn't exist, want to attach the error
      -- only to the name node. So this code should be fixed to get a Maybe [NameComponent]
      -- attribute from the @tbl or something
      loc.eEnv = envCreateTrefEnvironment @lhs.cat (nameComponents @tbl.originalTree)
      tbl.tpe = Left []

  | JoinTref
      loc.eEnv = createJoinTrefEnvironment @lhs.cat
                   @tbl0.upEnv @tbl1.upEnv
                   $ case (@joinType,@onExpr.originalTree) of
                      -- natural join
                      (x,Nothing) | x /= Cross -> Nothing
                      -- using join
                      (_,Just (JoinUsing _ nms)) -> Just nms
                      -- cross join
                      _ -> Just []
      -- this triggers uuagcs cycle detection, not sure why
      onExpr.downEnv = either (const brokeEnvironment) id @loc.eEnv
  | SubTref
      loc.eEnv = maybe (Left []) id
                 $ fmap envSelectListEnvironment @sel.upType


-- temp until code written
sem TableRef
  | FunTref
      loc.eEnv = Left []

sem TableAlias
    | NoAlias TableAlias FullAlias
        ann.tpe = Left []

attr OnExpr
  inh downEnv :: Environment

