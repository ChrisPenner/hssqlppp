
-- upenv is the environment produced by the tablerefs

attr TableRefList
     syn upEnv :: Environment

attr TableRef
     syn upEnv :: Environment

-- support for passing environment down into onexprs
attr OnExpr
  inh downEnv :: Environment


-- combine a tref list using cross joins

sem TableRefList
  | Nil lhs.upEnv = emptyEnvironment
  | Cons
      lhs.upEnv = if isEmptyEnv @tl.upEnv
                  then @hd.upEnv
                  else --problem: where to put the error?
                         either (error . show) id $
                         createJoinTrefEnvironment @lhs.cat @hd.upEnv @tl.upEnv $ Just []

--  | Nil lhs.annotatedTree = []
--  | Cons lhs.annotatedTree = @hd.aliasedAnnotatedTree : @tl.annotatedTree

-- boilerplate: pass any error from the env to the annotation
-- pass any successful env in the upEnv
sem TableRef
  | Tref FunTref SubTref JoinTref TableAlias FullAlias TableRefParens
      loc.eEnv :: {Either [TypeError] Environment}
      -- pass any errors to the annotation
      ann.tpe = either Left (const $ Left []) @loc.eEnv
      -- todo: what to do here?
      lhs.upEnv = either (const brokeEnvironment) id @loc.eEnv

-- create the actual environments

  | Tref
      -- if the referenced table doesn't exist, want to attach the error
      -- only to the name node. So this code should be fixed to get a Maybe [NameComponent]
      -- attribute from the @tbl or something
      loc.eEnv = envCreateTrefEnvironment @lhs.cat (nameComponents @tbl.originalTree)
      tbl.tpe = Left []

  | JoinTref
      loc.eEnv = createJoinTrefEnvironment @lhs.cat
                   @tbl0.upEnv @tbl1.upEnv
                   $ case (@joinType,@onExpr.originalTree) of
                      -- natural join
                      (x,Nothing) | x /= Cross -> Nothing
                      -- using join
                      (_,Just (JoinUsing _ nms)) -> Just nms
                      -- cross join
                      _ -> Just []
      -- this triggers uuagcs cycle detection, not sure why
      onExpr.downEnv = either (const brokeEnvironment) id @loc.eEnv
  | SubTref
      loc.eEnv = maybe (Left []) id
                 $ fmap envSelectListEnvironment @sel.upType
  | TableRefParens
      loc.eEnv = Right $ @tbl.upEnv
  | FullAlias
      loc.eEnv = Right $ createTrefAliasedEnvironment
                         (ncStr @tb) (Just $ map ncStr @cols) @tbl.upEnv
  | TableAlias
      loc.eEnv = Right $ createTrefAliasedEnvironment
                         (ncStr @tb) Nothing @tbl.upEnv
  | FunTref
      loc.eEnv = Left []


--attr TableRef
--  syn aliasedAnnotatedTree :: TableRef

-- todo: use this to implement adding aliases

sem TableRef
  | Tref FunTref JoinTref TableRefParens
      lhs.annotatedTree =
          let mk (q,is) = FullAlias emptyAnnotation
                                   (Nmc q)
                                   (map Nmc is)
                                   @annotatedTree
          in maybe @annotatedTree mk @loc.newAlias

--  | SubTref

--  | TableAlias FullAlias
--      lhs.annotatedTree = @annotatedTree

-- createTrefAliasedEnvironment :: String -> Maybe [String] -> Environment -> Environment

sem TableRef
  | JoinTref FunTref TableRefParens
      -- try to add a full table alias if possible
      -- not possible for some joins
      loc.newAlias =
        if tcfAddFullTablerefAliases @lhs.flags
        then do
          env <- either (const Nothing) Just @loc.eEnv
          cs <- either (const Nothing) Just $ envExpandStar Nothing env
          let qs = map (fst . fst) cs
          if all (== head qs) qs
            then return (head qs, map (snd.fst) cs)
            else Nothing
        else Nothing
  | Tref
      -- special case for tref, the expand star will give the
      -- system columns too, which we don't want
      loc.newAlias =
        if tcfAddFullTablerefAliases @lhs.flags
        then do
          (n,cs,_) <- either (const Nothing) Just
                        $ catLookupTableAndAttrs @lhs.cat
                        (nameComponents @tbl.originalTree)
          return (n, (map fst cs))
        else Nothing
  | FullAlias TableAlias

{-attr TableAlias
  inh newAlias :: {Maybe (String,[String])}

sem TableAlias
  | NoAlias TableAlias FullAlias
      lhs.annotatedTree =
        case @lhs.newAlias of
          Nothing -> @annotatedTree
          Just (t,cs) -> underAlias @annotatedTree t cs

{
underAlias :: TableAlias -> String -> [String] -> TableAlias
underAlias (NoAlias a) t cs = FullAlias a (Nmc t) (map Nmc cs)
underAlias (TableAlias a t) _ cs = FullAlias a t (map Nmc cs)
underAlias a@(FullAlias {}) _ _  = a
}

-- actual environment creation - this is the interesting bit in this file

sem TableRef
  | Tref
      -- if the referenced table doesn't exist, want to attach the error
      -- only to the name node. So this code should be fixed to get a Maybe [NameComponent]
      -- attribute from the @tbl or something
      loc.eEnv = envCreateTrefEnvironment @lhs.cat (nameComponents @tbl.originalTree)
      tbl.tpe = Left []

  | JoinTref
      loc.eEnv = createJoinTrefEnvironment @lhs.cat
                   @tbl0.upEnv @tbl1.upEnv
                   $ case (@joinType,@onExpr.originalTree) of
                      -- natural join
                      (x,Nothing) | x /= Cross -> Nothing
                      -- using join
                      (_,Just (JoinUsing _ nms)) -> Just nms
                      -- cross join
                      _ -> Just []
      -- this triggers uuagcs cycle detection, not sure why
      onExpr.downEnv = either (const brokeEnvironment) id @loc.eEnv
  | SubTref
      loc.eEnv = maybe (Left []) id
                 $ fmap envSelectListEnvironment @sel.upType


-- temp until code written
sem TableRef
  | FunTref
      loc.eEnv = Left []

sem TableAlias
    | NoAlias TableAlias FullAlias
        ann.tpe = Left []
-}


