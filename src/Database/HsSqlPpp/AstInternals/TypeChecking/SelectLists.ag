{-
Copyright 2009 Jake Wheat

This file contains the code that handles the select list part of a
select expression.

TODO: stop wrapping string,type lists in unnamedcompositetypes, pointless

-}

-- this is in the wrong file
--ATTR SelectExpression [||libUpdates : {[LocalBindingsUpdate]}]

ATTR MaybeSelectList [||listType : {[(String,Type)]}]

ATTR SelectItemList SelectList [||listType : {[(String,Type)]}]

{
{-data SiType = SiType (String,Maybe Type)
            | SiStarType [(String,Maybe Type)]-}
}

ATTR SelectItem [||itemType : {[(String,Type)]}]

ATTR SelectList [||libUpdates : {[LocalBindingsUpdate]}]

-- ATTR SelectItem [||columnName : String]


SEM SelectItem
    | SelExp
        -- allow star expansions for unaliased elements
        loc.annotatedTree = SelExp @ann @ex.ntAnnotatedTree
    | SelectItem
        loc.annotatedTree = SelectItem @ann @ex.annotatedTree @name


SEM MaybeSelectList
    | Just lhs.listType = @just.listType
    | Nothing lhs.listType = []

SEM SelectItemList
    | Cons lhs.listType = @hd.itemType ++ @tl.listType
    | Nil lhs.listType = []


{-

a function returning setof can only be used in a select item list (i
think?), where it creates a kind of join so
(a,b,setof c,d) where c returns (c1,c2,...)
expands to
(a,b,c1,d)
(a,b,c2,d)
(a,b,...,d)
so the type of that column is the type wrapped with setof

-}
SEM SelectItem
    | SelExp
        lhs.itemType = unwrapSetofs @ex.ntType
    | SelectItem
        lhs.itemType = case @ex.ntType of
                         [(_,t)] -> [(@name, unwrapSetof t)]
                         _ -> [] --error?

{
unwrapSetofs :: [(String,Type)] -> [(String,Type)]
unwrapSetofs = map (\(n,t) -> (n, unwrapSetof t))

unwrapSetof :: Type -> Type
unwrapSetof (SetOfType u) = u
unwrapSetof v = v

}


SEM SelectList
    | SelectList
        lhs.listType = @items.listType
        loc.intoFroms : {E ([(String,Type)],[(String,Type)])}
        loc.intoFroms =
          -- get the name and type of the assigning to identifiers
          -- and the type of the assigning from vars
          returnWhen (@into == []) ([],[]) $ do
          intoTypes <- either (Left . concat) Right $ listEither $ map getIntoType @into
          -- special case when the intoTypes is a single composite type
          let ft = @items.listType
          return (intoTypes,ft)
          where
            getIntoType :: Expression -> E (String,Type)
            getIntoType n = do
                            let n1 = getName n
                            t <- unwrapLookup <$> lbLookupID @lhs.lib n1
                            return (n1,t)
        loc.tpe =
            returnWhen (@into == []) () $ do
            (it,ft) <- @loc.intoFroms
            checkAssignmentsValid @lhs.cat (map snd ft) (map snd it)

        lhs.libUpdates =
            maybe [] id $ do
            _ <- etmt @loc.tpe
            (it,ft) <- etmt @loc.intoFroms
            -- not complete, we only cope with situation when
            -- assigning to a single record type on its own
            return $ case it of
              [(n,PgRecord _)] -> [LBIds "set record actual fields from select into"
                                         Nothing
                                         [(n,PgRecord $ Just $ CompositeType ft)]]
              _ -> []

{-
somewhere this has gone wrong.
we need @items.listType to be maybe [(String,Maybe Type)]
not [(String,Type)]
this is only so we can give better error messages
it doesn't make any difference when it type checks

we need the outer maybe to say the types feeding in have gone
completely wrong, so don't add any more errors

we need the maybes on the types to keep the columns lined up, so that
e.g. if we have

select t1,typerror,t3 into a,b,c ...

we don't get weird type errors as it tries to assign to the wrong
vars,

-}


        lhs.annotatedTree = addTypeErrors (tes @loc.tpe) $
                            SelectList @ann
                                       @items.annotatedTree
                                       @into
--[(@var,@loc.selType)]

{
isPgRecord :: Type -> Bool
isPgRecord (PgRecord _) = True
isPgRecord _ = False
}