{-
Copyright 2009 Jake Wheat

This file contains the code that handles the select list part of a
select expression.

TODO: stop wrapping string,type lists in unnamedcompositetypes, pointless

-}

-- this is in the wrong file
--ATTR SelectExpression [||libUpdates : {[LocalBindingsUpdate]}]

ATTR MaybeSelectList [||listType : {[(String,Type)]}]

ATTR SelectItemList SelectList [||listType : {[(String,Type)]}]

{
{-data SiType = SiType (String,Maybe Type)
            | SiStarType [(String,Maybe Type)]-}
}

ATTR SelectItem [||itemType : {[(String,Type)]}]

-- ATTR SelectList [||libUpdates : {[LocalBindingsUpdate]}]

-- ATTR SelectItem [||columnName : String]


SEM SelectItem
    | SelExp
        -- allow star expansions for unaliased elements
        loc.annotatedTree = SelExp @ann @ex.ntAnnotatedTree
    | SelectItem
        loc.annotatedTree = SelectItem @ann @ex.annotatedTree @name


SEM MaybeSelectList
    | Just lhs.listType = @just.listType
    | Nothing lhs.listType = []

SEM SelectItemList
    | Cons lhs.listType = @hd.itemType ++ @tl.listType
    | Nil lhs.listType = []


{-

a function returning setof can only be used in a select item list (i
think?), where it creates a kind of join so
(a,b,setof c,d) where c returns (c1,c2,...)
expands to
(a,b,c1,d)
(a,b,c2,d)
(a,b,...,d)
so the type of that column is the type wrapped with setof

-}
SEM SelectItem
    | SelExp
        lhs.itemType = @ex.ntType
                       {-do
                       t <- getTypeAnnotation @ex.ntAnnotatedTree
                       case t of
                            SetOfType u -> return u
                            v -> return v-}
    | SelectItem
        lhs.itemType = maybe [] id $ do
                       t <- getTypeAnnotation @ex.annotatedTree
                       return [(@name,t)]



SEM SelectList
    | SelectList
        lhs.listType = @items.listType
        loc.tpe =
            returnWhen (@into == []) (()) $ do
            -- let intoType = map (lbLookupID @lhs.lib) @into
            intoTypes <- either (Left . concat) Right $ listEither $ map (lbLookupID @lhs.lib) @into
            let fromTypes = map snd @items.listType
            checkAssignmentValid @lhs.cat
                                 (AnonymousRecordType fromTypes)
                                 (AnonymousRecordType intoTypes)
{-
somewhere this has gone wrong.
we need @items.listType to be maybe [(String,Maybe Type)]
not [(String,Type)]
this is only so we can give better error messages
it doesn't make any difference when it type checks

we need the outer maybe to say the types feeding in have gone
completely wrong, so don't add any more errors

we need the maybes on the types to keep the columns lined up, so that
e.g. if we have

select t1,typerror,t3 into a,b,c ...

we don't get weird type errors as it tries to assign to the wrong
vars,

-}


        lhs.annotatedTree = addTypeErrors (tes @loc.tpe) $
                            SelectList @ann
                                       @items.annotatedTree
                                       @into
        {-lhs.libUpdates =
            case @loc.stuff of
              (_,Just r) -> [LBIds "set record actual fields from select into" ""
                              [r] []]
              _ -> []-}
--[(@var,@loc.selType)]

SEM Statement
    | SelectStatement
        loc.libUpdates = undefined -- @ex.libUpdates

