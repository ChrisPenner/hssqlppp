{-
Copyright 2009 Jake Wheat

This file contains the code that handles the select list part of a
select expression.

TODO: stop wrapping string,type lists in unnamedcompositetypes, pointless

-}

-- this is in the wrong file
--ATTR SelectExpression [||libUpdates : {[LocalBindingsUpdate]}]

ATTR MaybeSelectList [||listType : {Maybe [(String,Maybe Type)]}]

ATTR SelectItemList SelectList [||listType : {[(String,Maybe Type)]}]

{
{-data SiType = SiType (String,Maybe Type)
            | SiStarType [(String,Maybe Type)]-}
}

ATTR SelectItem [||itemType : {Maybe Type}]

-- ATTR SelectList [||libUpdates : {[LocalBindingsUpdate]}]

-- ATTR SelectItem [||columnName : String]


SEM SelectItem
    | SelExp
        loc.annotatedTree = SelExp @ann {- $ fixStar-} @ex.annotatedTree
    | SelectItem
        loc.annotatedTree = SelectItem @ann {-(fixStar-} @ex.annotatedTree {-)-} @name


SEM MaybeSelectList
    | Just lhs.listType = Just @just.listType
    | Nothing lhs.listType = Nothing

SEM SelectItemList
    | Cons lhs.listType = (@hd.columnName, @hd.itemType) : @tl.listType
                {-case @hd.itemType of
                  Just (SiType (a,t)) -> (a,Just t) : @tl.listType
                  Just (SiStarType ps) -> ps ++ @tl.listType
                  Nothing -> @tl.listType-}
    | Nil lhs.listType = []


{-

a function returning setof can only be used in a select item list (i
think?), where it creates a kind of join so
(a,b,setof c,d) where c returns (c1,c2,...)
expands to
(a,b,c1,d)
(a,b,c2,d)
(a,b,...,d)
so the type of that column is the type wrapped with setof

-}
SEM SelectItem
    | SelExp SelectItem
        lhs.itemType = do
                       t <- getTypeAnnotation @ex.annotatedTree
                       case t of
                            SetOfType u -> return u
                            v -> return v



SEM SelectList
    | SelectList
        lhs.listType = @items.listType
        loc.tpe =
            returnWhen (@into == []) (()) $ do
            -- let intoType = map (lbLookupID @lhs.lib) @into
            intoTypes <- either (Left . concat) Right $ listEither $ map (lbLookupID @lhs.lib) @into
            fromTypes <- mapM (lmt . (\(a,b) -> case b of
                                                 Nothing -> Nothing
                                                 Just b1 -> Just b1)) @items.listType
            checkAssignmentValid @lhs.cat
                                 (AnonymousRecordType fromTypes)
                                 (AnonymousRecordType intoTypes)

        lhs.annotatedTree = addTypeErrors (tes @loc.tpe) $
                            SelectList @ann
                                       @items.annotatedTree
                                       @into
        {-lhs.libUpdates =
            case @loc.stuff of
              (_,Just r) -> [LBIds "set record actual fields from select into" ""
                              [r] []]
              _ -> []-}
--[(@var,@loc.selType)]

SEM Statement
    | SelectStatement
        loc.libUpdates = undefined -- @ex.libUpdates


{-SEM SelectExpression
    | Select
        lhs.libUpdates = @selSelectList.libUpdates
    | CombineSelect Values
        lhs.libUpdates = []-}

-- utils to handle a star, bit hacky, maybe should use a separate pass
-- or something?
{-
{
expandStar :: LocalBindings
           -> String
           -> Type
           -> [(String,Type)]
           -> [(String,Type)]
expandStar lb colName colType types =
    fromRight types $ do
    let (cn,iden) = splitIdentifier colName
    newCols <- if iden == "*"
                 then lbExpandStar lb cn
                 else return [(iden, colType)]
    return $ newCols ++ types

fixStar :: Expression -> Expression
fixStar =
    everywhere (mkT fixStar')
    where
      fixStar' :: Annotation -> Annotation
      fixStar' a =
          undefined {-
          if TypeAnnotation TypeCheckFailed `elem` a
              && any (\an ->
                       case an of
                         TypeErrorA (UnrecognisedIdentifier x) |
                           let (_,iden) = splitIdentifier x
                           in iden == "*" -> True
                         _ -> False) a
             then filter (\an -> case an of
                                   TypeAnnotation TypeCheckFailed -> False
                                   TypeErrorA (UnrecognisedIdentifier _) -> False
                                   _ -> True) a
             else a-}
}
-}

{-

================================================================================

= attribute names

columnName is used to collect the column names that the select list
produces, it is combined into an unnamedcompositetype in
selectitemlist, which is also where star expansion happens.

-}


{-
if the select item is just an identifier, then that column is named
after the identifier
e.g. select a, b as c, b + c from d, gives three columns one named
a, one named c, and one unnamed, even though only one has an alias
if the select item is a function or aggregate call at the top level,
then it is named after that function or aggregate

if it is a cast, the column is named after the target data type name
iff it is a simple type name

-}

--default value for non identifier nodes

{-
override for identifier nodes, this only makes it out to the selectitem
node if the identifier is not wrapped in parens, function calls, etc.
-}

-- collect the aliases and column names for use by the selectitemlist nodes
{-SEM SelectItem
    | SelExp lhs.columnName = case @ex.liftedColumnName of
                                "" -> "?column?"
                                s -> s
    | SelectItem lhs.columnName = @name-}
