{-
Copyright 2009 Jake Wheat

This file contains the type checking code for dml, currently insert,
update and delete.

================================================================================

= insert

check the insert data is the correct type. Doesn't cope with columns
with default values at the moment.

-}

SEM Statement
    | Insert
        loc.tpe = Right $ Pseudo Void
        loc.statementType : {Maybe StatementType}
        loc.statementType = Just ((getPlaceholderTypes @loc.insDataAddedInferredTypes) (fromMaybe [] @returning.listType))
        loc.columnTypes : {Either [TypeError] [(String,Type)]}
        loc.columnTypes =
            do
            tys <- unwrapSetOfComposite $
                   getTypeAnnotation @insData.annotatedTree
            checkColumnConsistency @lhs.cat
                                   @table
                                   @targetCols
                                   tys
        loc.insDataAddedInferredTypes =
            case @insData.annotatedTree of
              Values ann [exl] -> do
                  fargs <- map snd <$> @loc.columnTypes
                  let newExl = map setInfType $ zip (fargs ++ repeat Nothing) exl
                  return $ Values ann [newExl]
              x -> x
            where
              setInfType :: (Maybe Type,Expression) -> Expression
              setInfType (t,a) = updateAnnotation (\i -> i {infType = t}) a

        loc.backTree = Insert @ann @table @targetCols
                              @loc.insDataAddedInferredTypes @returning.annotatedTree
        loc.catUpdates = []

-- inject the ids into the returning part

SEM Statement
    | Insert
        returning.lib =
            fromRight @lhs.lib $ do
              atts <- catCompositeAttrs @lhs.cat relationComposites @table
              lbUpdate @lhs.cat @lhs.lib $ LBIds "insert target table" "" atts []

{-
================================================================================

= update

check the set clause assignments are ok, and inject ids into the where part

-}

SEM Statement
    | Update
        loc.tpe =
            do
            undefined {-
            checkRelationExists @lhs.cat @table
            --return $ Pseudo Void
            
            dependsOnRTpe (map snd @assigns.pairs) $ do
              _ <- @loc.columnTypes
              -- liftErrors @assigns.rowSetErrors
              return $ Pseudo Void-}
        loc.statementType =
            undefined {-
            leftToEmpty (\_ -> [StatementType (getPlaceholderTypes @loc.assignWInferredTypes
                                                ++ getPlaceholderTypes @whr.annotatedTree)
                                               (fromMaybe [] @returning.listType)])
               @loc.columnTypes-}

        loc.columnTypes =
            checkColumnConsistency @lhs.cat
                                   @table
                                   (map fst @assigns.pairs)
                                   @assigns.pairs
        loc.assignWInferredTypes : SetClauseList
        loc.assignWInferredTypes =
            let colTypes :: [Type]
                colTypes = (map snd $ fromRight [] @loc.columnTypes)
            in setInferredTypesG colTypes @assigns.annotatedTree

        loc.backTree = Update @ann
                              @table
                              @loc.assignWInferredTypes
                              @fromList.annotatedTree
                              @whr.annotatedTree
                              @returning.annotatedTree
        loc.catUpdates = []

{

setInferredTypesG :: Data a => [Type] -> a -> a
setInferredTypesG tys x =
  evalState (transformBiM f x) tys
  where
    f (p@(Placeholder _)) = do
         y:ys <- get
         put ys
         undefined -- return $ updateAnnotation (++ [InferredType y]) p
    f z = return z
}

-- local identifier bindings: pass the table attribute names and types
-- into the where expression, and the set clause expressions

SEM Statement
    | Update
        loc.lib =
             fromRight @lhs.lib $ do
             ct <- catCompositeAttrs @lhs.cat
                                     relationComposites
                                     @table
             lbUpdate @lhs.cat @lhs.lib $ LBIds "updated table attrs" "" ct []
        whr.lib = @loc.lib
        assigns.lib = @loc.lib
        returning.lib = @loc.lib

{-
== set clauses

for each regular set clause, we check the assignment type
-}

ATTR SetClauseList [||pairs : {[(String,Type)]}]

SEM SetClauseList
  | Cons lhs.pairs = @hd.pairs ++ @tl.pairs
         --lhs.rowSetErrors = maybeToList @hd.rowSetError ++ @tl.rowSetErrors
  | Nil lhs.pairs = []
        --lhs.rowSetErrors = []

ATTR SetClause [||pairs : {[(String,Type)]}
                  rowSetError : {Maybe TypeError}]

SEM SetClause
    | SetClause
        lhs.pairs = [(@att, getTypeAnnotation @val.annotatedTree)]
        lhs.rowSetError = Nothing
    | RowSetClause
        loc.rowSetError =
          let atts = @atts
              types = getRowTypes @vals.typeList
          in if length atts /= length types
               then Just WrongNumberOfColumns
               else Nothing
        lhs.pairs = zip @atts $ getRowTypes @vals.typeList

{
getRowTypes :: [Type] -> [Type]
getRowTypes [AnonymousRecordType ts] = ts
getRowTypes ts = ts
}

{-
================================================================================

= delete

pretty simple, mainly just need to inject ids into the where part

-}

SEM Statement
    | Delete
        loc.tpe =
            checkRelationExists @lhs.cat @table >>
            Right (Pseudo Void)
        loc.statementType = undefined {-[StatementType (getPlaceholderTypes @whr.annotatedTree)
                                           (fromMaybe [] @returning.listType)]-}

        loc.backTree = Delete @ann @table @using.annotatedTree @whr.annotatedTree @returning.annotatedTree
        loc.catUpdates = []


SEM Statement
    | Delete
        loc.lib =
            fromRight @lhs.lib $ do
            columnTypes <- catCompositeAttrs @lhs.cat relationComposites @table
            lbUpdate @lhs.cat @lhs.lib $ LBIds "delete table attrs" "" columnTypes []
        whr.lib = @loc.lib
        returning.lib = @loc.lib

{-
================================================================================
-}
{

--small shortcut to help produce better errors?
checkRelationExists :: Catalog -> String -> Either [TypeError] ()
checkRelationExists cat tbl =
    catCompositeDef cat relationComposites tbl >>
    return ()

--used by both insert and update
checkColumnConsistency :: Catalog ->  String -> [String] -> [(String,Type)]
                       -> Either [TypeError] [(String,Type)]
checkColumnConsistency cat tbl cols' insNameTypePairs = do
  ttcols <- lowerize <$> catCompositePublicAttrs cat [] tbl
  let cols = if null cols'
               then map fst ttcols
               else map (map toLower) cols'
  errorWhen (length insNameTypePairs /= length cols) [WrongNumberOfColumns]
  let nonMatchingColumns = cols \\ map fst ttcols
  errorWhen (not $ null nonMatchingColumns) $
       map UnrecognisedIdentifier nonMatchingColumns
  let targetNameTypePairs = map (\l -> (l, fromMaybe (error "dml.ag.chekcolumnconsistency: fromMaybe") $ lookup l ttcols)) cols
        --check the types of the insdata match the column targets
        --name datatype columntype
      typeTriples = map (\((a,b),c) -> (a,b,c)) $
                    zip targetNameTypePairs $
                    map snd insNameTypePairs
      errs :: [TypeError]
      errs = concat $ lefts $
             map (\(_,b,c) -> checkAssignmentValid cat c b) typeTriples
  undefined -- liftErrors errs
  return targetNameTypePairs
  where
    lowerize = map (\(a,b) -> (map toLower a,b))

}
