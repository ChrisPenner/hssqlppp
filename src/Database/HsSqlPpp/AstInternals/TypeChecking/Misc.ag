{-
Copyright 2009 Jake Wheat

Contains bit and pieces of type checking which don't fit anywhere else

================================================================================

= type names

Types with type modifiers (called PrecTypeName here, to be changed),
are not supported at the moment.

-}

ATTR TypeName [||namedType : {Maybe Type}]

SEM TypeName
     | SimpleTypeName ArrayTypeName SetOfTypeName PrecTypeName
         lhs.namedType = etmt @loc.tpe
         lhs.annotatedTree = addTypeErrors (tes @loc.tpe) @loc.backTree

SEM TypeName
     | SimpleTypeName
        loc.tpe = catLookupType @lhs.cat $ canonicalizeTypeName @tn
        loc.backTree = SimpleTypeName @ann @tn
     | ArrayTypeName
        loc.tpe = lmt @typ.namedType >>=  Right . ArrayType
        loc.backTree = ArrayTypeName @ann @typ.annotatedTree
     | SetOfTypeName
        loc.tpe = lmt @typ.namedType >>=  Right . SetOfType
        loc.backTree = SetOfTypeName @ann @typ.annotatedTree
     | PrecTypeName
        loc.tpe = catLookupType @lhs.cat $ canonicalizeTypeName @tn
        loc.backTree = PrecTypeName @ann @tn @prec


{-
================================================================================

= generic node types

-}

--expression list and list list - just collect up the types

ATTR ExpressionList [||typeList : {[Maybe Type]}]

SEM ExpressionList
    | Cons lhs.typeList = getTypeAnnotation @hd.annotatedTree : @tl.typeList
    | Nil lhs.typeList = []


ATTR ExpressionListList  [||typeListList : {[[Maybe Type]]}]

SEM ExpressionListList
    | Cons lhs.typeListList = @hd.typeList : @tl.typeListList
    | Nil lhs.typeListList = []


-- stringlist: collect the strings
--ATTR StringList [||strings : {[String]}]

--SEM StringList
--  | Cons lhs.strings = @hd : @tl.strings
--  | Nil lhs.strings = []

-- maybe bool expression: if present, then check its type is bool

SEM MaybeBoolExpression
    | Just
        lhs.annotatedTree = let t = getTypeAnnotation @just.annotatedTree
                            in if t `elem` [Nothing,Just typeBool]
                               then Just @just.annotatedTree
                               else Just $ addTypeErrors [ExpressionMustBeBool] @just.annotatedTree

{
{-
================================================================================

= some small utils

I think this should be alright, an identifier referenced in an
expression can only have zero or one dot in it.
-}

splitIdentifier :: String -> (String,String)
splitIdentifier s = let (a,b) = span (/= '.') s
                    in if b == ""
                         then ("", a)
                         else (a,tail b)

addTypeErrors :: Data a => [TypeError] -> a -> a
addTypeErrors es el = updateAnnotation u el
                      where
                        u a = a {errs = errs a ++ es}

setTypeAddErrors :: Data a => Et -> a -> a
setTypeAddErrors et el = updateAnnotation (setTypeAddErrorsA et) el

setTypeAddErrorsA :: Et -> Annotation -> Annotation
setTypeAddErrorsA et a =
    let a1 = a {errs = errs a ++ tes et}
    in case atype a1 of
         Just _ -> a1 {errs = errs a
                             ++ [InternalError $ "tried to set type a second time - " ++ show (etmt et)]}
         Nothing -> a1 {atype = etmt et}

keepValid :: [(String,Maybe Type)] -> [(String,Type)]
keepValid = mapMaybe f
            where
              f (a,Just b) = Just (a,b)
              f (_,Nothing) = Nothing

allJust :: [Maybe a] -> Maybe [a]
allJust ts = sequence ts

{-
================================================================================

proper dodgy:
1st pass is to add inferred types to the tree. This is done only for
expressions in a funcall argument list atm. Then we pull out the
placeholders after they've had this information added. Only the
placeholders in funcall argument lists will have their type inferred
in this way, to be expanded. Insert also does this currently, but in Dml.ag

This should probably be done during the typechecking phase instead,
but probably needs a proper type inferencing algorithm to be used, is
done like this for development expediency.

-}
getPlaceholders :: Data a => a -> [Expression]
getPlaceholders st =
    filter isPlaceholder $ everything (++) (mkQ [] ga) (setInferredTypes st)
    where
      ga :: Expression -> [Expression]
      ga s = [s]
      isPlaceholder e = case e of
                          PositionalArg _ _ -> True
                          Placeholder _ -> True
                          _ -> False

getPlaceholderTypes :: Data a => a -> [Maybe Type]
getPlaceholderTypes ex = map (infType . getAnnotation) $ getPlaceholders ex


setInferredTypes :: Data a => a -> a
setInferredTypes =
  transformBi $ \x ->
    case x of
      FunCall an op exprs -> FunCall an op (addInferredTypes an exprs)
      x1 -> x1
  where
    addInferredTypes :: Annotation -> [Expression] -> [Expression]
    addInferredTypes an exprs =
           let args :: [Maybe Type]
               args = map Just $ maybe [] (\(_,a,_,_) -> a) $ fnProt an
           in map setInfType $ zip (args ++ repeat Nothing) exprs
           where
             setInfType :: (Maybe Type,Expression) -> Expression
             setInfType (t,a) = updateAnnotation (\i -> i {infType = t}) a

}
