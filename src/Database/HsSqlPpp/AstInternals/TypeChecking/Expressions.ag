{-
Copyright 2009 Jake Wheat

This file contains the type checking code for the expression ast data
type.

-}

--gather the backtree, type errors and types together and add annotations
SEM Expression
    | IntegerLit StringLit FloatLit BooleanLit NullLit FunCall Identifier
      Exists Case CaseSimple Cast InPredicate ScalarSubQuery LiftOperator
      PositionalArg Placeholder WindowFn
        lhs.annotatedTree = updateAnnotation
                              (setTypeAddErrorsA @loc.tpe
                               . \a -> a {fnProt = @loc.prototype
                                         ,infType = msum [@lhs.expectedType
                                                         ,etmt @loc.tpe
                                                         ,Nothing]}) @loc.backTree
        loc.tpe : Et

SEM Expression
    | IntegerLit StringLit FloatLit BooleanLit NullLit Identifier
      Exists Case CaseSimple Cast InPredicate ScalarSubQuery LiftOperator
      PositionalArg Placeholder WindowFn
        loc.prototype : {Maybe FunctionPrototype}
        loc.prototype = Nothing

SEM Expression
    | IntegerLit StringLit FloatLit BooleanLit NullLit
      Exists Case CaseSimple Cast InPredicate ScalarSubQuery LiftOperator
      PositionalArg Placeholder WindowFn FunCall
      Identifier FunCall
        lhs.ntAnnotatedTree = updateAnnotation
                                 (setTypeAddErrorsA (either Left (Right . CompositeType) @loc.ntType)
                                 . \a -> a {fnProt = @loc.prototype}) @loc.backTree
        lhs.ntType = either (const []) id @loc.ntType

ATTR Expression [||ntAnnotatedTree : Expression
                   ntType : {[(String,Type)]}]

ATTR Expression [expectedType : {Maybe Type}||]

ATTR ExpressionList [expectedTypes : {[Maybe Type]}||]

{-
== literals

pretty straightforward
-}

SEM Expression
     | IntegerLit loc.tpe = Right typeInt
     | StringLit loc.tpe = Right UnknownType
     | FloatLit loc.tpe = Right typeNumeric
     | BooleanLit loc.tpe = Right typeBool
     -- I think a null has the same type resolution as an unknown string lit
     | NullLit loc.tpe = Right UnknownType

SEM Expression
    | IntegerLit
        loc.backTree = IntegerLit @ann @i
    | StringLit
        loc.backTree = StringLit @ann @value
    | FloatLit
        loc.backTree = FloatLit @ann @d
    | BooleanLit
        loc.backTree = BooleanLit @ann @b
    | NullLit
        loc.backTree = NullLit @ann


{-

== cast expression

all the work is done in the typename node
-}

SEM Expression
    | Cast loc.tpe = lmt @tn.namedType
           loc.backTree = Cast @ann @expr.annotatedTree @tn.annotatedTree

{-
== operators and functions
-}
SEM Expression
    | FunCall
        (loc.tpe
        ,loc.prototype) = either (\e -> (Left e, Nothing)) id $ do
                          args <- mapM lmt @args.typeList
                          efp <- findCallMatch @lhs.cat
                                               @funName
                                               args
                          let (_,_,r,_) = efp
                          return (Right r, Just efp)


        loc.backTree = FunCall @ann @funName @args.annotatedTree


   | WindowFn
        loc.tpe = lmt $ getTypeAnnotation @fn.annotatedTree
        loc.backTree = WindowFn @ann
                                @fn.annotatedTree
                                @partitionBy.annotatedTree
                                @orderBy.annotatedTree
                                @dir
                                @frm
{-
lifted operator:
pretty much the same as haskell 'any (lhs [op]) rhss' (or all instead of any)
where lhs is the first argument and rhss is the second argument
which must be an array

pg allows the rhss to also be a subselect, this is a todo

-}

SEM Expression
    | LiftOperator
        loc.tpe = do
                  args <- mapM lmt @args.typeList
                  let args = @args.annotatedTree
                  errorWhen (length args /= 2)
                            [AnyAllError $ "must have two args, got " ++ show args]
                  let [a,b] = args
                  aType <- lmt $ getTypeAnnotation a
                  bType <- lmt $ getTypeAnnotation b
                  errorWhen (not $ isArrayType bType)
                            [AnyAllError $ "second arg must be array, got " ++ show args]
                  elemType <- unwrapArray $ bType
                  resType <- fmap (\(_,_,r,_) -> r) $ findCallMatch @lhs.cat
                                                                    @oper
                                                                    [aType,elemType]
                  errorWhen (resType /= typeBool)
                            [AnyAllError $ "operator must have bool return, got " ++ show resType]
                  return resType
        loc.backTree = LiftOperator @ann @oper @flav @args.annotatedTree


{-
== case expression

for non simple cases, we need all the when expressions to be bool, and
then to collect the types of the then parts to see if we can resolve a
common type

for simple cases, we need to check all the when parts have the same type
as the value to check against, then we collect the then parts as above.

-}

SEM Expression
    | Case CaseSimple
        loc.whenTypes = map getTypeAnnotation $ concatMap fst $
                        @cases.annotatedTree
        loc.thenTypes = map getTypeAnnotation $
                            (map snd $ @cases.annotatedTree) ++
                              maybeToList @els.annotatedTree

SEM Expression
    | Case
        loc.tpe = do
                  wt <- mapM lmt @loc.whenTypes
                  -- probably the when types shoule be checked inside each when node
                  -- and type errors attach there, and ignored here
                  errorWhen (any (/= typeBool) wt)
                      [WrongTypes typeBool wt]
                  tt <- mapM lmt @loc.thenTypes
                  resolveResultSetType @lhs.cat tt
        loc.backTree = Case @ann @cases.annotatedTree @els.annotatedTree


SEM Expression
    | CaseSimple
        loc.tpe =
          do
          wt <- mapM lmt @loc.whenTypes
          vt <- lmt $ getTypeAnnotation @value.annotatedTree
          _ <- resolveResultSetType @lhs.cat (vt : wt)
          tt <- mapM lmt @loc.thenTypes
          resolveResultSetType @lhs.cat tt
        loc.backTree = CaseSimple @ann
                                  @value.annotatedTree
                                  @cases.annotatedTree
                                  @els.annotatedTree

{-
== identifiers
pull id types out of cat for identifiers

-}


{-

Star expansion handling.

In a few places - mainly the top level of a select list - if the
identifier is a star or qualified star we want to expand the star. The
cleanest way of doing this is to expand the stars in the ast to the
expansions, but we need to do this at the last minute during the ag
process since e.g. we might need the view information from the
immediately previous statement. I don't know how to alter the ag
process so that we can update a subtree and collect attributes from
that which would be a clean way of doing it.

So - use a bodge. When we want to get the identifier type, and star
expansion is possible, use a different pair of tpe and backtree
attributes to get the node information to the regular ones.

-}

SEM Expression
    | Identifier
        loc.tpe = unwrapLookup <$> lbLookupID @lhs.lib @i
        loc.backTree = Identifier @ann @i

        loc.ntType : {E [(String,Type)]}
        loc.ntType =
            if @i == "*"
            then unwrapStar <$> lbExpandStar @lhs.lib
            else (\t -> [(@i, t)]) <$> unwrapLookup <$> lbLookupID @lhs.lib @i


SEM Expression
  | FunCall
      loc.liftedColumnName = if isOperatorName @funName
                             then ""
                             else @funName
  | Cast
      loc.liftedColumnName = case @tn.annotatedTree of
                               SimpleTypeName _ tn -> tn
                               _ -> ""
  | WindowFn
      loc.liftedColumnName = let (FunCall _ fn _) = @fn.annotatedTree
                             in fn

SEM Expression
  | BooleanLit Case Exists FloatLit IntegerLit LiftOperator
    NullLit PositionalArg Placeholder ScalarSubQuery StringLit
    CaseSimple InPredicate
      loc.liftedColumnName = ""

SEM Expression
  | FunCall Cast CaseSimple InPredicate WindowFn
    BooleanLit Case Exists FloatLit IntegerLit LiftOperator
    NullLit PositionalArg Placeholder ScalarSubQuery StringLit
      loc.ntType = do
                   t <- @loc.tpe
                   return [(case @loc.liftedColumnName of
                             "" -> "?column?"
                             n -> n
                          ,t)]


SEM Expression
  | FunCall
      args.lib =
          case @funName of
            "." | Just t <- getTypeAnnotation $ head @args.annotatedTree
                  -> maybe emptyBindings id $ do
                          is <- expandComposite @lhs.cat t
                          etmt $ lbUpdate @lhs.cat (LBIds "dot" Nothing is) @lhs.lib
            _ -> @lhs.lib


SEM Expression
    | PositionalArg
        loc.tpe = unwrapLookup <$> lbLookupID @lhs.lib ('$':show @p)
        loc.backTree = PositionalArg @ann @p


SEM Expression
    | Placeholder
        loc.tpe = Right UnknownType
        loc.backTree = Placeholder @ann

-- exists: will work on any subselect so we don't need to do any checking
SEM Expression
    | Exists
        loc.tpe = Right typeBool
        loc.backTree = Exists @ann @sel.annotatedTree


{-
== scalar subquery
1 col -> type of that col
2 + cols -> row type
-}

SEM Expression
    | ScalarSubQuery
        loc.tpe =
            do
            selType <- lmt $ getTypeAnnotation @sel.annotatedTree
            f <- map snd <$> unwrapSetOfComposite selType
            case length f of
              0 -> Left [InternalError "no columns in scalar subquery?"]
              1 -> Right $ head f
              _ -> Right $ AnonymousRecordType f

        loc.backTree = ScalarSubQuery @ann @sel.annotatedTree
{-
== inlist
todo: make the ast and typechecking a special case of lifted operator
-}

SEM Expression
    | InPredicate
        loc.tpe = do
                  lt <- @list.listType
                  expt <- lmt $ getTypeAnnotation @expr.annotatedTree
                  _ <- resolveResultSetType @lhs.cat [expt, lt]
                  return typeBool
        loc.backTree = InPredicate @ann
                                   @expr.annotatedTree
                                   @i
                                   @list.annotatedTree


ATTR InList [||listType : {Either [TypeError] Type}]

SEM InList
    | InList
        lhs.listType = mapM lmt @exprs.typeList >>= resolveResultSetType @lhs.cat
    | InSelect
        lhs.listType =
            do
            st <- lmt $ getTypeAnnotation @sel.annotatedTree
            attrs <- map snd <$> unwrapSetOfComposite st
            case length attrs of
                      0 -> Left [InternalError
                                 "got subquery with no columns? in inselect"]
                      1 -> Right $ head attrs
                      _ -> Right $ AnonymousRecordType attrs
{-
================================================================================

slightly dodgy type inference

target is just to support parameterized statements at the moment, so
lots missing and no unification or anything like that, although this
wouldn't be too hard to add

some more of the code is in insert.ag

basically we just pass inferred types from function calls to the
individual arguments using the matched function prototype, and we pass
inferred types from the table's attribute types in an insert
statement. No other inferrence is done, and the inferred types aren't
checked for consistency with any type already in a node.

Then we use this info only to get the types of any placeholders in a
parameterized statement.

-}


-- some of this could be filled in quite easily

SEM AlterTableAction
    | AlterColumnDefault def.expectedType = Nothing


SEM CaseExpressionList
    | Cons hd.expectedType = Nothing

SEM CaseExpressionListExpressionPair
    | Tuple x2.expectedType = Nothing

SEM Constraint
    | CheckConstraint expr.expectedType = Nothing

SEM ExpressionDirectionPair
    | Tuple x1.expectedType = Nothing

SEM ExpressionList
    | Cons hd.expectedType = case @lhs.expectedTypes of
                               (t:_) -> t
                               _ -> Nothing
           tl.expectedTypes  = case @lhs.expectedTypes of
                               (_:ts) -> ts
                               _ -> []

SEM JoinExpression
    | JoinOn expr.expectedType = Just typeBool

SEM MaybeBoolExpression
    | Just just.expectedType = Just typeBool

SEM MaybeExpression
    | Just just.expectedType = Nothing

SEM RowConstraint
    | RowCheckConstraint expr.expectedType = Nothing

SEM SelectItem
    | SelExp SelectItem ex.expectedType = Nothing

SEM Statement
    | Assignment value.expectedType = Nothing
    | CaseStatementSimple val.expectedType = Nothing
    | Execute ExecuteInto Perform ReturnNext WhileStatement
        expr.expectedType = Nothing
    | ForIntegerStatement from.expectedType = Nothing
                          to.expectedType = Nothing
    | AlterSequence ownedBy.expectedType = Nothing
    | Assignment target.expectedType = Nothing
    | ForIntegerStatement ForSelectStatement var.expectedType = Nothing
SEM TableRef
    | TrefFun fn.expectedType = Nothing
    | Tref tbl.expectedType = Nothing

SEM ExpressionRoot
    | ExpressionRoot expr.expectedType = Nothing

SEM ExpressionStatementListPair
    | Tuple x1.expectedType = Nothing

SEM Expression
    | FunCall
        args.expectedTypes = maybe [] id $
                             -- hack for anonymousrecordtypes
                             case (@funName,@lhs.expectedType) of
                               ("!rowctor", Just (AnonymousRecordType ts)) -> return $ map Just ts
                               _ -> do
                                    (_,t,_,_) <- @loc.prototype
                                    return $ map Just t
    | LiftOperator
        args.expectedTypes = []
    | WindowFn
        partitionBy.expectedTypes = []
        orderBy.expectedTypes = []

SEM ExpressionListStatementListPair
    | Tuple x1.expectedTypes = []

SEM InList
    | InList exprs.expectedTypes = []

SEM SelectExpression
    | Select selGroupBy.expectedTypes = []

SEM Statement
    | CreateTrigger fnArgs.expectedTypes = []
    | Raise args.expectedTypes = []
    | Update assigns.expectedTypes = []

-- inferred types in the select expresssion

ATTR SelectExpression [expectedTypes: {[Maybe Type]}||]

ATTR ExpressionListList [expectedTypes: {[Maybe Type]}||]

SEM SelectExpression
    | Values vll.expectedTypes = @lhs.expectedTypes

SEM ExpressionListList
    | Cons hd.expectedTypes = @lhs.expectedTypes
           tl.expectedTypes = @lhs.expectedTypes

SEM Expression
    | Exists ScalarSubQuery sel.expectedTypes = []
SEM InList
    | InSelect sel.expectedTypes = []
SEM Statement
    | CreateTableAs CreateView expr.expectedTypes = []
    | ForSelectStatement ReturnQuery
        sel.expectedTypes = []
    | SelectStatement ex.expectedTypes = []
SEM TableRef
    | SubTref sel.expectedTypes = []
SEM WithQuery
    | WithQuery ex.expectedTypes = []
