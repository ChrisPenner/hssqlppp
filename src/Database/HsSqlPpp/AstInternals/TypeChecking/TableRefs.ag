{-
Copyright 2010 Jake Wheat

This file contains the checking for tablerefs (the from part of a
select expression).

Type checking joins is a real brain twister.

-----------
notes on how to write this file:

want to have inline diagrams - how to do this? - can't have inline in
ides usually, but can have inline when rendering source to html with
e.g. pandoc, but still want to be able to view the diagrams when
reading/editing the source code

do in literate style

want to add transcripts of sessions with psql
want to add output along the lines of 'load this sql, then pg_dump it,
this is what you get'
- stuff like this can be done usin a script which processes the source code and
  replaces the output, but need to know when it breaks, so the output
  also should be matched to check it's still working right, want an
  automated way of doing this rather than eyeballing diffs before
  commiting to source control

also, along these lines, want the automated tests to live here next to
the code they exercise. Would be extra nice if could use code coverage
to check that when the test is run, the code it's supposed to be
testing is used.
-------

Apart from the usual new annotated tree, tablerefs need to produce new
local bindings information to feed to the other parts of a select
expression, e.g. the field names and types than can be referenced in
the select list.

The different types of tablerefs are:
table name
sub select
function (I think pg will promotes non set returning functions and non
  composite returning functions implicitly so they all work, the name
  of the function is used to supply the correlation name and field
  name if there is none)
join

Join is the tricky one, partly because it is recursive.

The other complication is passing new local bindings into the sub
nodes. So far, this is done only of the onexpr part of a join

notes to add:
mainly a list of sql statements and the /d+ from psql to show how the
correlation names work with joins
1) natural/using joins when selected unqualified have the correlation
name from the first table
2) you can get these fields with the other table's correlation name by using that table name.* or .field_name
3) can create a view with two fields with the same name from different tables.
but if you add an alias to the join tref then they both attempt to have the same correlation name - error

maybe put the localbindings tests in here as well, so each chunk is a
bit of blather, some example sql/ possibly with /d+ or pg_dump output
from pg with notes, then some test cases, then the code that makes it
happen


-}

-- lib update contains the updated id and star expansions coming out
-- of the tableref part of a select expression. These updates aren't
-- used for chaining these things for nested table refs (in join
-- statements) - use attributes for them

ATTR TableRef TableRefList [|| libUpdates: {[LocalBindingsUpdate]}]

-- use these attributes which contain a copy of the info in lib
-- updates in a form more digestible to the join attributes resolution
-- the main advantages is we don't have to pull the ids out of a list
-- of update wrappers, and we don't have to split the id bindings into
-- qualified and unqualified parts. We could do it just using the
-- libupdates in principle, but this way seems to be a bit more direct
-- and clear to write and read (i.e. when I tried to to it using
-- libupdates I failed and gave up several times).
--ATTR TableRef [|| libUpdatesidLookups: {[LocalBindingsUpdate]}]

-- set the annotations, just need to pick up any type errors whilst
-- calculating the new bindings
SEM TableRef
    | SubTref Tref TrefFun JoinedTref
        lhs.annotatedTree = addTypeErrors @loc.errs @loc.backTree

SEM TableRefList
    | Nil
        lhs.libUpdates = []
    | Cons
        lhs.libUpdates = @hd.libUpdates -- todo, combine properly

{-

in the individual sem parts, we set four values:
idlookups : [(string,type)] pairs for all the unqualified ids which will be in scope coming out of the tref
qidlookups: [(string, [(string,type)])] for all the qualified ids
starexpansion: to expand unqualified *
qstarexpansion: to expand qualified *
(we need idlookups and starexpansion because of pg system columns,
which are a serious pain to deal with).

These are set as local vars, because we need to feed the resultant lib
update into the on expressions in joins lower down, which we can't do
directly with a syn attribute, so we collect them in locals, the
combined the in a local for libupdates. We copy all the parts and the
lib updates to regular attributes so we can access them from other
sems (the components (idlookups, etc.) are needed in working out joins
attributes, and the libupdate is used in the join expression, so all
this extra copying is only needed to support joins).

in each part, we collect errors in the errs local which we can then
add to the annotation for the node. when this happens, further type
checking in the select statement should stop but this isn't properly
implemented yet (this is to avoid too many type errors all over the
tree resulting from one mistake - a user friendliness consideration)

-}

SEM TableRef
    | SubTref
{-
subtref - pull the type of the select expression out (which will be a
          setof composite then the lbupdate is these fields qualified
          with the tref's alias
-}

        loc.errs = case @loc.selectAttrs of
                           Left e -> e
                           Right _ -> []
        loc.selectAttrs : {Either [TypeError] [(String,Type)]}
        loc.selectAttrs = lmt @sel.uType
        lhs.libUpdates = [LBTref "sub query" (getAlias "" @alias) --"" should be error
                                         (fromRight [] @loc.selectAttrs) []]

    | Tref
{-
tref - just a name of a table or view, just need to retrieve the fields from the catalog

-}
        loc.errs = []
        lhs.libUpdates = maybe [] id $ do
                         let n = getName @tbl.annotatedTree
                         (pu,pr) <- @tbl.tbUType
                         return [LBTref ("tref: " ++ n)
                                   (getAlias n @alias)
                                   pu
                                   pr]


    | TrefFun
{-

we rely on the funIdens function below to get the correlation name an
column names and types - see that function for how this works

-}
        loc.errs = case @eqfunIdens of
                     Left e -> e
                     Right _ -> []


        loc.eqfunIdens : {Either [TypeError] (String,[(String,Type)])}
        loc.eqfunIdens = funIdens @lhs.cat (getAlias "" @alias) @fn.annotatedTree @fn.uType
        lhs.libUpdates = [LBTref "fn"
                                         (fst @loc.qfunIdens)
                                         (snd @loc.qfunIdens)
                                         []]
        loc.qfunIdens = fromRight ("",[]) @loc.eqfunIdens
    | JoinedTref
{-
join - most of the hard work is done in local bindings
-}
        loc.errs = fromLeft [] @loc.newLib
                   ++ @loc.joinErrors
        lhs.libUpdates = if @loc.joinErrors == []
                         then @loc.libUpdates
                         else []
                   --bit hacky, we want any errors from the join
                   -- to be added here, instead of upstream
        loc.joinErrors = fromLeft [] (foldM (flip $ lbUpdate @lhs.cat) @lhs.lib @loc.libUpdates)
        loc.libUpdates =
            case (@tbl.libUpdates, @tbl1.libUpdates) of
              ([u1], [u2]) -> [LBJoinTref "join" u1 u2 jids
                                              (case @alias of
                                                       NoAlias -> Nothing
                                                       TableAlias t -> Just t
                                                       FullAlias t _ -> Just t)]
              _ -> []
            where
              jids = case (@nat, @onExpr.originalTree) of
                          (Natural, _) -> Left ()
                          (_,Just (JoinUsing _ s)) -> Right s
                          _ -> Right []
        loc.newLib : {Either [TypeError] LocalBindings}
        loc.newLib = case (@tbl.libUpdates, @tbl1.libUpdates) of
                       ([u1],[u2]) -> lbUpdate @lhs.cat
                                        (LBJoinTref "join" u1 u2 (Right []) Nothing) @lhs.lib
                       _ -> Right @lhs.lib
        onExpr.lib = fromRight @lhs.lib @loc.newLib

{



{-
convert a function call into a [String,[(string,type)]] list for use
in a tableref context
first consideration is the alias: if there is an alias in the select,
e.g. select * from generate_series(1,2) x;  (alias is x)
we use that, otherwise we use the name of the function
second consideration is the attributes coming out, roughly speaking
we have to convert an arbitrary type to a relation type
if we have a relation valued function, we don't need to do anything
if we have a setof non composite, we lift the single type to an
attribute, using the function name for the attribute name
if we have a non setof, we lift the single type to an attribute and
then relation, using the function name for the attribute name
need to check to see what should happen with arrayof

-}
funIdens :: Catalog -> String -> Expression -> Maybe Type -> Either [TypeError] (String,[(String,Type)])
funIdens cat alias fnVal ft = do
   errorWhen (case fnVal of
                FunCall _ _ _ -> False
                _ -> True)
             [ContextError "FunCall"]
   let (FunCall _ fnName _) = fnVal
       cn = if alias /= ""
                           then alias
                           else fnName
   attrs <- do
     fnt <- lmt ft
     case fnt of
       SetOfType (NamedCompositeType t) -> catCompositePublicAttrs cat [] t
       SetOfType x -> return [(cn,x)]
       y -> return [(cn,y)]
   return (cn, attrs)

getAlias :: String -> TableAlias -> String
getAlias def alias =
  case alias of
    NoAlias -> def
    TableAlias t -> t
    FullAlias t _ -> t

}

-- backtrees

SEM TableRef
    | SubTref
        loc.backTree = SubTref @ann @sel.annotatedTree @alias
    | Tref
        loc.backTree = Tref @ann t1 @alias
                       where
                         -- hack to hide the identifier not found error
                         -- todo: convert to do something similar to ntAnnotatedTree
                         t1 = case @tbl.annotatedTree of
                                Identifier a i -> Identifier (a {errs = ste i $ errs a}) i
                                x -> x
                         ste i (UnrecognisedIdentifier j : es) | i == j = es
                         ste i (e:es) = e : ste i es
                         ste _ [] = []
    | TrefFun
        loc.backTree = TrefFun @ann @fn.annotatedTree @alias
    | JoinedTref
        loc.backTree = JoinedTref @ann
                                  @tbl.annotatedTree
                                  @nat
                                  @joinType
                                  @tbl1.annotatedTree
                                  @onExpr.annotatedTree
                                  @alias
