{-
================================================================================

= insert

check the insert data is the correct type. Doesn't cope with columns
with default values at the moment.

-}

SEM Statement
    | Insert
        loc.tpe = either Left (const $ Right $ Pseudo Void) @loc.columnTypes
        loc.statementType = Just (catMaybes $ getPlaceholderTypes @insData.annotatedTree
                                 ,@returning.listType)
        -- column types is the name,type list for the columns
        -- mentioned in the select expression being inserted
        loc.columnTypes : {Either [TypeError] [(String,Type)]}
        loc.columnTypes =
          do
          atts <- catCompositePublicAttrs @lhs.cat relationComposites @table
          expAtts <- lmt (getTypeAnnotation @insData.annotatedTree)
                     >>= unwrapSetOfComposite
          let eNames = map fst expAtts
          tAtts <- case @targetCols of
                        [] -> return atts
                        _ -> mapM (lkpA atts) @targetCols
          checkAssignmentsValid @lhs.cat (map snd expAtts) (map snd tAtts)
          return tAtts
          where
            lkpA :: [(String,Type)] -> String -> E (String,Type)
            lkpA m n = maybe (Left [UnrecognisedIdentifier n])
                             (\t -> Right (n,t))
                             $ lookup n m

        loc.backTree = Insert @ann @table @targetCols
                              @insData.annotatedTree
                              @returning.annotatedTree
        loc.catUpdates = []
        insData.inferredTypes = maybe [] id $ do
                                ts <- etmt $ @loc.columnTypes
                                return $ map (Just . snd) ts

        returning.lib =
            either (const @lhs.lib) id $ do
              atts <- catCompositeAttrs @lhs.cat relationComposites @table
              lbUpdate @lhs.cat (LBIds "insert target table" (Just @table) atts) @lhs.lib
