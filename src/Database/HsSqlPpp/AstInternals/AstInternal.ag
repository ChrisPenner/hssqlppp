{-


This file contains the ast nodes, and the api functions to pass an ast
and get back type information.

It uses the Utrecht University Attribute Grammar system:

* http://www.cs.uu.nl/wiki/bin/view/HUT/AttributeGrammarSystem
* http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter

The attr and sem definitions are in TypeChecking.ag, which is included
into this file.

These ast nodes are both used as the result of successful parsing, and
as the input to the type checker (and the output from the type
checker), and the pretty printer.

= compiling

use

uuagc  -dcfwsp --cycle --genlinepragmas AstInternal.ag

to generate a new AstInternal.hs from this file (cycle will check for
cycles - it's bad if you get any of these, and genlinepragmas mean
that you'll be able to view the original source ag positions when
there are errors or warnings compiling the generated hs file, which
you want much more often than not).

Depending on the alignment of the planets, you might need to use

uuagc  -dcfwsp AstInternal.ag

At the moment, genlinepragmas seems to break when you use where with
uuagc > 0.9.19.

(install uuagc with
cabal install uuagc
)

-}

{- | test
-}
MODULE {Database.HsSqlPpp.AstInternals.AstInternal}
{
    -- {-# LANGUAGE DeriveDataTypeable,RankNTypes,ScopedTypeVariables #-}
    --from the ag files:
    --ast nodes
    Statement (..)
   ,SelectExpression (..)
   ,WithQueryList
   ,WithQuery(..)
   ,FnBody (..)
   --,SetClause (..)
   ,TableRef (..)
   ,TableAlias(..)
   ,JoinExpression (..)
   ,JoinType (..)
   ,SelectList (..)
   ,SelectItem (..)
   ,CopySource (..)
   ,AttributeDef (..)
   ,RowConstraint (..)
   ,AlterTableAction(..)
   ,Constraint (..)
   ,TypeAttributeDef (..)
   ,ParamDef (..)
   ,VarDef (..)
   ,RaiseType (..)
   ,CombineType (..)
   ,Volatility (..)
   ,Language (..)
   ,TypeName (..)
   ,DropType (..)
   ,Cascade (..)
   ,Direction (..)
   ,Distinct (..)
   ,Natural (..)
   ,IfExists (..)
   ,Replace(..)
   ,RestartIdentity (..)
   ,Expression (..)
   ,FrameClause(..)
   ,InList (..)
   ,LiftFlavour(..)
   ,TriggerWhen(..)
   ,TriggerEvent(..)
   ,TriggerFire(..)
   ,StatementList
   ,ExpressionListStatementListPairList
   ,ExpressionListStatementListPair
   ,ExpressionList
   ,ParamDefList
   ,AttributeDefList
   ,ConstraintList
   ,TypeAttributeDefList
   ,TypeNameList
   ,StringTypeNameListPair
   ,StringTypeNameListPairList
   ,ExpressionStatementListPairList
   --,SetClauseList
   ,CaseExpressionListExpressionPairList
   ,MaybeExpression
   ,TableRefList
   ,ExpressionListList
   ,SelectItemList
   ,OnExpr
   ,RowConstraintList
   ,VarDefList
   ,ExpressionStatementListPair
   ,CaseExpressionListExpressionPair
   ,ExpressionDirectionPair
   ,ExpressionDirectionPairList
   ,MaybeBoolExpression
   ,MaybeSelectList
   ,SetValue(..)
   ,AlterTableActionList
   -- typechecking
   ,typeCheck
   ,typeCheckPS
   ,typeCheckExpression
}

{
import Data.Maybe
import Data.List
import Control.Applicative
import Data.Generics
import Data.Char
import Control.Monad.State

import Data.Generics.PlateData
import Debug.Trace

import Database.HsSqlPpp.AstInternals.TypeType
import Database.HsSqlPpp.AstInternals.TypeChecking.TypeConversion
import Database.HsSqlPpp.AstInternals.AstAnnotation
import Database.HsSqlPpp.AstInternals.Catalog.CatalogInternal
import Database.HsSqlPpp.AstInternals.TypeChecking.LocalBindings
import Database.HsSqlPpp.Utils.Utils
import Database.HsSqlPpp.AstInternals.TypeChecking.ErrorUtils

}

{-
================================================================================

SQL top level statements

everything is chucked in here: dml, ddl, plpgsql statements

-}

DATA Statement

--queries

    | SelectStatement ann:Annotation ex:SelectExpression

-- dml

    --table targetcolumns insertdata(values or select statement) returning
    | Insert ann:Annotation
             table : Expression
             targetCols : {[String]}
             insData : SelectExpression
             returning : MaybeSelectList
    --tablename setitems where returning
    | Update ann:Annotation
             table : Expression
             assigns : ExpressionList --SetClauseList
             fromList : TableRefList
             whr : MaybeBoolExpression
             returning : MaybeSelectList
    --tablename, where, returning
    | Delete ann:Annotation
             table : Expression
             using : TableRefList
             whr : MaybeBoolExpression
             returning : MaybeSelectList
    --tablename column names, from
    | Copy ann:Annotation
           table : String
           targetCols : {[String]}
           source : CopySource
    --represents inline data for copy statement
    | CopyData ann:Annotation insData : String
    | Truncate ann:Annotation
               tables: {[String]}
               restartIdentity : RestartIdentity
               cascade : Cascade

-- ddl

    | CreateTable ann:Annotation
                  name : String
                  atts : AttributeDefList
                  cons : ConstraintList
    | AlterTable ann:Annotation
                 name : String
                 actions : AlterTableActionList
    | CreateSequence ann:Annotation
                     name:String
                     incr:Integer
                     min:Integer
                     max:Integer
                     start:Integer
                     cache:Integer
    | AlterSequence ann:Annotation
                    name:String
                    ownedBy: Expression
    | CreateTableAs ann:Annotation
                    name : String
                    expr : SelectExpression
    | CreateView ann:Annotation
                 name : String
                 expr : SelectExpression
    | CreateType ann:Annotation
                 name : String
                 atts : TypeAttributeDefList
    -- language name args rettype bodyquoteused body vol
    | CreateFunction ann:Annotation
                     name : String
                     params : ParamDefList
                     rettype : TypeName
                     rep : Replace
                     lang : Language
                     body : FnBody
                     vol : Volatility
    -- name type checkexpression
    | CreateDomain ann:Annotation
                   name : String
                   typ : TypeName
                   checkName: String
                   check : MaybeBoolExpression
    | CreateLanguage ann:Annotation
                     name:String
    | CreateTrigger ann:Annotation
                    name:String
                    wh : TriggerWhen
                    events: {[TriggerEvent]}
                    tbl : String
                    firing : TriggerFire
                    fnName : String
                    fnArgs : ExpressionList
    -- ifexists (name,argtypes)* cascadeorrestrict
    | DropFunction ann:Annotation
                   ifE : IfExists
                   sigs : StringTypeNameListPairList
                   cascade : Cascade
    -- ifexists names cascadeorrestrict
    | DropSomething ann:Annotation
                    dropType : DropType
                    ifE : IfExists
                    names : {[String]}
                    cascade : Cascade
    | Assignment ann:Annotation
                 target : Expression
                 value : Expression
    | Return ann:Annotation
             value : MaybeExpression
    | ReturnNext ann:Annotation
                 expr : Expression
    | ReturnQuery ann:Annotation
                  sel : SelectExpression
    | Raise ann:Annotation
            level : RaiseType
            message : String
            args : ExpressionList
    | NullStatement ann:Annotation
    | Perform ann:Annotation
              expr : Expression
    | Execute ann:Annotation
              expr : Expression
    | ExecuteInto ann:Annotation
                  expr : Expression
                  targets : {[String]}
    | ForSelectStatement ann:Annotation
                         lb : {Maybe String}
                         var : Expression
                         sel : SelectExpression
                         sts : StatementList
    | ForIntegerStatement ann:Annotation
                          lb : {Maybe String}
                          var : Expression
                          from : Expression
                          to : Expression
                          sts : StatementList
    | LoopStatement ann:Annotation
                    lb : {Maybe String}
                    sts : StatementList
    | WhileStatement ann:Annotation
                     lb : {Maybe String}
                     expr : Expression
                     sts : StatementList
    | ContinueStatement ann:Annotation lb:{Maybe String}
    | ExitStatement ann:Annotation lb:{Maybe String}
    --variable, list of when parts, else part
    | CaseStatementSimple ann:Annotation
                    val : Expression
                    cases : ExpressionListStatementListPairList
                    els : StatementList
    | CaseStatement ann:Annotation
                    cases : ExpressionListStatementListPairList
                    els : StatementList
    --list is
    --first if (condition, statements):elseifs(condition, statements)
    --last bit is else statements
    | If ann:Annotation
         cases : ExpressionStatementListPairList
         els : StatementList
    | Block ann:Annotation lb:{Maybe String} vars:VarDefList sts : StatementList

--misc

    | Set ann:Annotation name:String values:{[SetValue]}
    | Notify ann:Annotation name:String

-- =============================================================================

--Statement components

-- maybe this should be called relation valued expression?
DATA SelectExpression
    | Select ann:Annotation
             selDistinct : Distinct
             selSelectList : SelectList
             selTref : TableRefList
             selWhere : MaybeBoolExpression
             selGroupBy : ExpressionList
             selHaving : MaybeBoolExpression
             selOrderBy : ExpressionDirectionPairList
             selLimit : MaybeExpression
             selOffset : MaybeExpression
    | CombineSelect ann:Annotation
                    ctype : CombineType
                    sel1 : SelectExpression
                    sel2 : SelectExpression
    | Values ann:Annotation
             vll:ExpressionListList
    | WithSelect ann : Annotation
                 withs : WithQueryList
                 ex : SelectExpression

TYPE WithQueryList = [WithQuery]
DATA WithQuery | WithQuery ann : Annotation
                           name : String
                           ex : SelectExpression

DATA FnBody | SqlFnBody ann:Annotation sts : StatementList
            | PlpgsqlFnBody ann:Annotation blk : Statement

DATA TableRef | Tref ann:Annotation
                     tbl:Expression
                     alias : TableAlias
              | JoinedTref ann:Annotation
                           tbl : TableRef
                           nat : Natural
                           joinType : JoinType
                           tbl1 : TableRef
                           onExpr : OnExpr
                           alias : TableAlias
              | SubTref ann:Annotation
                        sel : SelectExpression
                        alias : TableAlias
              | TrefFun ann:Annotation
                        fn:Expression
                        alias : TableAlias
{
data TableAlias = NoAlias
                | TableAlias String --alias:String
                | FullAlias String [String] -- alias:String cols:{[String]}
                  deriving (Show,Eq,Typeable,Data)
}

DATA JoinExpression | JoinOn ann:Annotation expr:Expression
                    | JoinUsing ann:Annotation x:{[String]}

{
data JoinType = Inner | LeftOuter| RightOuter | FullOuter | Cross
                deriving (Show,Eq,Typeable,Data)
}

-- select columns, into columns

DATA SelectList | SelectList ann:Annotation items:SelectItemList into:ExpressionList

DATA SelectItem | SelExp ann:Annotation ex:Expression
                | SelectItem ann:Annotation ex:Expression name:String

{
data CopySource = CopyFilename String
                | Stdin
                  deriving (Show,Eq,Typeable,Data)
}
--name type default null constraint

DATA AttributeDef | AttributeDef ann:Annotation
                                 name : String
                                 typ : TypeName
                                 def: MaybeExpression
                                 cons : RowConstraintList

--Constraints which appear attached to an individual field

DATA RowConstraint | NullConstraint ann:Annotation name:String
                   | NotNullConstraint ann:Annotation name:String
                   | RowCheckConstraint ann:Annotation name:String expr:Expression
                   | RowUniqueConstraint ann:Annotation name:String
                   | RowPrimaryKeyConstraint ann:Annotation name:String
                   | RowReferenceConstraint ann:Annotation name:String
                                            table : String
                                            att : (Maybe String)
                                            onUpdate : Cascade
                                            onDelete : Cascade

--constraints which appear on a separate row in the create table

DATA Constraint | UniqueConstraint ann:Annotation name:String x:{[String]}
                | PrimaryKeyConstraint ann:Annotation name:String x:{[String]}
                | CheckConstraint ann:Annotation name:String expr:Expression
                  -- sourcecols targettable targetcols ondelete onupdate
                | ReferenceConstraint ann:Annotation
                                      name:String
                                      atts : {[String]}
                                      table : String
                                      tableAtts : {[String]}
                                      onUpdate : Cascade
                                      onDelete : Cascade

DATA TypeAttributeDef | TypeAttDef ann:Annotation
                                   name : String
                                   typ : TypeName

DATA AlterTableAction | AlterColumnDefault ann:Annotation
                                           nm : String
                                           def : Expression
                      | AddConstraint ann: Annotation
                                      con: Constraint
{
data SetValue
    = SetStr Annotation String
    | SetId Annotation String
    | SetNum Annotation Double
      deriving (Show,Eq,Typeable,Data)


data TriggerWhen = TriggerBefore | TriggerAfter
                   deriving (Show,Eq,Typeable,Data)
data TriggerEvent = TInsert| TUpdate | TDelete
                    deriving (Show,Eq,Typeable,Data)
data TriggerFire = EachRow | EachStatement
                   deriving (Show,Eq,Typeable,Data)
}

DATA ParamDef | ParamDef ann:Annotation name:String typ:TypeName
              | ParamDefTp ann:Annotation typ:TypeName

DATA VarDef | VarDef ann:Annotation
                     name : String
                     typ : TypeName
                     value : (Maybe Expression)
{
data RaiseType = RNotice | RException | RError
                 deriving (Show,Eq,Typeable,Data)

data CombineType = Except | Union | Intersect | UnionAll
                   deriving (Show,Eq,Typeable,Data)

data Volatility = Volatile | Stable | Immutable
                  deriving (Show,Eq,Typeable,Data)

data Language = Sql | Plpgsql
                deriving (Show,Eq,Typeable,Data)
}

DATA TypeName | SimpleTypeName ann:Annotation tn:String
              | PrecTypeName ann:Annotation tn:String prec:Integer
              | ArrayTypeName ann:Annotation typ:TypeName
              | SetOfTypeName ann:Annotation typ:TypeName
{
data DropType = Table
              | Domain
              | View
              | Type
                deriving (Show,Eq,Typeable,Data)

data Cascade = Cascade | Restrict
               deriving (Show,Eq,Typeable,Data)

data Direction = Asc | Desc
                 deriving (Show,Eq,Typeable,Data)

data Distinct = Distinct | Dupes
                deriving (Show,Eq,Typeable,Data)

data Natural = Natural | Unnatural
               deriving (Show,Eq,Typeable,Data)

data IfExists = Require | IfExists
                deriving (Show,Eq,Typeable,Data)

data Replace = Replace | NoReplace
               deriving (Show,Eq,Typeable,Data)

data RestartIdentity = RestartIdentity | ContinueIdentity
                       deriving (Show,Eq,Typeable,Data)
}
{-
================================================================================

Expressions

Similarly to the statement type, all expressions are chucked into one
even though there are many restrictions on which expressions can
appear in different places.  Maybe this should be called scalar
expression?

-}
DATA Expression | IntegerLit ann:Annotation i:Integer
                | FloatLit ann:Annotation d:Double
                | StringLit ann:Annotation
                            value : String
                | NullLit ann:Annotation
                | BooleanLit ann:Annotation b:Bool
                | PositionalArg ann:Annotation p:Integer
                | Placeholder ann:Annotation -- represents a '?'
                | Cast ann:Annotation
                       expr:Expression
                       tn:TypeName
                | Identifier ann:Annotation
                             i:String
                | QIdentifier ann:Annotation
                              qual:Expression
                              i:String
                -- bit hacky, preserve parens when they contain just an identifier
                -- or positional arg, so we can pretty print this since it is needed
                -- in some places for the pg parser
                {- | PIdentifier ann:Annotation
                              ex:Expression-}
                | Case ann:Annotation
                       cases : CaseExpressionListExpressionPairList
                       els : MaybeExpression
                | CaseSimple ann:Annotation
                             value : Expression
                             cases : CaseExpressionListExpressionPairList
                             els : MaybeExpression
                | Exists ann:Annotation
                         sel : SelectExpression
                | FunCall ann:Annotation
                          funName:String
                          args:ExpressionList
                | InPredicate ann:Annotation
                              expr:Expression
                              i:Bool
                              list:InList
                | WindowFn ann:Annotation
                           fn : Expression
                           partitionBy : ExpressionList
                           orderBy : ExpressionList
                           dir : Direction
                           frm : FrameClause
                | ScalarSubQuery ann:Annotation
                                 sel : SelectExpression
                | LiftOperator ann:Annotation
                               oper:String
                               flav:LiftFlavour
                               args:ExpressionList
{
data LiftFlavour = LiftAny | LiftAll
                   deriving (Show,Eq,Typeable,Data)
}

--todo: use liftoperator to implement inlist?
DATA InList | InList ann:Annotation exprs : ExpressionList
            | InSelect ann:Annotation sel : SelectExpression

{
data FrameClause = FrameUnboundedPreceding
                 | FrameUnboundedFull
                 | FrameRowsUnboundedPreceding
                   deriving (Show,Eq,Typeable,Data)
}
{-

list of expression flavours from postgresql with the equivalents in this ast
pg                                here
--                                ----
constant/literal                  integerlit, floatlit, unknownstringlit, nulllit, boollit
column reference                  identifier
positional parameter reference    positionalarg
subscripted expression            funcall
field selection expression        identifier
operator invocation               funcall
function call                     funcall
aggregate expression              funcall
window function call              windowfn
type cast                         cast
scalar subquery                   scalarsubquery
array constructor                 funcall
row constructor                   funall

Anything that is represented in the ast as some sort of name plus a
list of expressions as arguments is treated as the same type of node:
FunCall.

This includes
symbol operators
regular function calls
keyword operators e.g. and, like (ones which can be parsed as normal
  syntactic operators)
unusual syntax operators, e.g. between
unusual syntax function calls e.g. substring(x from 5 for 3)
arrayctors e.g. array[3,5,6]
rowctors e.g. ROW (2,4,6)
array subscripting

list of keyword operators (regular prefix, infix and postfix):
and, or, not
is null, is not null, isnull, notnull
is distinct from, is not distinct from
is true, is not true,is false, is not false, is unknown, is not unknown
like, not like, ilike, not ilike
similar to, not similar to
in, not in (don't include these here since the argument isn't always an expr)

unusual syntax operators and fn calls
between, not between, between symmetric
overlay, substring, trim
any, some, all

Most of unusual syntax forms and keywords operators are not yet
supported, so this is mainly a todo list.

Keyword operators are encoded with the function name as a ! followed
by a string
e.g.
operator 'and' -> FunCall "!and" ...
see keywordOperatorTypes value in AstUtils.lhs for the list of
currently supported keyword operators.

-}

-- some list nodes, not sure if all of these are needed as separately
-- named node types

TYPE OnExpr = MAYBE JoinExpression
TYPE MaybeSelectList = MAYBE SelectList

TYPE TableRefList = [TableRef]
TYPE MaybeExpression = MAYBE Expression
TYPE MaybeBoolExpression = MAYBE Expression

TYPE ExpressionList = [Expression]
TYPE ExpressionListList = [ExpressionList]

-- TYPE SetClauseList = [SetClause]
TYPE AttributeDefList = [AttributeDef]
TYPE ConstraintList = [Constraint]
TYPE TypeAttributeDefList = [TypeAttributeDef]
TYPE ParamDefList = [ParamDef]
TYPE TypeNameList = [TypeName]
TYPE StringTypeNameListPair = (String, TypeNameList)
TYPE StringTypeNameListPairList = [StringTypeNameListPair]
TYPE ExpressionListStatementListPair = (ExpressionList,StatementList)
TYPE ExpressionListStatementListPairList = [ExpressionListStatementListPair]
TYPE ExpressionStatementListPair = (Expression, StatementList)
TYPE ExpressionStatementListPairList = [ExpressionStatementListPair]
TYPE VarDefList = [VarDef]
TYPE SelectItemList = [SelectItem]
TYPE RowConstraintList = [RowConstraint]
TYPE CaseExpressionListExpressionPair = (ExpressionList,Expression)
TYPE CaseExpressionListExpressionPairList = [CaseExpressionListExpressionPair]
TYPE StatementList = [Statement]
TYPE ExpressionDirectionPair = (Expression,Direction)
TYPE ExpressionDirectionPairList = [ExpressionDirectionPair]
TYPE AlterTableActionList = [AlterTableAction]
-- Add a root data type so we can put initial values for inherited
-- attributes in the section which defines and uses those attributes
-- rather than in the sem_ calls

DATA Root | Root statements:StatementList
DERIVING Root: Show

-- use an expression root also to support type checking,
-- etc., individual expressions

DATA ExpressionRoot | ExpressionRoot expr:Expression
DERIVING ExpressionRoot: Show

{-
================================================================================

=some basic bookkeeping

attributes which every node has
-}

SET AllNodes = Statement SelectExpression FnBody TableRef
               JoinExpression
               SelectList SelectItem AttributeDef RowConstraint
               TypeAttributeDef ParamDef VarDef Constraint
               TypeName
               Expression InList MaybeExpression MaybeBoolExpression
               ExpressionList ExpressionListList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList TypeNameList StringTypeNameListPair
               StringTypeNameListPairList
               StatementList ExpressionListStatementListPair
               ExpressionListStatementListPairList ExpressionStatementListPair
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList CaseExpressionListExpressionPair
               CaseExpressionListExpressionPairList
               TableRefList TableRef OnExpr MaybeSelectList
               AlterTableAction
               ExpressionDirectionPair
               ExpressionDirectionPairList AlterTableActionList
               WithQueryList WithQuery


DERIVING AllNodes: Show,Eq,Typeable,Data


INCLUDE "TypeChecking/TypeChecking.ag"

{-

================================================================================

used to use record syntax to try to insulate code from field changes,
and not have to write out loads of nothings and [] for simple selects,
but don't know how to create haskell named records from uuagc DATA
things

makeSelect :: Statement
makeSelect = Select Dupes (SelectList [SelExp (Identifier "*")] [])
                   Nothing Nothing [] Nothing [] Asc Nothing Nothing


================================================================================

= annotation functions

-}
{
{-
-- | Type check multiple asts, allowing type checking references in
--   later files to definitions in earlier files. This is probably
--   more straightforward if you parse the files then concatenate the
--   statementlists together before type checking rather than using
--   this function
typeCheckMany :: Catalog -> [StatementList] -> [StatementList]
typeCheckMany cat sts =
    annInt cat sts []
    where
      annInt e (s:ss) ress =
          let (e1,res) = typeCheck e s
          in annInt e1 ss (res:ress)
      annInt _ [] ress = reverse ress
-}

-- | Takes an ast, checks against catalog passed, and adds
--   annotations, including types, type errors, and statement info.
--   Returns the updated catalog as well as the annotated ast.
typeCheck :: Catalog -> StatementList -> (Catalog,StatementList)
typeCheck cat sts =
    let t = sem_Root (Root (fixupImplicitJoins sts))
        ta = wrap_Root t Inh_Root {cat_Inh_Root = cat
                                  ,lib_Inh_Root = emptyBindings}
        tl = annotatedTree_Syn_Root ta
        cat1 = producedCat_Syn_Root ta
    in case tl of
         Root r -> (cat1,r)

-- | Unfinished version of type check which can type check an
-- individual statement with ? or positional arg placeholders in
-- it. Will error if the statement isn't select, update, insert or
-- delete. For use in type checking embedded parameterized
-- statements. Does all typechecking and annotation that the regular
-- typecheck does.
typeCheckPS :: Catalog -> Statement -> Either String Statement
typeCheckPS cat st =
    case st of
      SelectStatement _ _ -> tc
      Insert _ _ _ _ _ -> tc
      Update _ _ _ _ _ _ -> tc
      Delete _ _ _ _ _ -> tc
      _ -> Left "requires select, update, insert or delete statement"
    where
      tc = let t = sem_Root (Root (fixupImplicitJoins [st]))
               ta = wrap_Root t Inh_Root {cat_Inh_Root = cat
                                         ,lib_Inh_Root = emptyBindings}
               tl = annotatedTree_Syn_Root ta
               --cat1 = producedCat_Syn_Root ta
           in case tl of
                Root [st1] -> Right st1
                _ -> error "impossible happened in typeCheckPS!"


-- | Testing utility, mainly used to check an expression for type errors
-- or to get its type.
typeCheckExpression :: Catalog -> Expression -> Expression
typeCheckExpression cat ex =
    let t = sem_ExpressionRoot (ExpressionRoot (fixupImplicitJoins ex))
        rt = (annotatedTree_Syn_ExpressionRoot
              (wrap_ExpressionRoot t Inh_ExpressionRoot {cat_Inh_ExpressionRoot = cat
                                                        ,lib_Inh_ExpressionRoot = emptyBindings}))
    in case rt of
         ExpressionRoot e -> e

{-
bit of a hack, to avoid rewriting the tableref type checking to be
able to do implicit joins, we just convert them in to the equivalent
explicit join
-}

fixupImplicitJoins :: Data a => a -> a
fixupImplicitJoins =
    transformBi $ \x ->
            case x of
              -- alter asts to change implicit joins into explicit joins
              Select an dis sl trs@(_:_:_) whr grp hav od lim off
                  -> Select an dis sl [convTrefs trs] whr grp hav od lim off
              x1 -> x1
    where
      convTrefs (tr:tr1:trs) = JoinedTref emptyAnnotation tr Unnatural Cross (convTrefs (tr1:trs)) Nothing NoAlias
      convTrefs (tr:[]) = tr
      convTrefs _ = error "failed doing implicit join fixup hack"

}

{-

Future plans:

Investigate how much mileage can get out of making these nodes the
parse tree nodes, and using a separate ast. Hinges on how much extra
value can get from making the types more restrictive for the ast nodes
compared to the parse tree. Starting to think this won't be worth it.

Would like to turn this back into regular Haskell file, maybe could
use AspectAG instead of uuagc to make this happen?


-}
