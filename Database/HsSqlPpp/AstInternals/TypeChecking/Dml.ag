


{-
================================================================================

= insert

-}
{
getCAtts t =
    case t of
      SetOfType (UnnamedCompositeType t) -> t
      _ -> []
}

SEM Statement
    | Insert
        loc.columnStuff =
            checkColumnConsistency @lhs.env
                                   @table
                                   @targetCols.strings
                                   (getCAtts $ getTypeAnnotation @insData.annotatedTree)
        loc.tpe =
            chainTypeCheckFailed [getTypeAnnotation @insData.annotatedTree] $ do
              @loc.columnStuff
              Right $ Pseudo Void
        loc.statementInfo =
            [InsertInfo @table $ errorToTypeFailF UnnamedCompositeType @loc.columnStuff]
        loc.backTree = Insert @ann @table @targetCols.annotatedTree
                              @insData.annotatedTree @returning
        loc.envUpdates = []

ATTR StringList [||strings : {[String]}]

SEM StringList
  | Cons lhs.strings = @hd : @tl.strings
  | Nil lhs.strings = []

{-
================================================================================

= update

-}

SEM Statement
    | Update
        loc.tpe =
            do
            let re = checkRelationExists @lhs.env @table
            when (isJust re) $
                 Left [fromJust $ re]
            chainTypeCheckFailed (map snd @assigns.pairs) $ do
              @loc.columnsConsistent
              checkErrorList @assigns.rowSetErrors $ Pseudo Void
        loc.columnsConsistent =
            checkColumnConsistency @lhs.env @table (map fst @assigns.pairs) @assigns.pairs
        loc.statementInfo =
            [UpdateInfo @table $ errorToTypeFailF UnnamedCompositeType @loc.columnsConsistent]
        loc.backTree = Update @ann @table @assigns.annotatedTree @whr.annotatedTree @returning
        loc.envUpdates = []
        loc.columnTypes = case getCompositeColumns @lhs.env @table of
                            Left er -> []
                            Right c -> c
        whr.lib = case updateBindings @lhs.lib [LibStackIDs [("", @loc.columnTypes)]] of
                         Left x -> error $ show x
                         Right e -> e

ATTR SetClauseList [||pairs : {[(String,Type)]}
                      rowSetErrors : {[TypeError]}]

SEM SetClauseList
  | Cons lhs.pairs = @hd.pairs ++ @tl.pairs
         lhs.rowSetErrors = maybeToList @hd.rowSetError ++ @tl.rowSetErrors
  | Nil lhs.pairs = []
        lhs.rowSetErrors = []

ATTR SetClause [||pairs : {[(String,Type)]}
                  rowSetError : {Maybe TypeError}]

SEM SetClause
    | SetClause
        lhs.pairs = [(@att, getTypeAnnotation @val.annotatedTree)]
        lhs.rowSetError = Nothing
    | RowSetClause
        loc.rowSetError =
          let atts = @atts.strings
              types = getRowTypes @vals.typeList
          in if length atts /= length types
               then Just WrongNumberOfColumns
               else Nothing
        lhs.pairs = zip @atts.strings $ getRowTypes @vals.typeList

{
getRowTypes :: [Type] -> [Type]
getRowTypes [RowCtor ts] = ts
getRowTypes ts = ts
}

{-
================================================================================

= delete
-}

SEM Statement
    | Delete
        loc.tpe =
            case checkRelationExists @lhs.env @table of
              Just e -> Left [e]
              Nothing -> Right $ Pseudo Void
        loc.statementInfo = [DeleteInfo @table]
        loc.backTree = Delete @ann @table @whr.annotatedTree @returning
        loc.envUpdates = []
        loc.columnTypes = case getCompositeColumns @lhs.env @table of
                            Left er -> []
                            Right c -> c
        whr.lib = case updateBindings @lhs.lib [LibStackIDs [("", @loc.columnTypes)]] of
                         Left x -> error $ show x
                         Right e -> e


{
checkRelationExists :: Environment -> String -> Maybe TypeError
checkRelationExists env tbl =
          case getAttrs env [TableComposite, ViewComposite] tbl of
            Just _ -> Nothing
            _ -> Just $ UnrecognisedRelation tbl

checkColumnConsistency :: Environment ->  String -> [String] -> [(String,Type)]
                       -> Either [TypeError] [(String,Type)]
checkColumnConsistency env tbl cols' insNameTypePairs = do
  rt <- getRelationType env tbl
  ttcols <- unwrapComposite $ fst rt
  let cols :: [String]
      cols = if null cols'
               then map fst ttcols
               else cols'
  errorWhen (length insNameTypePairs /= length cols) [WrongNumberOfColumns]
  let nonMatchingColumns = cols \\ map fst ttcols
  errorWhen (not $ null nonMatchingColumns) $
       map UnrecognisedIdentifier nonMatchingColumns
  let targetNameTypePairs =
        map (\l -> (l,fromJust $ lookup l ttcols)) cols
        --check the types of the insdata match the column targets
        --name datatype columntype
      typeTriples = map (\((a,b),c) -> (a,b,c)) $ zip targetNameTypePairs $ map snd insNameTypePairs
      errs :: [TypeError]
      errs = concat $ lefts $ map (\(_,b,c) -> checkAssignmentValid env c b) typeTriples
  unless (null errs) $ Left errs
  return targetNameTypePairs

getCompositeColumns :: Environment -> String -> Either [TypeError] [(String,Type)]
getCompositeColumns env tbl = do
  rt <- getRelationType env tbl
  cols <- unwrapComposite $ fst rt
  cols1 <- unwrapComposite $ snd rt
  return $ cols ++ cols1


}