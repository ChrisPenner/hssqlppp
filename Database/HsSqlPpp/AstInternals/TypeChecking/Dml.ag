{-
Copyright 2009 Jake Wheat

This file contains the type checking code for dml, currently insert,
update and delete.

================================================================================

= insert

check the insert data is the correct type. Doesn't cope with columns
with default values at the moment.

-}

SEM Statement
    | Insert
        loc.tpe =
            ctcf [getTypeAnnotation @insData.annotatedTree] $ do
              @loc.columnTypes
              Right $ Pseudo Void
        loc.statementInfo =
            leftToEmpty (\ct -> [InsertInfo @table ct]) @loc.columnTypes

        loc.columnTypes =
            do
            tys <- unwrapSetOfComposite $
                   getTypeAnnotation @insData.annotatedTree
            checkColumnConsistency @lhs.env
                                   @table
                                   @targetCols.strings
                                   tys

        loc.backTree = Insert @ann @table @targetCols.annotatedTree
                              @insData.annotatedTree @returning
        loc.envUpdates = []

{-
================================================================================

= update

-}

SEM Statement
    | Update
        loc.tpe =
            do
            checkRelationExists @lhs.env @table
            ctcf (map snd @assigns.pairs) $ do
              @loc.columnsConsistent
              liftErrors @assigns.rowSetErrors
              return $ Pseudo Void
        loc.statementInfo =
            leftToEmpty (\ct -> [UpdateInfo @table ct]) @loc.columnsConsistent

        loc.columnsConsistent =
            checkColumnConsistency @lhs.env
                                   @table
                                   (map fst @assigns.pairs)
                                   @assigns.pairs

        loc.backTree = Update @ann
                              @table
                              @assigns.annotatedTree
                              @whr.annotatedTree
                              @returning
        loc.envUpdates = []

-- local identifier bindings: pass the table attribute names and types
-- into the where expression

SEM Statement
    | Update
        whr.lib =
            case (do
                   ct <- envCompositeAttrs @lhs.env [TableComposite,ViewComposite] @table
                   updateBindings @lhs.lib [LibStackIDs [("", ct)]]) of
                 Left x -> error $ show x
                 Right e -> e

{-
== set clauses

small complication is slightly hacky code to deal with row set
assignments, where we assign from a multiple attribute subselect into
mulitple columns - todo: check if we need so much special casing for
this: should be able to reuse the funcall typing of row set equality
(trade one hack for another, squinting so that assignment looks like
an equality check - since it type checks the same we might be ok). If
we do this, we only need to expand the row sets out to produce a
single string,type list at the end.

-}

ATTR SetClauseList [||pairs : {[(String,Type)]}
                      rowSetErrors : {[TypeError]}]

SEM SetClauseList
  | Cons lhs.pairs = @hd.pairs ++ @tl.pairs
         lhs.rowSetErrors = maybeToList @hd.rowSetError ++ @tl.rowSetErrors
  | Nil lhs.pairs = []
        lhs.rowSetErrors = []

ATTR SetClause [||pairs : {[(String,Type)]}
                  rowSetError : {Maybe TypeError}]

SEM SetClause
    | SetClause
        lhs.pairs = [(@att, getTypeAnnotation @val.annotatedTree)]
        lhs.rowSetError = Nothing
    | RowSetClause
        loc.rowSetError =
          let atts = @atts.strings
              types = getRowTypes @vals.typeList
          in if length atts /= length types
               then Just WrongNumberOfColumns
               else Nothing
        lhs.pairs = zip @atts.strings $ getRowTypes @vals.typeList

{
getRowTypes :: [Type] -> [Type]
getRowTypes [RowCtor ts] = ts
getRowTypes ts = ts
}

{-
================================================================================

= delete
-}

SEM Statement
    | Delete
        loc.tpe =
            do
            checkRelationExists @lhs.env @table
            Right $ Pseudo Void
        loc.statementInfo = [DeleteInfo @table]
        loc.backTree = Delete @ann @table @whr.annotatedTree @returning
        loc.envUpdates = []
        loc.columnTypes = fromRight [] $ envCompositeAttrs @lhs.env [TableComposite,ViewComposite] @table
        whr.lib = case updateBindings @lhs.lib [LibStackIDs [("", @loc.columnTypes)]] of
                         Left x -> error $ show x
                         Right e -> e

{-
================================================================================
-}
{

checkRelationExists :: Environment -> String -> Either [TypeError] ()
checkRelationExists env tbl = do
    envCompositeDef env [TableComposite, ViewComposite] tbl
    return ()

checkColumnConsistency :: Environment ->  String -> [String] -> [(String,Type)]
                       -> Either [TypeError] [(String,Type)]
checkColumnConsistency env tbl cols' insNameTypePairs = do
  ttcols <- envCompositePublicAttrs env [] tbl
  let cols :: [String]
      cols = if null cols'
               then map fst ttcols
               else cols'
  errorWhen (length insNameTypePairs /= length cols) [WrongNumberOfColumns]
  let nonMatchingColumns = cols \\ map fst ttcols
  errorWhen (not $ null nonMatchingColumns) $
       map UnrecognisedIdentifier nonMatchingColumns
  let targetNameTypePairs =
        map (\l -> (l,fromJust $ lookup l ttcols)) cols
        --check the types of the insdata match the column targets
        --name datatype columntype
      typeTriples = map (\((a,b),c) -> (a,b,c)) $ zip targetNameTypePairs $ map snd insNameTypePairs
      errs :: [TypeError]
      errs = concat $ lefts $ map (\(_,b,c) -> checkAssignmentValid env c b) typeTriples
  unless (null errs) $ Left errs
  return targetNameTypePairs

}
