{-
Copyright 2009 Jake Wheat

Contains bit and pieces of type checking which don't fit anywhere else

-}

{-

================================================================================

= type names

Types with type modifiers (called PrecTypeName here, to be changed),
are not supported at the moment.

-}

ATTR TypeName [||namedType : Type]

SEM TypeName
     | SimpleTypeName ArrayTypeName SetOfTypeName PrecTypeName
         lhs.namedType = errorToTypeFail @loc.tpe
         lhs.annotatedTree = updateAnnotation
                               ((map TypeErrorA $ getErrors @loc.tpe) ++)
                               @loc.backTree


SEM TypeName
     | SimpleTypeName
        loc.tpe = envLookupType @lhs.env $ canonicalizeTypeName @tn
        loc.backTree = SimpleTypeName @ann @tn
     | ArrayTypeName
        loc.tpe = chainTypeCheckFailed [@typ.namedType] $ Right $ ArrayType @typ.namedType
        loc.backTree = ArrayTypeName @ann @typ.annotatedTree
     | SetOfTypeName
        loc.tpe = chainTypeCheckFailed [@typ.namedType] $ Right $ SetOfType @typ.namedType
        loc.backTree = SetOfTypeName @ann @typ.annotatedTree
     | PrecTypeName
        loc.tpe = Right TypeCheckFailed
        loc.backTree = PrecTypeName @ann @tn @prec


{
annTypesAndErrors :: Data a => a -> Type -> [TypeError]
                  -> Maybe [AnnotationElement] -> a
annTypesAndErrors item nt errs add =
    updateAnnotation modifier item
    where
      modifier = (([TypeAnnotation nt] ++ fromMaybe [] add ++
       map TypeErrorA errs) ++)

}

{-
================================================================================

= expression lists and lists of lists

-}

ATTR ExpressionList [||typeList : {[Type]}]

SEM ExpressionList
    | Cons lhs.typeList = getTypeAnnotation @hd.annotatedTree : @tl.typeList
    | Nil lhs.typeList = []


ATTR ExpressionListList  [||typeListList : {[[Type]]}]

SEM ExpressionListList
    | Cons lhs.typeListList = @hd.typeList : @tl.typeListList
    | Nil lhs.typeListList = []


-- Maybe expression stuff

SEM MaybeBoolExpression
    | Just
        lhs.annotatedTree =
          if getTypeAnnotation @just.annotatedTree `notElem` [typeBool, TypeCheckFailed]
            then Just $ updateAnnotation ((TypeErrorA ExpressionMustBeBool) :)
                          @just.annotatedTree
            else Just $ @just.annotatedTree

ATTR MaybeExpression [||exprType : {Maybe Type}]

SEM MaybeExpression
    | Just lhs.exprType = Just $ getTypeAnnotation @just.annotatedTree
    | Nothing lhs.exprType = Nothing

{
{-
I think this should be alright, an identifier referenced in an
expression can only have zero or one dot in it.
-}

splitIdentifier :: String -> (String,String)
splitIdentifier s = let (a,b) = span (/= '.') s
                    in if b == ""
                         then ("", a)
                         else (a,tail b)


--returns the type of the relation, and the system columns also

getRelationType :: Environment -> String -> Either [TypeError] (Type,Type)
getRelationType env tbl =
          case getAttrs env [TableComposite, ViewComposite] tbl of
            Just ((_,_,a@(UnnamedCompositeType _), s@(UnnamedCompositeType _)))
                 -> Right (a,s)
            _ -> Left [UnrecognisedRelation tbl]

{-
lookup a composite type name, restricting it to only certain kinds of
composite type, returns the composite definition which you can get the
attributes out of which is a pair with the normal columns first, then
the system columns second
-}

getAttrs :: Environment -> [CompositeFlavour] -> String -> Maybe CompositeDef
getAttrs env f n = case envCompositeAttrs env f (CompositeType n) of
                     Left _ -> Nothing
                     Right a -> Just a


}