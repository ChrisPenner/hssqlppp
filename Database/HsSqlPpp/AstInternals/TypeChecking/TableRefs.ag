{-
Copyright 2009 Jake Wheat

This file contains the checking for tablerefs (the from part of a
select expression).

-}

ATTR TableRef MaybeTableRef [|| libUpdates: {[LocalIdentifierBindingsUpdate]}]

ATTR TableRef [|| idLookups : {[(String,Type)]}
                  starExpansion : {[(String,Type)]}
                  qidLookups : {[(String,[(String,Type)])]}
                  qstarExpansion : {[(String,[(String,Type)])]}]

SEM TableRef
    | SubTref TrefAlias Tref TrefFun TrefFunAlias JoinedTref
        lhs.annotatedTree =
            updateAnnotation (map TypeErrorA @loc.errs ++) @loc.backTree

SEM MaybeTableRef
    | Nothing
        lhs.libUpdates = []


SEM TableRef
    | SubTref TrefAlias Tref TrefFun TrefFunAlias JoinedTref
        loc.libUpdates = if null @errs
                           then [LibStackIDs $ ("", @loc.idLookups): @loc.qidLookups
                                ,LibSetStarExpansion $ ("", @loc.starExpansion): @loc.qstarExpansion]
                           else []
        lhs.libUpdates = @loc.libUpdates

-- one of the main hairy bits of code which needs a serious refactor:
SEM TableRef
    | SubTref TrefAlias Tref TrefFun TrefFunAlias JoinedTref
        lhs.idLookups = @loc.idLookups
        lhs.qidLookups = @loc.qidLookups
        lhs.starExpansion = @loc.starExpansion
        lhs.qstarExpansion = @loc.qstarExpansion
    | SubTref
        loc.errs = case @loc.selectAttrs of
                           Left e -> e
                           Right _ -> []
        loc.backTree = SubTref @ann @sel.annotatedTree @alias
        loc.selectAttrs = unwrapSetOfComposite (getTypeAnnotation @sel.annotatedTree)
        loc.idLookups = fromRight [] @loc.selectAttrs
        loc.qidLookups = [(@alias, @loc.idLookups)]
        loc.starExpansion = @loc.idLookups
        loc.qstarExpansion = @loc.qidLookups
    | TrefAlias Tref
        loc.errs = case @loc.relType of
                     Left e -> e
                     Right _ -> []
        loc.relType = envCompositeAttrsPair @lhs.env [] @tbl
        loc.relType1 = fromRight ([],[]) @loc.relType
        loc.pAttrs = fst @loc.relType1
        loc.sAttrs = snd @loc.relType1
        loc.idLookups = @loc.pAttrs ++ @loc.sAttrs
        loc.qidLookups = [(@loc.alias1, @loc.idLookups)]
        loc.starExpansion = @loc.pAttrs
        loc.qstarExpansion = [(@loc.alias1, @loc.pAttrs)]
    | Tref
        loc.alias1 = @tbl
        loc.backTree = Tref @ann @tbl
    | TrefAlias
        loc.alias1 = @alias
        loc.backTree = TrefAlias @ann @tbl @alias
    | TrefFun TrefFunAlias
        loc.errs = case @eqfunIdens of
                     Left e -> e
                     Right _ -> []
        loc.eqfunIdens = funIdens @lhs.env @loc.alias1 @fn.annotatedTree
        loc.qfunIdens = fromRight ("",[]) @loc.eqfunIdens
        loc.alias2 = fst @loc.qfunIdens
        loc.funIdens = snd @loc.qfunIdens
        loc.idLookups = @loc.funIdens
        loc.qidLookups = [(@alias2, @loc.idLookups)]
        loc.starExpansion = @loc.idLookups
        loc.qstarExpansion = @loc.qidLookups
    | TrefFun
        loc.alias1 = ""
        loc.backTree = TrefFun @ann @fn.annotatedTree
    | TrefFunAlias
        loc.alias1 = @alias
        loc.backTree = TrefFunAlias @ann @fn.annotatedTree @alias
    | JoinedTref
        loc.errs = fromLeft [] @loc.ejoinAttrs
        loc.idLookups = @loc.joinAttrs ++
                          @loc.removeJoinAttrs @tbl.idLookups ++
                          @loc.removeJoinAttrs @tbl1.idLookups
        loc.qidLookups = @tbl.qidLookups ++ @tbl1.qidLookups
        loc.starExpansion = @loc.joinAttrs ++
                              @loc.removeJoinAttrs @tbl.starExpansion ++
                              @loc.removeJoinAttrs @tbl1.starExpansion
        loc.qstarExpansion = @tbl.qstarExpansion ++ @tbl1.qstarExpansion
        loc.removeJoinAttrs = filter (\(n,_) -> n `notElem` @loc.joinNames)
        loc.joinNames = map fst @loc.joinAttrs
        loc.joinAttrs = fromRight [] @loc.ejoinAttrs
        loc.ejoinAttrs =
            do
            let jns = case (@nat.annotatedTree, @onExpr.originalTree) of
                          (Natural, _) -> commonFieldNames
                          (_,Just (JoinUsing _ s)) -> s
                          _ -> []
                tjtsm = map (flip lookup @tbl.idLookups) jns
                t1jtsm = map (flip lookup @tbl1.idLookups) jns
            errorWhen (not $ null $ filter (==Nothing) $ tjtsm ++ t1jtsm)
                      [MissingJoinAttribute]
            let tjts = catMaybes tjtsm
                t1jts = catMaybes t1jtsm
                resolvedTypes :: [Either [TypeError] Type]
                resolvedTypes = map (\(a,b) -> resolveResultSetType @lhs.env [a,b]) $ zip tjts t1jts
            liftErrors $ concat $ lefts resolvedTypes
            return $ zip jns $ rights resolvedTypes
            where
              commonFieldNames = intersect (f @tbl.starExpansion) (f @tbl1.starExpansion)
                                 where f = map fst

        loc.backTree = JoinedTref @ann
                                  @tbl.annotatedTree
                                  @nat.annotatedTree
                                  @joinType.annotatedTree
                                  @tbl1.annotatedTree
                                  @onExpr.annotatedTree
        onExpr.lib = case updateBindings @lhs.lib @loc.libUpdates of
                       Left x -> error $ show x
                       Right e -> e

{
funIdens :: Environment -> String -> Expression -> Either [TypeError] (String,[(String,Type)])
funIdens env alias fnVal = do
   errorWhen (case fnVal of
                FunCall _ _ _ -> False
                _ -> True)
             [ContextError "FunCall"]
   let (FunCall _ fnName _) = fnVal
       correlationName = if alias /= ""
                           then alias
                           else fnName
   attrs <- do
     case getTypeAnnotation fnVal of
       SetOfType (CompositeType t) -> envCompositePublicAttrs env [] t
       SetOfType x -> return [(correlationName,x)]
       y -> return [(correlationName,y)]
   return (correlationName, attrs)
   where
     getCompositeType t = UnnamedCompositeType $ fromRight [] $ envCompositePublicAttrs env [] t
}

