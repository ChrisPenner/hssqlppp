
SEM Statement
    | Return
        loc.tpe = chainTypeCheckFailed [fromMaybe typeBool @value.exprType] $ Right $ Pseudo Void
        loc.backTree = Return @ann @value.annotatedTree
        loc.envUpdates = []
        loc.statementInfo = []


SEM Statement
    | Assignment
        loc.tpe =
            do
            let fromType = getTypeAnnotation @value.annotatedTree
            toType <- libLookupID @lhs.lib "" @target
            chainTypeCheckFailed [getTypeAnnotation @value.annotatedTree, toType] $ do
              checkAssignmentValid @lhs.env fromType toType
              return $ Pseudo Void
        loc.backTree = Assignment @ann @target @value.annotatedTree
        loc.envUpdates = []
        loc.statementInfo = []


SEM Statement
    | ForSelectStatement
        loc.selType = getTypeAnnotation @sel.annotatedTree
        loc.tpe =
          do
          chainTypeCheckFailed [@loc.selType] $ do
            toType <- libLookupID @lhs.lib "" @var
            chainTypeCheckFailed [toType] $ do
              if toType /= Pseudo Record
                then checkAssignmentValid @lhs.env @loc.selType toType
                else Right ()
              return $ Pseudo Void

        sts.lib =
          case @loc.tpe of
            Left _ -> @lhs.lib
            Right _ -> case @loc.selType of
                         UnnamedCompositeType t ->
                             case updateBindings @lhs.lib [LibStackIDs [(@var, t)]] of
                               Left x -> error $ show x
                               Right e -> e
                         SetOfType (UnnamedCompositeType t) ->
                             case updateBindings @lhs.lib [LibStackIDs [(@var, t)]] of
                               Left x -> error $ show x
                               Right e -> e
                         _ -> @lhs.lib

        loc.backTree = ForSelectStatement @ann @var @sel.annotatedTree @sts.annotatedTree
        loc.envUpdates = []
        loc.statementInfo = []

