{-
Copyright 2009 Jake Wheat

This file contains the type checking code for the expression ast data
type.

-}


SEM Expression
    | IntegerLit StringLit FloatLit BooleanLit NullLit FunCall Identifier
      Exists Case CaseSimple Cast InPredicate ScalarSubQuery LiftOperator
      --PositionalArg WindowFn
        lhs.annotatedTree = annTypesAndErrors @loc.backTree
                              (errorToTypeFail @loc.tpe)
                              (getErrors @loc.tpe)
                              Nothing

{-
== literals
-}

SEM Expression
    | IntegerLit
        loc.backTree = IntegerLit @ann @i
    | StringLit
        loc.backTree = StringLit @ann @quote @value
    | FloatLit
        loc.backTree = FloatLit @ann @d
    | BooleanLit
        loc.backTree = BooleanLit @ann @b
    | NullLit
        loc.backTree = NullLit @ann

SEM Expression
     | IntegerLit loc.tpe = Right typeInt
     | StringLit loc.tpe = Right UnknownStringLit
     | FloatLit loc.tpe = Right typeNumeric
     | BooleanLit loc.tpe = Right typeBool
     -- I think a null has the same type resolution as an unknown string lit
     | NullLit loc.tpe = Right UnknownStringLit


{-

== cast expression

-}

SEM Expression
    | Cast loc.tpe = Right $ @tn.namedType
           loc.backTree = Cast @ann @expr.annotatedTree @tn.annotatedTree

{-
== operators and functions
-}
SEM Expression
    | FunCall
        loc.tpe = chainTypeCheckFailed @args.typeList $
                    typeCheckFunCall
                      @lhs.env
                      @funName
                      @args.typeList
        loc.backTree = FunCall @ann @funName @args.annotatedTree

{
typeCheckFunCall :: Environment -> String -> [Type] -> Either [TypeError] Type
typeCheckFunCall env fnName argsType =
    chainTypeCheckFailed argsType $
      case fnName of
              -- do the special cases first, some of these will use
              -- the variadic support when it is done and no longer
              -- be special cases.
              "!arrayCtor" ->
                    ArrayType <$> resolveResultSetType env argsType
              "!between" -> do
                    f1 <- lookupFn ">=" [argsType !! 0, argsType !! 1]
                    f2 <- lookupFn "<=" [argsType !! 0, argsType !! 2]
                    lookupFn "!and" [f1,f2]
              "coalesce" -> resolveResultSetType env argsType
              "greatest" -> do
                    t <- resolveResultSetType env argsType
                    lookupFn ">=" [t,t]
                    return t
              "least" -> do
                    t <- resolveResultSetType env argsType
                    lookupFn "<=" [t,t]
                    return t
              "!rowCtor" -> return $ RowCtor argsType
                    -- special case the row comparison ops
              _ | let isRowCtor t = case t of
                                      RowCtor _ -> True
                                      _ -> False
                  in fnName `elem` ["=", "<>", "<=", ">=", "<", ">"]
                         && length argsType == 2
                         && all isRowCtor argsType ->
                    checkRowTypesMatch (head argsType) (head $ tail argsType)
              --checked for all special cases, so run general case now
              s -> lookupFn s argsType
    where
      lookupFn :: String -> [Type] -> Either [TypeError] Type
      lookupFn s1 args = do
        (_,_,r) <- findCallMatch env
                             (if s1 == "u-" then "-" else s1) args
        return r
      checkRowTypesMatch (RowCtor t1s) (RowCtor t2s) = do
        when (length t1s /= length t2s) $ Left [ValuesListsMustBeSameLength]
        --this is wrong - we want all the errors, not just the first set
        mapM_ (resolveResultSetType env . (\(a,b) -> [a,b])) $ zip t1s t2s
        return typeBool
      checkRowTypesMatch x y  =
        error $ "internal error: checkRowTypesMatch called with " ++ show x ++ "," ++ show y
}

--lifted operator

SEM Expression
    | LiftOperator
        loc.tpe = chainTypeCheckFailed @args.typeList $
                    do
                      let args = @args.annotatedTree
                      errorWhen (length args /= 2)
                                [AnyAllError $ "must have two args, got " ++ show args]
                      let [a,b] = args
                          bType = getTypeAnnotation b
                      let t1 = getTypeAnnotation a
                      chainTypeCheckFailed [t1,bType] $ do
                        errorWhen (not $ isArrayType bType)
                           [AnyAllError $ "second arg must be array, got " ++ show args]
                        t2 <- unwrapArray $ bType
                        t3 <- typeCheckFunCall
                                @lhs.env
                                @oper
                                [t1,t2]
                        errorWhen (t3 /= typeBool)
                                  [AnyAllError $ "operator must have bool return, got " ++ show t3]
                        return t3
        loc.backTree = LiftOperator @ann @oper @flav.annotatedTree @args.annotatedTree


{-
== case expression

for non simple cases, we need all the when expressions to be bool, and
then to collect the types of the then parts to see if we can resolve a
common type

for simple cases, we need to check all the when parts have the same type
as the value to check against, then we collect the then parts as above.

-}

SEM Expression
    | Case CaseSimple
        loc.whenTypes = map getTypeAnnotation $ concatMap fst $
                        @cases.annotatedTree
        loc.thenTypes = map getTypeAnnotation $
                            (map snd $ @cases.annotatedTree) ++
                              maybeToList @els.annotatedTree

SEM Expression
    | Case
        loc.tpe =
            chainTypeCheckFailed @loc.whenTypes $ do
               when (any (/= typeBool) @loc.whenTypes) $
                 Left [WrongTypes typeBool @loc.whenTypes]
               chainTypeCheckFailed @loc.thenTypes $
                        resolveResultSetType
                          @lhs.env
                          @loc.thenTypes
        loc.backTree = Case @ann @cases.annotatedTree @els.annotatedTree


SEM Expression
    | CaseSimple
        loc.tpe =
          chainTypeCheckFailed @loc.whenTypes $ do
          checkWhenTypes <- resolveResultSetType
                                 @lhs.env
                                 (getTypeAnnotation @value.annotatedTree: @loc.whenTypes)
          chainTypeCheckFailed @loc.thenTypes $
                     resolveResultSetType
                              @lhs.env
                              @loc.thenTypes
        loc.backTree = CaseSimple @ann @value.annotatedTree @cases.annotatedTree @els.annotatedTree

{-
== identifiers
pull id types out of env for identifiers

-}

SEM Expression
    | Identifier
        loc.tpe = let (correlationName,iden) = splitIdentifier @i
                  in libLookupID @lhs.lib correlationName iden
        loc.backTree = Identifier @ann @i

SEM Expression
    | Exists
        loc.tpe = Right typeBool
        loc.backTree = Exists @ann @sel.annotatedTree


{-
== scalar subquery
1 col -> type of that col
2 + cols -> row type
-}

SEM Expression
    | ScalarSubQuery
        loc.tpe = let selType = getTypeAnnotation @sel.annotatedTree
                  in chainTypeCheckFailed [selType]
                       $ do
                         f <- map snd <$> unwrapSetOfComposite selType
                         case length f of
                              0 -> Left [InternalError "no columns in scalar subquery?"]
                              1 -> Right $ head f
                              _ -> Right $ RowCtor f

        loc.backTree = ScalarSubQuery @ann @sel.annotatedTree
{-
== inlist
-}

SEM Expression
    | InPredicate
        loc.tpe = do
                    lt <- @list.listType
                    ty <- resolveResultSetType
                            @lhs.env
                            [getTypeAnnotation @expr.annotatedTree, lt]
                    return typeBool
        loc.backTree = InPredicate @ann @expr.annotatedTree @i @list.annotatedTree


ATTR InList [||listType : {Either [TypeError] Type}]

SEM InList
    | InList
        lhs.listType = resolveResultSetType
                         @lhs.env
                         @exprs.typeList
    | InSelect
        lhs.listType =
            do
              attrs <-  map snd <$> (unwrapSetOfComposite $
                          let a = getTypeAnnotation @sel.annotatedTree
                          in {-trace ("attrs is: " ++ show a) $-} a)
              typ <- case length attrs of
                           0 -> Left [InternalError "got subquery with no columns? in inselect"]
                           1 -> Right $ head attrs
                           _ -> Right $ RowCtor attrs
              chainTypeCheckFailed attrs $ Right typ

