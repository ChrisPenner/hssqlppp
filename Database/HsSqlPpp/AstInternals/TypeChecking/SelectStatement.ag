{-

================================================================================

= basic select statements

This is a bit of a mess, will be rewritten with a proper literate
flavour once all the different bits are type checking ok, which should
make it much more readable.

-}

SEM Statement
    | SelectStatement
        loc.tpe = chainTypeCheckFailed [getTypeAnnotation @ex.annotatedTree] $ Right $ Pseudo Void
        loc.statementInfo = [SelectInfo $ getTypeAnnotation @ex.annotatedTree]
        loc.backTree = SelectStatement @ann @ex.annotatedTree
        loc.envUpdates = []

{-

================================================================================

Type checking select expressions

The main issue is the complicated flow of identifier bindings through the
various parts. This is the rough order in which this happens:

with
from
where
groupby
having
select
combine
orderby
limit

if a type error occurs, we want to give up on any following stages,
rather than create loads of type errors (maybe this could be refined
more).

The select list produces the final type which the selectexpression has.

inside the from, if we have any join expressions we need to pass the types
from the joined trefs to the join expressions.

So, the basic plan is to propagate the iden bindings in the env attribute
as elsewhere, and also pass along a flag to say whether the previous stage
type checked or not, so we can bail if it has failed.

-}

SEM SelectExpression
    | Values Select CombineSelect
        lhs.annotatedTree = annTypesAndErrors @loc.backTree
                              (errorToTypeFail @loc.tpe)
                              (getErrors @loc.tpe)
                              Nothing

SEM SelectExpression
    | Values
        loc.tpe = typeCheckValuesExpr
                              @lhs.env
                              @vll.typeListList
        loc.backTree = Values @ann @vll.annotatedTree
    | Select
        loc.tpe =
           do
           let trefType = fromMaybe typeBool $ fmap getTypeAnnotation
                                                    @selTref.annotatedTree
               slType = @selSelectList.listType
           chainTypeCheckFailed [trefType, slType] $
             Right $ case slType of
                       UnnamedCompositeType [(_,Pseudo Void)] -> Pseudo Void
                       _ -> SetOfType slType
        loc.backTree = Select @ann
                              @selDistinct.annotatedTree
                              @selSelectList.annotatedTree
                              @selTref.annotatedTree
                              @selWhere.annotatedTree
                              @selGroupBy.annotatedTree
                              @selHaving.annotatedTree
                              @selOrderBy.annotatedTree
                              @selDir.annotatedTree
                              @selLimit.annotatedTree
                              @selOffset.annotatedTree
    | CombineSelect
        loc.tpe =
          let sel1t = getTypeAnnotation @sel1.annotatedTree
              sel2t = getTypeAnnotation @sel2.annotatedTree
          in chainTypeCheckFailed [sel1t, sel2t] $
                typeCheckCombineSelect @lhs.env sel1t sel2t
        loc.backTree = CombineSelect @ann @ctype.annotatedTree
                                     @sel1.annotatedTree
                                     @sel2.annotatedTree

{

typeCheckValuesExpr :: Environment -> [[Type]] -> Either [TypeError] Type
typeCheckValuesExpr env rowsTs =
        let colNames = zipWith (++)
                           (repeat "column")
                           (map show [1..length $ head rowsTs])
        in unionRelTypes env rowsTs colNames


typeCheckCombineSelect :: Environment -> Type -> Type -> Either [TypeError] Type
typeCheckCombineSelect env v1 v2 = do
    u1 <- unwrapSetOfComposite v1
    let colNames = map fst u1
    u2 <- unwrapSetOfComposite v2
    let colTypes1 = map snd u1
    let colTypes2 = map snd u2
    unionRelTypes env [colTypes1,colTypes2] colNames

unionRelTypes :: Environment -> [[Type]] -> [String] -> Either [TypeError] Type
unionRelTypes env rowsTs colNames =
  let lengths = map length rowsTs
  in case () of
             _ | null rowsTs ->
                   Left [NoRowsGivenForValues]
               | not (all (==head lengths) lengths) ->
                   Left [ValuesListsMustBeSameLength]
               | otherwise ->
                   --i don't think this propagates all the errors, just the first set
                   mapM (resolveResultSetType env) (transpose rowsTs) >>=
                     (return . SetOfType . UnnamedCompositeType . zip colNames)


getTbCols c = unwrapSetOfComposite (getTypeAnnotation c)
}

ATTR TableRef MaybeTableRef [||idens : {[(String,([(String,Type)],[(String,Type)]))]}
                                  joinIdens : {[String]} ]

SEM TableRef
    | SubTref TrefAlias Tref TrefFun TrefFunAlias JoinedTref
        lhs.annotatedTree = annTypesAndErrors @loc.backTree
                              (errorToTypeFail @loc.tpe)
                              (getErrors @loc.tpe)
                              Nothing

-- one of the main hairy bits of code which needs a serious refactor:
SEM TableRef
    | SubTref loc.tpe = chainTypeCheckFailed [getTypeAnnotation @sel.annotatedTree] <$>
                        unwrapSetOfWhenComposite $ getTypeAnnotation @sel.annotatedTree
              loc.backTree = SubTref @ann @sel.annotatedTree @alias
              lhs.idens = [(@alias, (fromRight [] $ getTbCols @sel.annotatedTree, []))]
              lhs.joinIdens = []
    | TrefAlias Tref
        loc.tpe = either Left (Right . UnnamedCompositeType . fst) @loc.relType
        lhs.joinIdens = []
        loc.relType = envCompositeAttrsPair @lhs.env [] @tbl
        loc.unwrappedRelType =
            fromRight ([],[]) @loc.relType
    | Tref
        lhs.idens = [(@tbl, @loc.unwrappedRelType)]
        loc.backTree = Tref @ann @tbl
    | TrefAlias
        lhs.idens = [(@alias, @loc.unwrappedRelType)]
        loc.backTree = TrefAlias @ann @tbl @alias
    | TrefFun TrefFunAlias
        loc.tpe = getFnType @lhs.env @loc.alias1 @fn.annotatedTree
        lhs.joinIdens = []
        lhs.idens = case getFunIdens
                              @lhs.env @loc.alias1
                              @fn.annotatedTree of
                      Right (s, UnnamedCompositeType c) -> [(s,(c,[]))]
                      _ -> []
    | TrefFun
        loc.alias1 = ""
        loc.backTree = TrefFun @ann @fn.annotatedTree
    | TrefFunAlias
        loc.alias1 = @alias
        loc.backTree = TrefFunAlias @ann @fn.annotatedTree @alias
    | JoinedTref
        loc.tpe =
            chainTypeCheckFailed [tblt
                      ,tbl1t] $
               case (@nat.annotatedTree, @onExpr.annotatedTree) of
                      (Natural, _) -> unionJoinList $
                                      commonFieldNames tblt tbl1t
                      (_,Just (JoinUsing _ s)) -> unionJoinList s
                      _ -> unionJoinList []
            where
              tblt = getTypeAnnotation @tbl.annotatedTree
              tbl1t = getTypeAnnotation @tbl1.annotatedTree
              unionJoinList s =
                  combineTableTypesWithUsingList @lhs.env s tblt tbl1t
        loc.idens = @tbl.idens ++ @tbl1.idens
        loc.joinIdens = commonFieldNames (getTypeAnnotation @tbl.annotatedTree)
                                         (getTypeAnnotation @tbl1.annotatedTree)
        lhs.idens = @loc.idens
        lhs.joinIdens = @loc.joinIdens
        loc.backTree = JoinedTref @ann
                                  @tbl.annotatedTree
                                  @nat.annotatedTree
                                  @joinType.annotatedTree
                                  @tbl1.annotatedTree
                                  @onExpr.annotatedTree
        onExpr.lib = case updateBindings @lhs.lib
                            (convertToNewStyleUpdates @loc.idens @loc.joinIdens) of
                       Left x -> error $ show x
                       Right e -> e

{
{-
this function a bit of a mess - artefact of not fully updated code
after the environment data type was changed.
-}
convertToNewStyleUpdates :: [(String, ([(String,Type)], [(String,Type)]))] -> [String] -> [LocalIdentifierBindingsUpdate]
convertToNewStyleUpdates qualIdens joinIdens =
  -- we're given a list of qualified types, and a list of names of join columns
  -- want to produce a list of qualified types, with an additional one with "" qualification
  -- and produce a star expansion
    [LibStackIDs newQualifiedList
    ,LibSetStarExpansion newStarExpansion]
  where
    qualifiedFieldsCombined :: [(String,[(String,Type)])]
    qualifiedFieldsCombined = map (\(alias,(att,sysatt)) -> (alias, att++sysatt)) qualIdens
    isJoinField (n,_) = n `elem` joinIdens
    (joinFields,nonJoinFields) = partition isJoinField $ concatMap snd qualifiedFieldsCombined
    --need to resolve types instead of using nub
    newQualifiedList = ("", nub joinFields ++ nonJoinFields):qualifiedFieldsCombined
    qualifiedFieldsStarExp = map (\(alias,(att,_)) -> (alias, att)) qualIdens
    (joinFieldsStarExp,nonJoinFieldsStarExp) =
        partition isJoinField $ concatMap snd qualifiedFieldsStarExp
    --need to resolve types instead of using nub
    newStarExpansion = ("", nub joinFieldsStarExp ++ nonJoinFieldsStarExp):qualifiedFieldsStarExp

{-
combine two relvar types when being joined, pass in a using list and
it checks the types in the using list are compatible, and eliminates
duplicate columns of the attrs in the using list, returns the relvar
type of the joined tables.
-}
combineTableTypesWithUsingList :: Environment -> [String] -> Type -> Type -> Either [TypeError] Type
combineTableTypesWithUsingList env l t1c t2c = do
    --check t1 and t2 have l
    t1 <-unwrapComposite t1c
    t2 <- unwrapComposite t2c
    let names1 = getNames t1
    let names2 = getNames t2
    when (not (contained l names1) ||
              not (contained l names2)) $
         Left [MissingJoinAttribute]
    --check the types
    joinColumnTypes <- mapM (getColumnType t1 t2) l
    let nonJoinColumns =
            let notJoin = (\(s,_) -> s `notElem` l)
            in filter notJoin t1 ++ filter notJoin t2
    return $ UnnamedCompositeType $ zip l joinColumnTypes ++ nonJoinColumns
    where
      getNames :: [(String,Type)] -> [String]
      getNames = map fst
      contained l1 l2 = all (`elem` l2) l1
      getColumnType :: [(String,Type)] -> [(String,Type)] -> String -> Either [TypeError] Type
      getColumnType t1 t2 f =
          let ct1 = getFieldType t1 f
              ct2 = getFieldType t2 f
          in resolveResultSetType env [ct1,ct2]
      getFieldType t f = snd $ fromJust $ find (\(s,_) -> s == f) t

commonFieldNames :: Type -> Type -> [String]
commonFieldNames t1 t2 =
    intersect (fn t1) (fn t2)
    where
      fn (UnnamedCompositeType s) = map fst s
      fn _ = []

getFnType :: Environment -> String -> Expression -> Either [TypeError] Type
getFnType env alias =
    either Left (Right . snd) . getFunIdens env alias

getFunIdens :: Environment -> String -> Expression -> Either [TypeError] (String,Type)
getFunIdens env alias fnVal =
   case fnVal of
       FunCall _ f _ ->
           let correlationName = if alias /= ""
                                   then alias
                                   else f
           in Right (correlationName, case getTypeAnnotation fnVal of
                SetOfType (CompositeType t) -> getCompositeType t
                SetOfType x -> UnnamedCompositeType [(correlationName,x)]
                y -> UnnamedCompositeType [(correlationName,y)])
       x -> Left [ContextError "FunCall"]
   where
     getCompositeType t = UnnamedCompositeType $ fromRight [] $ envCompositePublicAttrs env [] t
}

SEM MaybeTableRef
    | Nothing
        lhs.idens = []
        lhs.joinIdens = []

ATTR SelectItemList SelectList [||listType : Type]

SEM SelectItemList
    | Cons lhs.listType = doSelectItemListTpe @lhs.lib @hd.columnName @hd.itemType @tl.listType
    | Nil lhs.listType = UnnamedCompositeType []

{
doSelectItemListTpe :: LocalIdentifierBindings
                    -> String
                    -> Type
                    -> Type
                    -> Type
doSelectItemListTpe env colName colType types =
    if types == TypeCheckFailed
       then types
       else errorToTypeFail (do
         let (correlationName,iden) = splitIdentifier colName
         newCols <- if iden == "*"
                         then libExpandStar env correlationName
                         else return [(iden, colType)]
         foldM (flip consComposite) types $ reverse newCols)
}


ATTR SelectItem [||itemType : Type]

SEM SelectItem
    | SelExp SelectItem
        lhs.itemType = getTypeAnnotation @ex.annotatedTree

-- hack to fix up for errors for ok *
SEM SelectItem
    | SelExp
        loc.annotatedTree = SelExp @ann $ fixStar @ex.annotatedTree
    | SelectItem
        loc.backTree = SelectItem @ann (fixStar @ex.annotatedTree) @name

{

fixStar :: Expression -> Expression
fixStar =
    everywhere (mkT fixStar')
    where
      fixStar' :: Annotation -> Annotation
      fixStar' a =
          if TypeAnnotation TypeCheckFailed `elem` a
              && any (\an ->
                       case an of
                         TypeErrorA (UnrecognisedIdentifier x) |
                           let (_,iden) = splitIdentifier x
                           in iden == "*" -> True
                         _ -> False) a
             then filter (\an -> case an of
                                   TypeAnnotation TypeCheckFailed -> False
                                   TypeErrorA (UnrecognisedIdentifier _) -> False
                                   _ -> True) a
             else a
}

SEM SelectList
    | SelectList
        lhs.listType = @items.listType


{-

== env passing

env flow:
current simple version:
from tref -> select list
          -> where

(so we take the identifiers and types from the tref part, and send
them into the selectlist and where parts)

full order of identifier passing:
   1. from
   2. where
   3. group by
   4. having
   5. select


group by notes, from the pg manual:
group by expressions can be an input column name, or the name or
ordinal number of an output column (SELECT list item), or an arbitrary
expression formed from input-column values. In case of ambiguity, a
GROUP BY name will be interpreted as an input-column name rather than
an output column name.

For now, just send the input columns in as identifiers

-}

SEM SelectExpression
    | Select
         loc.newLib = case updateBindings @lhs.lib
                            (convertToNewStyleUpdates @selTref.idens @selTref.joinIdens) of
                        Left x -> error $ show x -- @lhs.env
                        Right e -> e
         selSelectList.lib = @loc.newLib
         selWhere.lib = @loc.newLib
         selGroupBy.lib = @loc.newLib

{-

== attributes

columnName is used to collect the column names that the select list
produces, it is combined into an unnamedcompositetype in
selectitemlist, which is also where star expansion happens.

-}

ATTR SelectItem [||columnName : String]

{-
if the select item is just an identifier, then that column is named
after the identifier
e.g. select a, b as c, b + c from d, gives three columns one named
a, one named c, and one unnamed, even though only one has an alias
if the select item is a function or aggregate call at the top level,
then it is named after that function or aggregate

if it is a cast, the column is named after the target data type name
iff it is a simple type name

-}

--default value for non identifier nodes

ATTR Expression [||liftedColumnName USE {`(fixedValue "")`} {""}: String]

{
fixedValue :: a -> a -> a -> a
fixedValue a _ _ = a
}

{-
override for identifier nodes, this only makes it out to the selectitem
node if the identifier is not wrapped in parens, function calls, etc.
-}

SEM Expression
  | Identifier lhs.liftedColumnName = @i
  | FunCall lhs.liftedColumnName =
      if isOperatorName @funName
         then ""
         else @funName
  | Cast lhs.liftedColumnName = case @tn.annotatedTree of
                                  SimpleTypeName _ tn -> tn
                                  _ -> ""

-- collect the aliases and column names for use by the selectitemlist nodes
SEM SelectItem
    | SelExp lhs.columnName = case @ex.liftedColumnName of
                                "" -> "?column?"
                                s -> s
    | SelectItem lhs.columnName = @name

