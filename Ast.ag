{-
Copyright 2009 Jake Wheat

This file contains the ast nodes, which aren't brilliantly designed,
and the attribute grammar system which uses the Utrecht University
Attribute Grammar system:

http://www.cs.uu.nl/wiki/bin/view/HUT/AttributeGrammarSystem
http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter

There is very limited source position information in the ast at the
moment. The grammar system is used to implement type checking, and
will also do other static checks, which is a work in progress and in a
very early state.

These ast nodes a are both used as the result of successful parsing,
and as the input to the pretty printer.

Lots of invalid sql is currently allowed if you construct the asts in
code, the parser isn't quite as lenient, but still can parse and not
complain about a lot of invalid sql.

use

uuagc -dcfws Ast.ag

to generate a new Ast.hs from this file

(install uuagc with
cabal install uuagc
)

Tip: after you've compiled this file with the above command, you can
get loads of warnings from ghc if you're the sort who enables
these. Using haskell-mode from emacs usually results in compiles being
really slow just cos emacs outputs all these warnings _really_ slowly,
and also any real warnings and errors can get drowned out. You can get
rid of these warnings by ghc compiling the produced Ast.hs on the
command line:
ghc -c TypeType.lhs FnTypes.hs PGTypes.hs Ast.hs

does the job, you can then compile from emacs and it will use the .o
file and you won't get any warnings about generated code in Ast.hs (if
the .o file gets stale, ghc / haskell mode will do the right thing and
ignore it, but it can't tell if the Ast.hs has gotten stale wrt
Ast.ag)
-}

MODULE {Ast}
{
    -- exports
    MySourcePos

    --ast nodes
   ,Statement (..)
   ,SelectExpression (..)
   ,FnBody (..)
   ,SetClause (..)
   ,TableRef (..)
   ,JoinExpression (..)
   ,JoinType (..)
   ,SelectList (..)
   ,SelectItem (..)
   ,CopySource (..)
   ,AttributeDef (..)
   ,RowConstraint (..)
   ,Constraint (..)
   ,TypeAttributeDef (..)
   ,ParamDef (..)
   ,VarDef (..)
   ,RaiseType (..)
   ,CombineType (..)
   ,Volatility (..)
   ,Language (..)
   ,TypeName (..)
   ,DropType (..)
   ,Cascade (..)
   ,Direction (..)
   ,Distinct (..)
   ,Natural (..)
   ,IfExists (..)
   ,RestartIdentity (..)
   ,Expression (..)
   ,FunName (..)
   ,KeywordOperator(..)
   ,OperatorType (..)
   ,getOperatorType
   ,InList (..)
   ,StatementList
   --checking stuff
   ,Message (..)
   ,MessageStuff (..)
   --types
   ,Type (..)
   ,PseudoType (..)
   ,TypeErrorInfo (..)
   --fns
   ,checkAst
   ,getExpressionType
   ,getStatementsType
   ,resetSps
   ,resetSp
   ,resetSp'
   ,resetSps'
   ,nsp
   ,checkFunctionTypes
   ,typeSmallInt
   ,typeBigInt
   ,typeInt
   ,typeNumeric
   ,typeFloat4
   ,typeFloat8
   ,typeVarChar
   ,typeChar
   ,typeBool

}
{
import Data.Maybe
import Data.List
import Debug.Trace

import TypeType
import PGTypes
import FnTypes

}

{-
================================================================================

SQL top level statements

everything is chucked in here, in particular this means that many places where
a select can appear inside another statement (e.g. a subselect), you can
instead put any statement - this type checks but is totally invalid.

-}

DATA Statement

--queries

    | SelectStatement ex:SelectExpression

-- dml

    --table targetcolumns insertdata(values or select statement) returning
    | Insert table : String
             targetCols : StringList
             insData : SelectExpression
             returning : (Maybe SelectList)
    --tablename setitems where returning
    | Update table : String
             assigns : SetClauseList
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename, where, returning
    | Delete table : String
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename column names, from
    | Copy table : String
           targetCols : StringList
           source : CopySource
    --represents inline data for copy statement
    | CopyData insData : String
    | Truncate tables: StringList
               restartIdentity : RestartIdentity
               cascade : Cascade

-- ddl

    | CreateTable name : String
                  atts : AttributeDefList
                  cons : ConstraintList
    | CreateTableAs name : String
                    expr : SelectExpression
    | CreateView name : String
                 expr : SelectExpression
    | CreateType name : String
                 atts : TypeAttributeDefList
    -- language name args rettype bodyquoteused body vol
    | CreateFunction lang : Language
                     name : String
                     params : ParamDefList
                     rettype : TypeName
                     bodyQuote : String
                     body : FnBody
                     vol : Volatility
    -- name type checkexpression
    | CreateDomain name : String
                   typ : TypeName
                   check : (Maybe Expression)
    -- ifexists (name,argtypes)* cascadeorrestrict
    | DropFunction ifE : IfExists
                   sigs : StringStringListPairList
                   cascade : Cascade
    -- ifexists names cascadeorrestrict
    | DropSomething dropType : DropType
                    ifE : IfExists
                    names : StringList
                    cascade : Cascade
    | Assignment target : String
                 value : Expression
    | Return value : (Maybe Expression)
    | ReturnNext expr : Expression
    | ReturnQuery sel : SelectExpression
    | Raise level : RaiseType
            message : String
            args : ExpressionList
    | NullStatement
    | Perform expr : Expression
    | Execute expr : Expression
    | ExecuteInto expr : Expression
                  targets : StringList
    | ForSelectStatement var : String
                         sel : SelectExpression
                         sts : StatementList
    | ForIntegerStatement var : String
                          from : Expression
                          to : Expression
                          sts : StatementList
    | WhileStatement expr : Expression
                     sts : StatementList
    | ContinueStatement
    --variable, list of when parts, else part
    | CaseStatement val : Expression
                    cases : ExpressionListStatementListPairList
                    els : StatementList
    --list is
    --first if (condition, statements):elseifs(condition, statements)
    --last bit is else statements
    | If cases : ExpressionStatementListPairList
         els : StatementList

-- =============================================================================

--Statement components

-- maybe this should be called relation valued expression?
DATA SelectExpression
    | Select selDistinct : Distinct
             selSelectList : SelectList
             selTref : (Maybe TableRef)
             selWhere : (Maybe Expression)
             selGroupBy : ExpressionList
             selHaving : (Maybe Expression)
             selOrderBy : ExpressionList
             selDir : Direction
             selLimit : (Maybe Expression)
             selOffset : (Maybe Expression)
    | CombineSelect ctype : CombineType
                    sel1 : SelectExpression
                    sel2 : SelectExpression
    | Values vll:ExpressionListList

DATA FnBody | SqlFnBody sts : StatementList
            | PlpgsqlFnBody VarDefList sts : StatementList

DATA SetClause | SetClause String Expression | RowSetClause StringList ExpressionList

DATA TableRef | Tref String
              | TrefAlias tref : String
                          alias : String
              | JoinedTref tref : TableRef
                           nat : Natural
                           joinType : JoinType
                           jtref : TableRef
                           onExpr : (Maybe JoinExpression)
              | SubTref sel : SelectExpression alias : String
              | TrefFun Expression
              | TrefFunAlias Expression String

DATA JoinExpression | JoinOn Expression | JoinUsing StringList

DATA JoinType | Inner | LeftOuter| RightOuter | FullOuter | Cross

-- select columns, into columns

DATA SelectList | SelectList SelectItemList StringList

DATA SelectItem | SelExp Expression
                | SelectItem Expression String

DATA CopySource | CopyFilename String | Stdin

--name type default null constraint

DATA AttributeDef | AttributeDef name : String
                                 typ : TypeName
                                 check : (Maybe Expression)
                                 cons : RowConstraintList

--Constraints which appear attached to an individual field

DATA RowConstraint | NullConstraint
                   | NotNullConstraint
                   | RowCheckConstraint Expression
                   | RowUniqueConstraint
                   | RowPrimaryKeyConstraint
                   | RowReferenceConstraint table : String
                                            att : (Maybe String)
                                            onUpdate : Cascade
                                            onDelete : Cascade

--constraints which appear on a separate row in the create table

DATA Constraint | UniqueConstraint StringList
                | PrimaryKeyConstraint StringList
                | CheckConstraint Expression
                  -- sourcecols targettable targetcols ondelete onupdate
                | ReferenceConstraint atts : StringList
                                      table : String
                                      tableAtts : StringList
                                      onUpdate : Cascade
                                      onDelete : Cascade

DATA TypeAttributeDef | TypeAttDef name : String
                                   typ : TypeName

DATA ParamDef | ParamDef String TypeName
              | ParamDefTp TypeName

DATA VarDef | VarDef name : String
                     typ : TypeName
                     value : (Maybe Expression)

DATA RaiseType | RNotice | RException | RError

DATA CombineType | Except | Union | Intersect | UnionAll

DATA Volatility | Volatile | Stable | Immutable

DATA Language | Sql | Plpgsql

DATA TypeName | SimpleTypeName tn:String
              | PrecTypeName tn:String prec:Integer
              | ArrayTypeName typ:TypeName
              | SetOfTypeName typ:TypeName

DATA DropType | Table
              | Domain
              | View
              | Type

DATA Cascade | Cascade | Restrict

DATA Direction | Asc | Desc

DATA Distinct | Distinct | Dupes

DATA Natural | Natural | Unnatural

DATA IfExists | Require | IfExists

DATA RestartIdentity | RestartIdentity | ContinueIdentity

{-
================================================================================

Expressions

Similarly to the statement type, all expressions
are chucked into one even though there are many restrictions
on which expressions can appear in different places.
Maybe this should be called scalar expression?
-}
DATA Expression | IntegerLit Integer
                | FloatLit Double
                | StringLit quote : String
                            value : String
                | NullLit
                | BooleanLit Bool
                | PositionalArg Integer
                | Cast expr:Expression tn:TypeName
                | Identifier String
                | Case cases : CaseExpressionListExpressionPairList
                       els : MaybeExpression
                | Exists sel : SelectExpression
                | FunCall funName:FunName args:ExpressionList
                | InPredicate Expression Bool InList
                  -- windowfn selectitem partitionby orderby orderbyasc?
                | WindowFn fn : Expression
                           partitionBy : ExpressionList
                           orderBy : ExpressionList
                           dir : Direction
                | ScalarSubQuery sel : SelectExpression

TYPE MaybeExpression = MAYBE Expression

{-

list of expression flavours from postgresql with this ast equivs
constant/literal               integerlit, floatlit, stringlit, nulllit, boollit
column reference               identifier
positional parameter reference   positionalarg
subscripted expression            fun arraysub
field selection expression        identifier
operator invocation               fun op
function call                     fun simple
aggregate expression              ?
window function call              windowfn
type cast                         cast
scalar subquery                   scalarsubquery
array constructor                 fun arrayval
row constructor                   fun rowctor

TODO: think about having separate parse tree which the parser produces,
and a proper set of ast types with no pollution from concrete syntax
or parsing considerations


Anything that is represented in the ast as some sort of name plus a
list of expressions as arguments is treated as the same type of node:
FunCall.

This includes
symbol operators
regular function calls
keyword operators e.g. and, like (ones which can be parsed as normal
  syntactic operators)
unusual syntax operators, e.g. between
unusual syntax function calls e.g. substring(x from 5 for 3)
arrayctors e.g. array[3,5,6]
rowctors e.g. ROW (2,4,6)
array subscripting

All of these could be considered concrete syntax variants of function
calls, which take none, one or more expressions as arguments, and
return a single expression as the result.

Divide them up into different flavours (corresponding to the FunName
algebraic data type constructors), which is guided by what the pretty
printer needs to work (maybe this is a bit inelegant):
all regular function calls like [name](args,...) are SimpleFuns
all regular operators (symbols, regular prefix,infix and postfix) are
  treated the same
arrayctors, rowctors, array subscript are each given their own ctor
all the standard keyword operators (prefix, infix and postfix) are
  given their own ctor
each unusual syntax keyword operator is given its own ctor
each unusual syntax function call is given its own ctor

keyword operators (regular prefix, infix and postfix):
and, or, not
is null, is not null, isnull, notnull
is distinct from, is not distinct from
is true, is not true,is false, is not false, is unknown, is not unknown
like, not like, ilike, not ilike
similar to, not similar to
in, not in (don't include these here since the argument isn't always an expr)

unusual syntax operators and fn calls
between, not between, between symmetric
overlay, substring, trim
any, some, all

-}


DATA FunName | SimpleFun String
             | Operator String
             | KOperator KeywordOperator
             | ArrayCtor
             | RowCtor
             | ArraySub
             | Substring
             | Between
               --add not between, overlay, any, etc.


DATA OperatorType | BinaryOp | PrefixOp | PostfixOp

{

-- for now, assume that all the overloaded operators that have the
-- same name are all either binary, prefix or postfix, otherwise the
-- getoperatortype would need the types of the arguments to determine
-- the operator type, and the parser would have to be a lot cleverer

getOperatorType :: String -> OperatorType
getOperatorType s = case () of
                      _ | any (\(x,_,_) -> x == s) binaryOperatorTypes ->
                            BinaryOp
                        | any (\(x,_,_) -> x == s ||
                                           (x=="-" && s=="u-"))
                              prefixOperatorTypes ->
                            PrefixOp
                        | any (\(x,_,_) -> x == s) postfixOperatorTypes ->
                            PostfixOp
                        | otherwise ->
                            error $ "don't know flavour of operator " ++ s
}


DATA InList | InList ExpressionList | InSelect sel : SelectExpression

-- some list nodes, not sure if all of these are needed as separately
-- named node types

TYPE ExpressionList = [Expression]
TYPE ExpressionListList = [ExpressionList]
TYPE StringList = [String]
TYPE SetClauseList = [SetClause]
TYPE AttributeDefList = [AttributeDef]
TYPE ConstraintList = [Constraint]
TYPE TypeAttributeDefList = [TypeAttributeDef]
TYPE ParamDefList = [ParamDef]
TYPE StringStringListPair = (String,StringList)
TYPE StringStringListPairList = [StringStringListPair]
TYPE ExpressionListStatementListPair = (ExpressionList,StatementList)
TYPE ExpressionListStatementListPairList = [ExpressionListStatementListPair]
TYPE ExpressionStatementListPair = (Expression, StatementList)
TYPE ExpressionStatementListPairList = [ExpressionStatementListPair]
TYPE VarDefList = [VarDef]
TYPE SelectItemList = [SelectItem]
TYPE RowConstraintList = [RowConstraint]
TYPE CaseExpressionListExpressionPair = (CaseExpressionList,Expression)
TYPE CaseExpressionList = [Expression]
TYPE CaseExpressionListExpressionPairList = [CaseExpressionListExpressionPair]

-- slightly hacky, add the source positions only in statement lists
-- this includes top level statements, and statements inside createfunction,
-- and nested inside if, while, case statements, and the like, but
-- unfortunately not select expressions inside other
-- expressions/statements

TYPE SourcePosStatement = (MySourcePos, Statement)
TYPE StatementList = [SourcePosStatement]


{-
================================================================================
Error reporting
-}

DATA Message | Error MySourcePos MessageStuff
             | Warning MySourcePos MessageStuff
             | Notice MySourcePos MessageStuff

DATA MessageStuff | ContinueNotInLoop
                  | CustomMessage String

DERIVING Message MessageStuff: Eq
DERIVING MessageStuff: Show
{

instance Show Message where
   show m = showMessage m

showMessage :: Message -> [Char]
showMessage m = case m of
                  Error sp s -> showit "Error" sp s
                  Warning sp s -> showit "Warning" sp s
                  Notice sp s -> showit "Notice" sp s
                where
                  showit lev (fn,l,c) s = lev ++ "\n" ++ fn ++ ":"
                                          ++ show l ++ ":" ++ show c ++ ":\n"
                                          ++ show s ++ "\n"
}

-- Add a root data type so we can put initial values for inherited
-- attributes in the section which defines and uses those attributes
-- rather than in the sem_ calls

DATA Root | Root statements:StatementList
DERIVING Root: Show

DATA ExpressionRoot | ExpressionRoot expr:Expression
DERIVING ExpressionRoot: Show

{-
================================================================================

=some basic bookkeeping

attributes which every node has
-}

SET AllNodes = Statement SelectExpression FnBody SetClause TableRef JoinExpression JoinType
               SelectList SelectItem CopySource AttributeDef RowConstraint
               Constraint TypeAttributeDef ParamDef VarDef RaiseType
               CombineType Volatility Language TypeName DropType Cascade
               Direction Distinct Natural IfExists RestartIdentity
               Expression InList MaybeExpression
               ExpressionList ExpressionListList StringList SetClauseList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList StringStringListPair StringStringListPairList
               StatementList ExpressionListStatementListPair
               ExpressionListStatementListPairList ExpressionStatementListPair
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList CaseExpressionListExpressionPair
               CaseExpressionListExpressionPairList CaseExpressionList
               SourcePosStatement FunName


SET NonListNodes = Statement SelectExpression FnBody SetClause TableRef JoinExpression JoinType
               SelectItem CopySource AttributeDef RowConstraint
               Constraint TypeAttributeDef ParamDef VarDef RaiseType
               CombineType Volatility Language TypeName DropType Cascade
               Direction Distinct Natural IfExists RestartIdentity
               Expression InList MaybeExpression
               StringStringListPair ExpressionListStatementListPair
               ExpressionStatementListPair
               CaseExpressionListExpressionPair
               SourcePosStatement FunName


SET ListNodes = SelectList ExpressionList ExpressionListList StringList
                SetClauseList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList StringStringListPairList
               StatementList
               ExpressionListStatementListPairList
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList
               CaseExpressionListExpressionPairList CaseExpressionList

DERIVING AllNodes: Show,Eq

SEM SourcePosStatement
    | Tuple x2.sourcePos = @x1


{-

================================================================================

attribute descriptions:

sourcePos - holds the source position used in messages, not very
accurate at the moment, just gives you the position of the first
character in the current statement

messages - used to collect error messages, also to be used for
warnings (e.g. $1 position argument used when all args have aliases),
and notices - will probably use these to highlight dodgy sql
code and idioms.


-}

ATTR AllNodes
  [ sourcePos: MySourcePos
  |
  |
  ]

ATTR AllNodes Root ExpressionRoot
  [
  |
  | messages USE {++} {[]} : {[Message]}
  ]

SEM Root
  | Root statements.sourcePos = ("",0,0)

SEM ExpressionRoot
  | ExpressionRoot expr.sourcePos = ("",0,0)


{-

================================================================================

= static tests

Problem 1: can't have two sem statements for the same node type which
both add messages, and then the messages get combined to provide the
final message list attribute value for that node. Workaround is
instead of having each check in it's own section, to combine them all
into one SEM.

Problem 2: no shorthand to combine what the default rule for messages
would be and then add a bit extra - so if you want all the children
messages, plus possiby an extra message or two, have to write out the
default rule in full explicitly. Can get round this by writing out
loads of code.

Both the workarounds to these seem a bit tedious and error prone, and
will make the code much less readable. Maybe need a preprocessor to
produce the ag file?

================================================================================

= inloop testing

inloop - use to check continue, exit, and other commands that can only
appear inside loops (for, while, loop)

-}

ATTR AllNodes
  [ inLoop: Bool
  |
  |
  ]

SEM Root
  | Root statements.inLoop = False

SEM ExpressionRoot
  | ExpressionRoot expr.inLoop = False

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

SEM Statement
     | ForSelectStatement ForIntegerStatement WhileStatement sts.inLoop = True
     | CreateFunction body.inLoop = False

-- now we can check when we hit a continue statement if it is in the
-- right context
SEM Statement
    | ContinueStatement  lhs.messages = if not @lhs.inLoop
                                          then [Error @lhs.sourcePos ContinueNotInLoop]
                                          else []

{-
================================================================================
Type checking

the current type checking approach doesn't quite match how SQL
works. What it will do when the first version is finished, is:
* possibly read the database catalogs
* then read the source script(s)
and statically check the types are consistent, as if the scripts are
declarative descriptions rather than a series of imperative
commands.

In particular, e.g. it won't be able to type check a create function
statement run from an invocation of another function.

One possible solution to this is to defer type checking and use the
database to load the script bit by bit whilst type checking as bits
are loaded.

Part of the syntax extension system design is to provide some
specialized methods for generating sql code in a way that can be type
checked statically without having to run the code.



we set all the node types to unknown to start with, this allows the
type checking to be implemented bit by bit. When the type checking is
complete, these might be removed or changed to something more useful.

-}

ATTR NonListNodes Root ExpressionRoot
  [
  |
  | nodeType USE {`setUnknown`} {UnknownType} : {Type}
  ]


ATTR ListNodes
  [
  |
  | nodeType USE {`appendTypeList`} {TypeList []} : {Type}
  ]

{
setUnknown :: Type -> Type -> Type
setUnknown _ _ = UnknownType

appendTypeList :: Type -> Type -> Type
appendTypeList t1 (TypeList ts) = TypeList (t1:ts)
appendTypeList t1 t2 = TypeList (t1:t2:[])
}

{
{-
================================================================================

= some type checking utils

== propagateunknownerror

shortcut which should end up being used in every bit of type checking
to make sure once we have an bad typed node, the type error propagates
up the node tree nicely, instead of creating a cascade of type
errors. Currently also used to propagate unknowntype in the same way.

if the first argument is unknown or type error, pass it on otherwise
use the second argument

-}
propagateUnknownError :: Type -> Type -> Type
propagateUnknownError t t1 =
    case t of
      a@(TypeError _ _) -> a
      UnknownType -> UnknownType
      TypeList l -> doTypeList l
      _ -> t1
    where
      -- run through the type list, if there are any eorors, collect
      -- them all into a list
      -- otherwise, if there are any unknowns, then the type is
      -- unknown
      -- otherwise, keep the list the same
      doTypeList ts =
          let unks = filter (\u -> case u of
                                     UnknownType -> True
                                     _ -> False) ts
              errs = filter (\u -> case u of
                                     TypeError _ _ -> True
                                     _ -> False) ts
          in case () of
               _ | length errs > 0 -> case () of
                                        _ | length errs == 1 -> head errs
                                          | otherwise -> TypeList errs
                 | length unks > 0 -> UnknownType
                 | otherwise -> t1

typesFromTypeList :: Type -> [Type]
typesFromTypeList (TypeList ts) = ts
typesFromTypeList x = error $ "can't get types from list " ++ show x

typeFromArray :: Type -> Type
typeFromArray (ArrayType t) = t
typeFromArray x = error $ "can't get types from non array " ++ show x

isArrayType :: Type -> Bool
isArrayType (ArrayType _) = True
isArrayType (Pseudo AnyArray) = True
isArrayType _ = False

}
---------------------------------------------

{-
================================================================================

= mini type checking dsl

create a little dsl to do declarative type checking for TypeList
types. We can pass in:
* the list of types,
* a declarative constraint on this list, and
* a method for determining the resultant type.

Nnot sure all these constraint variations will be needed. or if this
is going to last as the type checking is made more
comprehensive. Currently used for type checking keyword operators, and
in case expressions, maybe some other places.

-}

DATA ArgsCheck
    -- check any number of args, all have the same type
    | AllSameType Type
    -- check any one or more args, all have the same type
    | AllSameType1 Type
    -- check any one or more args, all have the same type as eachother
    | AllSameType1Any
    | AllSameTypeAny
    -- check all same type, exact number of args
    | AllSameTypeNum Type Int
    -- check all same type as each other, exact number of args
    | AllSameTypeNumAny Int
    -- check type list matches given list
    | ExactList TypeList
    -- check type list passes predicate list respectively
    | ExactPredList ArgCheckList
    -- check all types pass single predicate, exact number
    | AllSameTypePredNum ArgCheck Int

{
type TypeList = [Type]
type ArgCheckList = [ArgCheck]
}

DATA ArgCheck
    | ArgCheck TypePred TypePredError

{
type TypePred = (Type -> Bool)
type TypePredError = (Type -> TypeErrorInfo)

exactType :: Type -> ArgCheck
exactType t = ArgCheck (t==) (WrongType t)

checkPredList :: MySourcePos -> [ArgCheck] -> [Type] -> [Type]
checkPredList sp achks ats =
    if length achks /= length ats
      then [TypeError sp
            (WrongNumArgs
             (length achks)
             (length ats))]
      else checkArg 0 [] achks ats
    where
      checkArg :: Int -> [Type] -> [ArgCheck] -> [Type] -> [Type]
      checkArg n acc ((ArgCheck chk err):chks) (t:ts) =
          if chk t
            then checkArg (n+1) acc chks ts
            else checkArg (n+1) (acc ++ [TypeError sp $ err t]) chks ts
      checkArg _ acc [] [] = acc
      checkArg _ _ _ _ = error "internal error: pattern match failure in checkArg"
}

DATA RetType
    -- always returns fixed type
    | ConstRetType Type
    -- returns same type as argument n
    | RetTypeAsArgN Int
    -- use generic fn on arg list to produce return type
    | RetTypeFun RetTypeFunner

{
type RetTypeFunner = ([Type] -> Type)

-- the actual dsl engine:

checkTypes :: MySourcePos -> Type -> ArgsCheck -> RetType -> Type
checkTypes sp tl@(TypeList l) argC retT =
    --1: check tl for errors or unknowns
    --2: check the args against the constraints,
    --  filter this for unknown or errors
    --  (it returns Just error, or Nothing if ok)
    --3: get the return type, and check that for unknowns or errors
    --4: success, return the result type
    --todo: where can implicit casts be used in this type checking?
    let c = case checkArgs of
              Just t -> t
              Nothing -> getRetType
    in pe tl $ pe c c
    where
      getRetType =
          case retT of
            ConstRetType t -> t
            RetTypeAsArgN n -> l !! n
            RetTypeFun f -> f l
      checkArgs =
          case argC of
            AllSameType t -> checkArgListMatches t l
            AllSameType1 t | length l == 0 ->
                                Just $ te NeedOneOrMoreArgs
                           | otherwise -> checkArgListMatches t l
            AllSameTypeNum t n | length l /= n ->
                                    Just $ te $ WrongNumArgs n (length l)
                               | otherwise -> checkArgListMatches t l
            AllSameTypeNumAny n | length l /= n ->
                                    Just $ te $ WrongNumArgs n (length l)
                                | otherwise -> checkArgListMatches (head l) l
            AllSameTypeAny -> checkArgListMatches (head l) l
            AllSameType1Any | length l == 0 ->
                                Just $ te NeedOneOrMoreArgs
                            | otherwise -> checkArgListMatches (head l) l
            ExactList ts | ts == l -> Nothing
                         | canImplicitCast l ts -> Nothing
                         | otherwise ->
                              Just $ te $ WrongTypeList ts l
            ExactPredList chks -> case checkPredList sp chks l of
                                    x | length x == 0 -> Nothing
                                      | otherwise -> Just $ TypeList x
            AllSameTypePredNum p n -> case checkPredList sp
                                             (replicate n p)
                                             l of
                                        x | length x == 0 -> Nothing
                                          | otherwise -> Just $ TypeList x
      checkArgListMatches tc tcs = if all (==tc) tcs
                                   then Nothing
                                   else Just $ te (WrongTypes tc tcs)
      te = TypeError sp
      pe = propagateUnknownError
      canImplicitCast (f:fs) (t:ts) =
          {-trace (show (f:fs) ++ show (t:ts)) $-}
          (f == t || implicitlyCastableFromTo f t) && canImplicitCast fs ts
      canImplicitCast [] [] = True
      canImplicitCast _ _ = False


checkTypes _ x _ _ = error $ "can't check types of non type list: " ++ show x

}


--bit hacky, used to work with maybe bits in attribute grammar code
SEM MaybeExpression
    | Just lhs.nodeType = @just.nodeType
    | Nothing lhs.nodeType = Pseudo AnyElement

{-
================================================================================

= type table
this holds the available types

random notes on pg types:

== domains:
the point of domains is you can't put constraints on types, but you
can wrap a type up in a domain and put a constraint on it there

== literals/selectors

source strings are parsed as unknown type: they can be implicitly cast
to almost any type in the right contexts.

rows ctors can also be implicitly cast to any composite type matching
the elements (how exactly are they matched?)

string literals are not checked for valid syntax currently, but this
will probably change so we can type check string literals statically,
whereas pg defers all checking to runtime, because it has to cope with
custom data types. this code isn't going to be able to support custom
data types very well, so it can get away with doing more static checks
on this sort of thing.

== notes on type checking types

=== basic type checking
at the moment - just check type exists in predetermined list of type
names
todo: option to read types from database catalog at time of type
checking
todo: collect type names from current source file to check against

Type aliases

Some types in postgresql have multiple names. I think this is
hardcoded in the pg parser. There are two canonicalize routines to work
with these aliases.

The first one is for the ast, these canonical names have been chosen
arbitrarily, but with some guidelines: where there is a choice, prefer
the sql standard name, where there are multiple sql standard names,
choose the most concise or common one.

The second one is for postgresql, and converts type names into the
name which appears in the pg_type catalog table.

ast canonical names:
numbers:
int2, int4/integer, int8 -> smallint, int, bigint
numeric, decimal -> numeric
float(1) to float(24), real -> float(24)
float, float(25) to float(53), double precision -> float
serial, serial4 -> int
bigserial, serial8 -> bigint
character varying(n), varchar(n)-> varchar(n)
character(n), char(n) -> char(n)

update: going to stick with the names given in pg_type as the
canonical names for now, add constants to protect other programs from
changes here.

data type definitions live in pgtypes.hs

TODO:

SimpleTypeName can match a composite or domain type, as well as a base
type

what about PrecTypeName? - need to fix the ast and parser (these are
called type modifiers in pg)

also, what can setof be applied to - don't know if it can apply to an
array or setof type

array types have to match an exact array type in the catalog, so we
can't create an arbitrary array of any type

-}

SEM TypeName
     | SimpleTypeName
          lhs.nodeType = let st = canonicalizeType $ ScalarType @tn
                         in checkTypeExists @lhs.sourcePos st
--     | PrecTypeName
--          lhs.nodeType = if @tn `elem` defaultTypes
--                           then ScalarType @tn
--                           else TypeError @lhs.sourcePos
--                                  (UnknownTypeError @tn)
     | ArrayTypeName
          lhs.nodeType = propagateUnknownError @typ.nodeType
                           $ checkTypeExists
                                 @lhs.sourcePos
                                 (ArrayType @typ.nodeType)
     | SetOfTypeName
          lhs.nodeType = propagateUnknownError @typ.nodeType
                           (SetOfType @typ.nodeType)

{
checkTypeExists :: MySourcePos -> Type -> Type
checkTypeExists sp t =
    if t `elem` defaultTypeNames
      then t
      else TypeError sp (UnknownTypeError t)
}


--first actual bit of type checking - a cast expression
-- todo: some sort of validation on whether the cast will work
-- it's not straight forward to work out exactly what explicit casts
-- pg allows...

SEM Expression
    | Cast lhs.nodeType = propagateUnknownError
                            (TypeList
                             [@expr.nodeType])
                            @tn.nodeType
{
--aliases to protect client code if/when the ast canonical names are
--changed
typeSmallInt,typeBigInt,typeInt,typeNumeric,typeFloat4,
  typeFloat8,typeVarChar,typeChar,typeBool :: Type
typeSmallInt = ScalarType "int2"
typeBigInt = ScalarType "int8"
typeInt = ScalarType "int4"
typeNumeric = ScalarType "numeric"
typeFloat4 = ScalarType "float4"
typeFloat8 = ScalarType "float8"
typeVarChar = ScalarType "varchar"
typeChar = ScalarType "char"
typeBool = ScalarType "bool"

canonicalizeType :: Type -> Type
canonicalizeType t =
    case t of
      ScalarType s -> cName s
      ArrayType a -> ArrayType $ canonicalizeType a
      SetOfType a -> SetOfType $ canonicalizeType a
      t1@_ -> t1
    where
      cName s = case () of
                  _ | s `elem` smallIntNames -> typeSmallInt
                    | s `elem` intNames -> typeInt
                    | s `elem` bigIntNames -> typeBigInt
                    | s `elem` numericNames -> typeNumeric
                    | s `elem` float4Names -> typeFloat4
                    | s `elem` float8Names -> typeFloat8
                    | s `elem` varcharNames -> typeVarChar
                    | s `elem` charNames -> typeChar
                    | s `elem` boolNames -> typeBool
                    | otherwise -> ScalarType s
      smallIntNames = ["int2", "smallint"]
      intNames = ["int4", "integer", "int"]
      bigIntNames = ["int8", "bigint"]
      numericNames = ["numeric", "decimal"]
      float4Names = ["real", "float4"]
      float8Names = ["double precision", "float"]
      varcharNames = ["character varying", "varchar"]
      charNames = ["character", "char"]
      boolNames = ["boolean", "bool"]


}

{-
= literals
-}

SEM Expression
     | IntegerLit lhs.nodeType = typeInt
     | StringLit lhs.nodeType = UnknownStringLit
     | FloatLit lhs.nodeType = typeNumeric
     | BooleanLit lhs.nodeType = typeBool
     -- I think a null types like an unknown string lit
     | NullLit lhs.nodeType = UnknownStringLit


{-

================================================================================

= function and operator tables
these hold the types of functions and operators for lookup and checking
they live in fntypes.hs
-}

{

allOpsAndFns :: [FunctionPrototype]
allOpsAndFns = binaryOperatorTypes
               ++ prefixOperatorTypes
               ++ postfixOperatorTypes
               ++ functionTypes

--add the keyword operators here

keywordBinaryOperatorTypes :: [(KeywordOperator,[Type],Type)]
keywordBinaryOperatorTypes = [
 (And, [typeBool, typeBool], typeBool),
 (Or, [typeBool, typeBool], typeBool),
 (Like, [ScalarType "text", ScalarType "text"], typeBool)]
keywordUnaryOperatorTypes :: [(KeywordOperator,[Type],Type)]
keywordUnaryOperatorTypes = [
 (Not, [typeBool], typeBool),
 (IsNull, [Pseudo Any], typeBool),
 (IsNotNull, [Pseudo Any], typeBool)]

allKeywordOps :: [(KeywordOperator, [Type], Type)]
allKeywordOps = keywordBinaryOperatorTypes ++ keywordUnaryOperatorTypes


-- this utility fn is used to check that the operator and function
-- prototypes only contain types listed in the defaultTypeNames list

checkFunctionTypes :: [(String, [Type])]
checkFunctionTypes =
    catMaybes $ map (\(f,a,r) ->
                     let ts = (r:a)
                         badts = filter (not . knownType) ts
                     in if length badts == 0
                          then Nothing
                          else Just (f, badts)
                    ) allOpsAndFns
    where
      knownType :: Type -> Bool
      knownType l = case l of
                      Pseudo _ -> True
                      t@(ScalarType _) -> t `elem` defaultTypeNames
                      ArrayType t -> knownType t
                      SetOfType t -> knownType t
                      _ -> error "internal error: unknown type in function proto"

}

{-

todo:
polymorphic functions
row ctor implicitly and explicitly cast to a composite type
cast empty array

== simple operators

type check keyword operators, standard operators (prefix, postfix,
binary), and function calls

-}

ATTR FunName
  [
  |
  | val : SELF
  ]

SEM Expression
    | FunCall lhs.nodeType =
        case @funName.val of
          ArrayCtor -> let t = resolveResultSetType @lhs.sourcePos $ typesFromTypeList @args.nodeType
                       in propagateUnknownError t $ ArrayType t
          Substring -> ct
                         (ExactList [ScalarType "text"
                                    ,ScalarType "int4"
                                    ,ScalarType "int4"])
                         (ConstRetType (ScalarType "text"))
          Between -> ct -- needs to be fixed to type check against <= and =>
                         (AllSameTypeNumAny 3)
                         (ConstRetType (typeBool))
          ArraySub -> ct
                         (ExactPredList
                           [ArgCheck isArrayType NotArrayType
                           ,exactType (ScalarType "int4")])
                         (RetTypeFun (\t -> typeFromArray $ head t))
          Operator s -> lookupFn s (typesFromTypeList @args.nodeType)
          KOperator k -> lookupKop k (typesFromTypeList @args.nodeType)
          SimpleFun f -> lookupFn f (typesFromTypeList @args.nodeType)
          _ -> UnknownType
        where
          ct = checkTypes @lhs.sourcePos @args.nodeType
          lookupFn s1 args = case findCallMatch @lhs.sourcePos
                                             (if s1 == "u-" then "-" else s1) args of
                               Left te -> te
                               Right (_,_,r) -> r
          lookupKop s args = let cands = filter (\(o,a,_) ->
                                                   (o,a) == (s,args))
                                           allKeywordOps
                             in case () of
                                 _ | length cands == 0 -> TypeError @lhs.sourcePos (NoMatchingKOperator s args)
                                   | length cands == 1 -> let (_,_,rettype) = (head cands)
                                                          in rettype
                                   | otherwise -> TypeError @lhs.sourcePos (MultipleMatchingKOperators s args)
{
{-

findCallMatch - partially implements the type conversion rules for
finding an operator or function match given a name and list of
arguments with partial or fully specified types

TODO:
namespaces
function style casts not in catalog
variadic args
default args
domains -> base type

Algo:

cands = all fns with matching names
        and same number of args

if exact match on types in this list, use it
  (if binary operator being matched, and one arg is typed and one is
  unknown, also match an operator by assuming the unknown is the same
  as the typed arg)

best match part:

filter cands with args which don't exactly match input args, and input
args cannot be converted by an implicit cast. unknowns count as
matching anything
if one left: use it

filter for preferred types:

for each cand, count each arg at each position which needs conversion,
and the cand type is a preferred type at that position.
if there are cands with count>0, keep only cands with the max count,
if one return it
if there are no cands with count>0, keep them all

check unknowns:
if any input args are unknown, and any cand accepts string at that
position, fix that arg's category as string, otherwise if all cands
accept same category at that position, fix that input args as that
category.
if we still have unknowns, then fail

discard cands which don't match the new input arg/category list

for each categorised input arg, if any cand accepts preferred type at
that position, get rid of cands which don't accept preferred type at
that position

if one left: use
else fail


findCallMatch is a bit of a mess

-}

type FunctionPrototype = (String,[Type],Type)
type ProtArgCast = (FunctionPrototype, [ArgCastFlavour])

findCallMatch :: MySourcePos -> String -> [Type] ->  Either Type FunctionPrototype
findCallMatch sp f inArgs =
    case () of
         _ | length exactMatch == 1 -> Right $ getHeadFn exactMatch
           | length binOp1UnknownMatch == 1 -> Right $ getHeadFn binOp1UnknownMatch
           | length reachable == 1 -> Right $ getHeadFn reachable
           | length filteredForPreferred == 1 -> Right $ getHeadFn filteredForPreferred
           | length unknownMatchesByCat == 1 ->  Right $ getHeadFn unknownMatchesByCat
           | otherwise -> {-trace ("exact matches " ++ show exactMatch) $
                          trace ("\nreachable " ++ show reachable) $
                          trace ("\nfilteredforpreferred " ++ show filteredForPreferred) $
                          trace ("\nargCats " ++ show argCats) $
                          trace ("\nunknownMatchesByCat " ++ show unknownMatchesByCat) -}
                          Left $ TypeError sp (NoMatchingOperator f inArgs)
    where
      -- basic lists which roughly mirror algo
      -- get the possibly matching candidates
      icl = initialCandList

      -- record what casts are needed for each candidate
      castPairs :: [[ArgCastFlavour]]
      castPairs = map listCastPairs $ map getFnArgs icl

      candCastPairs :: [ProtArgCast]
      candCastPairs = zip icl castPairs

      -- see if we have an exact match
      exactMatch :: [ProtArgCast]
      exactMatch = getExactMatch candCastPairs

      -- implement the one known, one unknown resolution for binary operators
      binOp1UnknownMatch :: [ProtArgCast]
      binOp1UnknownMatch = getBinOp1UnknownMatch candCastPairs

      -- eliminate candidates for which the inargs cannot be casted to
      reachable :: [ProtArgCast]
      reachable = filterCandCastPairs (none (==CannotCast)) candCastPairs

      -- keep the cands with the most casts to preferred types
      preferredTypesCounts = countPreferredTypeCasts reachable
      keepCounts = maximum preferredTypesCounts
      itemCountPairs :: [(ProtArgCast,Int)]
      itemCountPairs = zip reachable preferredTypesCounts
      filteredForPreferred :: [ProtArgCast]
      filteredForPreferred = map fst $ filter (\(_,i) -> i == keepCounts) itemCountPairs

      -- collect the inArg type categories to do unknown inArg resolution
      argCats :: [Either () String]
      argCats = getCastCategoriesForUnknowns filteredForPreferred
      unknownMatchesByCat :: [ProtArgCast]
      unknownMatchesByCat = getCandCatMatches filteredForPreferred argCats

      -------------
      initialCandList :: [FunctionPrototype]
      initialCandList = filter (\(candf,candArgs,_) ->
                                  (candf,length candArgs) == (f,length inArgs))
                          allOpsAndFns

      listCastPairs :: [Type] -> [ArgCastFlavour]
      listCastPairs l = listCastPairs' inArgs l
                        where
                          listCastPairs' :: [Type] -> [Type] -> [ArgCastFlavour]
                          listCastPairs' (ia:ias) (ca:cas) =
                              (case () of
                                 _ | ia == ca -> ExactMatch
                                   | implicitlyCastableFromTo ia ca ->
                                       case isPreferredType ca of
                                         True -> ImplicitToPreferred
                                         False -> ImplicitToNonPreferred
                                   | otherwise -> CannotCast
                              ) : listCastPairs' ias cas
                          listCastPairs' [] [] = []
                          listCastPairs' _ _ = error "internal error: mismatched num args in implicit cast algorithm"

      getExactMatch :: [ProtArgCast] -> [ProtArgCast]
      getExactMatch ccp  = filterCandCastPairs (all (==ExactMatch)) ccp

      getBinOp1UnknownMatch :: [ProtArgCast] -> [ProtArgCast]
      getBinOp1UnknownMatch cands =
          if not (isOperator f &&
                  length inArgs == 2 &&
                  (count (==UnknownStringLit) inArgs) == 1)
            then []
            else let newInArgs =
                         take 2 $ repeat (if head inArgs == UnknownStringLit
                                            then inArgs !! 1
                                            else head inArgs)
                 in filter (\((_,a,_),_) -> a == newInArgs) cands

      countPreferredTypeCasts :: [ProtArgCast] -> [Int]
      countPreferredTypeCasts l =
          map (\(_,cp) -> count (==ImplicitToPreferred) cp) l

      -- Left () is used for inArgs which aren't unknown,
      --                      and for unknowns which we don't have a
      --                      unique category
      -- Right s -> s is the single letter category at
      --                           that position
      getCastCategoriesForUnknowns :: [ProtArgCast] -> [Either () String]
      getCastCategoriesForUnknowns cands =
          filterArgN 0
          where
            candArgLists :: [[Type]]
            candArgLists = map (\((_,a,_), _) -> a) cands
            filterArgN :: Int -> [Either () String]
            filterArgN n =
                if n == length inArgs
                  then []
                  else let targType = inArgs !! n
                       in ((if targType /= UnknownStringLit
                              then Left ()
                              else getCandsCatAt n) : filterArgN (n+1))
                where
                  getCandsCatAt :: Int -> Either () String
                  getCandsCatAt n' =
                      let typesAtN = map (!!n') candArgLists
                          catsAtN = map getTypeCategory typesAtN
                      in case () of
                           --if any are string choose string
                           _ | any (== "S") catsAtN -> Right "S"
                             -- if all are same cat choose that
                             | all (== head catsAtN) catsAtN -> Right $ head catsAtN
                             -- otherwise no match, this will be
                             -- picked up as complete failure to match
                             -- later on
                             | otherwise -> Left ()

      getCandCatMatches :: [ProtArgCast] -> [Either () String] -> [ProtArgCast]
      getCandCatMatches candsA cats = getMatches candsA 0
         where
           getMatches :: [ProtArgCast] -> Int -> [ProtArgCast]
           getMatches cands n =
               case () of
                 _ | n == length inArgs -> cands
                   | (inArgs !! n) /= UnknownStringLit -> getMatches cands (n + 1)
                   | otherwise ->
                       let catMatches :: [ProtArgCast]
                           catMatches = filter (\c -> Right (getCatForArgN n c) ==
                                                     (cats !! n)) cands
                           prefMatches :: [ProtArgCast]
                           prefMatches = filter (\c -> isPreferredType
                                                       (getTypeForArgN n c)) catMatches
                           keepMatches :: [ProtArgCast]
                           keepMatches = if length prefMatches > 0
                                           then prefMatches
                                           else catMatches
                       in getMatches keepMatches (n + 1)
           getTypeForArgN :: Int -> ProtArgCast -> Type
           getTypeForArgN n ((_,a,_),_) = a !! n
           getCatForArgN :: Int -> ProtArgCast -> String
           getCatForArgN n c = getTypeCategory (getTypeForArgN n c)

      -- utils
      -- filter a candidate/cast flavours pair by a predicate on each
      -- individual cast flavour
      filterCandCastPairs :: ([ArgCastFlavour] -> Bool)
                          -> [ProtArgCast]
                          -> [ProtArgCast]
      filterCandCastPairs predi ccp = filter (\(_,cp) -> predi cp) ccp

      getFnArgs :: FunctionPrototype -> [Type]
      getFnArgs (_,a,_) = a

      getHeadFn :: [ProtArgCast] -> FunctionPrototype
      getHeadFn l =  let ((hdFn, _):_) = l
                     in hdFn

      none p l = not (any p l)
      count p l = length $ filter p l

data ArgCastFlavour = ExactMatch
                    | CannotCast
                    | ImplicitToPreferred
                    | ImplicitToNonPreferred
                      deriving (Eq,Show)

isOperator :: String -> Bool
isOperator s = any (`elem` "+-*/<>=~!@#%^&|`?") s

isPreferredType :: Type -> Bool
isPreferredType t = case find (\(t1,_,_)-> t1==t) typeCategories of
                      Nothing -> error $ "internal error, couldn't find type category information: " ++ show t
                      Just (_,_,p) -> p

getTypeCategory :: Type -> String
getTypeCategory t = case find (\(t1,_,_)-> t1==t) typeCategories of
                      Nothing -> error $ "internal error, couldn't find type category information: " ++ show t
                      Just (_,c,_) -> c


implicitlyCastableFromTo :: Type -> Type -> Bool
implicitlyCastableFromTo from to = from == UnknownStringLit ||
                                     any (==(from,to,ImplicitCastContext)) castTable

{-

resolveResultSetType -
partially implement the typing of results sets where the types aren't
all the same and not unknown
used in union,except,intersect columns, case, array ctor, values, greatest and least

algo:
if all inputs are same and not unknown -> that type
replace domains with base types
if all inputs are unknown then text
if the non unknown types aren't all in same category then fail
choose first input type that is a preferred type if there is one
choose last non unknown type that has implicit casts from all preceding inputs
check all can convert to selected type else fail

code is not as much of a mess as findCallMatch

-}

resolveResultSetType :: MySourcePos -> [Type] -> Type
resolveResultSetType sp inArgs = propagateUnknownError (TypeList inArgs) $
    case () of
      _ | length inArgs == 0 -> TypeError sp TypelessEmptyArray
        | allSameType -> head inArgs
        --todo: do domains
        | allUnknown -> ScalarType "text"
        | not allSameCat -> TypeError sp (IncompatibleTypes inArgs)
        | isJust targetType &&
          allConvertibleToFrom
            (fromJust targetType)
            inArgs -> fromJust targetType
        | otherwise -> TypeError sp (IncompatibleTypes inArgs)
   where
     allSameType = all (== head inArgs) inArgs && head inArgs /= UnknownStringLit
     allUnknown = all (==UnknownStringLit) inArgs
     allSameCat = let firstCat = getTypeCategory (head knownTypes)
                  in all (\t -> getTypeCategory t == firstCat) knownTypes
     targetType = case catMaybes [firstPreferred, lastAllConvertibleTo] of
                    [] -> Nothing
                    (x:_) -> Just x
     firstPreferred = find isPreferredType knownTypes
     lastAllConvertibleTo = firstAllConvertibleTo (reverse knownTypes)
     firstAllConvertibleTo (x:xs) = if allConvertibleToFrom x xs
                                      then Just x
                                      else firstAllConvertibleTo xs
     firstAllConvertibleTo [] = Nothing
     matchOrImplicitToFrom t t1 = t == t1 || implicitlyCastableFromTo t1 t
     knownTypes = filter (/=UnknownStringLit) inArgs
     allConvertibleToFrom t ts = all (matchOrImplicitToFrom t) ts
}

{-
== case expression

check the when expressions are boolean inside the pairs, then collect
the then types to pass to resolveResultSetType

-}

SEM CaseExpressionListExpressionPair
    | Tuple lhs.nodeType = checkTypes
                             @lhs.sourcePos
                             @x1.nodeType
                             (AllSameType $ typeBool)
                             (ConstRetType @x2.nodeType)

SEM Expression
    | Case lhs.nodeType =
             resolveResultSetType
               @lhs.sourcePos
               (typesFromTypeList (case @els.nodeType of
                                     Pseudo AnyElement -> @cases.nodeType
                                     e -> TypeList
                                          ((typesFromTypeList @cases.nodeType)
                                           ++ [e])))

{-
================================================================================

= basic select statements

-}

SEM Statement
    | SelectStatement lhs.nodeType = @ex.nodeType


SEM SelectExpression
    --assume we get TypeList (TypeList (Type)) out of vll
    | Values lhs.nodeType =
        let rowsTs1 = (typesFromTypeList @vll.nodeType)
            --convert into [[Type]]
            rowsTs = map typesFromTypeList rowsTs1
            --check all same length
            lengths = map length rowsTs
            error1 = case () of
                      _ | length rowsTs1 == 0 ->
                            Just $ TypeError @lhs.sourcePos NoRowsGivenForValues
                        | not (all (==head lengths) lengths) ->
                            Just $ TypeError @lhs.sourcePos
                                 ValuesListsMustBeSameLength
                        | otherwise -> Nothing
            colNames = map (\(a,b) -> a ++ b) $
                       zip (repeat "column")
                           (map show [1..head lengths])
            colTypeLists = transpose rowsTs
            colTypes = map (resolveResultSetType @lhs.sourcePos) colTypeLists
            error2 = let es = filter (\t -> case t of
                                              TypeError _ _ -> True
                                              _ -> False) colTypes
                     in case length es of
                          0 -> Nothing
                          1 -> Just $ head es
                          _ ->  Just $ TypeList es
            ty = UnnamedCompositeType $ zip colNames colTypes
        in head $ catMaybes [error1, error2, Just $ SetOfType ty]

{-

End of type checking

================================================================================

used to use record syntax to try to insulate code from field changes,
and not have to write out loads of nothings and [] for simple selects,
but don't know how to create haskell named records from uuagc DATA
things

makeSelect :: Statement
makeSelect = Select Dupes (SelectList [SelExp (Identifier "*")] [])
                   Nothing Nothing [] Nothing [] Asc Nothing Nothing


================================================================================

= checkAst

test function to run on asts, returns a list of errors, warnings, etc.

-}
{
checkAst :: StatementList -> [Message]
checkAst sts = let t = sem_Root (Root sts)
               in (messages_Syn_Root (wrap_Root t Inh_Root))
{-
================================================================================

= Types

-}

getExpressionType :: Expression -> Type
getExpressionType ex = let t = sem_ExpressionRoot (ExpressionRoot ex)
                       in (nodeType_Syn_ExpressionRoot
                           (wrap_ExpressionRoot t Inh_ExpressionRoot))


getStatementsType :: StatementList -> [Type]
getStatementsType st = let t = sem_Root (Root st)
                           tl = (nodeType_Syn_Root
                                 (wrap_Root t Inh_Root))
                       in typesFromTypeList tl


--hack job, often not interested in the source positions when testing
--the asts produced, so this function will reset all the source
--positions to empty ("", 0, 0)

resetSps :: [Statement] -> [Statement]
resetSps sts = map resetSp sts

resetSp :: Statement -> Statement
resetSp (CreateFunction l n p r bq b v) = (CreateFunction l n p r bq
                                              (case b of
                                                SqlFnBody stss -> SqlFnBody (map resetSp' stss)
                                                PlpgsqlFnBody vd stss -> PlpgsqlFnBody vd (map resetSp' stss))
                                            v)
resetSp (ForSelectStatement v s stss) = ForSelectStatement v s (map resetSp' stss)
resetSp (ForIntegerStatement v f t stss) = ForIntegerStatement v f t (map resetSp' stss)
resetSp (CaseStatement v cs els) = CaseStatement v (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp (If cs els) = If (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp a = a

resetSp' :: SourcePosStatement -> SourcePosStatement
resetSp' (_,st) = (nsp,resetSp st)

resetSps' :: StatementList -> StatementList
resetSps' sts = map resetSp' sts

nsp :: MySourcePos
nsp = ("", 0,0)
}

{-

containment guide for select expressions:
combineselect 2 selects
insert ?select
createtableas 1 select
createview 1 select
return query 1 select
forselect 1 select
select->subselect select
expression->exists select
            scalarsubquery select
            inselect select

containment guide for statements:
forselect [statement]
forinteger [statement]
while [statement]
casestatement [[statement]]
if [[statement]]
createfunction->fnbody [Statement]

TODO

some non type-check checks:
check plpgsql only in plpgsql function
orderby in top level select only
copy followed immediately by copydata iff stdin, copydata only follows
  copy from stdin
count args to raise, etc., check same number as placeholders in string
natural with correct join types
no natural with onexpr in joins
constraint column ref checks?
typename -> setof (& fix parsing), what else like this?
expressions: positionalarg in function, window function only in select
 list top level

review all ast checks, and see if we can also catch them during
parsing (e.g. typeName parses setof, but this should only be allowed
for a function return, and we can make this a parse error when parsing
from source code rather than checking a generated ast. This needs
judgement to say whether a parse error is better than a check error, I
think for setof it is, but e.g. for a continue not in a loop (which
could be caught during parsing) works better as a check error, looking
at the error message the user will get. This might be wrong, haven't
thought too carefully about it yet).

Type checking

Start with tables, and then simple select * from table, select a,b from table.
Then maybe do some simple expressions.

Add separate function to return the inferred types of statementlists/
expressions, etc., so the checkAst checks the types are consistent,
and them have something like getStatementType, getStatementsType,
getExpressionType (which works for selects and relation valued
expressions as well as scalars, tuples, etc).


TODO: canonicalize ast process, as part of type checking produces a canonicalized ast which:
all implicit casts appear explicitly in the ast (maybe distinguished from explicit casts?)
all names fully qualified
all types use canonical names
literal values and selectors in one form (use row style?)
nodes are tagged with types
what else?

Canonical form only defined for type consistent asts.

This canonical form should pretty print and parse back to the same
form, and type check correctly.

-}
