{-
Copyright 2009 Jake Wheat

This file contains the ast nodes, which aren't brilliantly designed,
and the attribute grammar system which uses the Utrecht University
Attribute Grammar system:

http://www.cs.uu.nl/wiki/bin/view/HUT/AttributeGrammarSystem
http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter

There are no source positions in the ast at the moment. The grammar
system is intended to act a as type checker, and to do other static
checks for the time being, which is a work in progress and in a very
early state.

These ast nodes a are both used as the result of successful parsing,
and as the input to the pretty printer.

Lots of invalid sql is currently allowed if you construct the asts in
code, the parser isn't quite as lenient, but still can parse and not
complain about a lot of invalid sql.

use

uuagc -dcfws Ast.ag

to generate a new Ast.hs from this file

(install uuagc with
cabal install uuagc
)

Tip: after you've compiled this file with the above command, you can
get loads of warnings from ghc if you're the sort who enables
these. Using haskell-mode from emacs usually results in compiles being
really slow just cos emacs outputs all these warnings _really_ slowly,
and also any real warnings and errors can get drowned out. You can get
rid of these warnings by ghc compiling the produced Ast.hs on the
command line:
ghc -c Ast.hs

does the job, you can then compile from emacs and it will use the .o
file and you won't get any warnings about generated code in Ast.hs (if
the .o file gets stale, ghc / haskell mode will do the right thing and
ignore it, but it can't tell if the Ast.hs has gotten stale wrt
Ast.ag)
-}

MODULE {Ast}
{} -- exports
{} -- imports

{-
================================================================================

SQL top level statements

everything is chucked in here, in particular this means that many places where
a select can appear inside another statement (e.g. a subselect), you can
instead put any statement - this type checks but is totally invalid.

> -- | Statement represents a single sql or plpgsql statement.

-}

TYPE MySourcePos = (String, Int, Int)

DATA Statement

--queries

    | Select selDistinct : Distinct
             selSelectList : SelectList
             selTref : (Maybe TableRef)
             selWhere : (Maybe Expression)
             selGroupBy : ExpressionList
             selHaving : (Maybe Expression)
             selOrderBy : ExpressionList
             selDir : Direction
             selLimit : (Maybe Expression)
             selOffset : (Maybe Expression)
    | CombineSelect ctype : CombineType
                    sel1 : Statement
                    sel2 : Statement
    | Values ExpressionListList

-- dml

    --table targetcolumns insertdata(values or select statement) returning
    | Insert table : String
             targetCols : StringList
             insData : Statement
             returning : (Maybe SelectList)
    --tablename setitems where returning
    | Update table : String
             assigns : SetClauseList
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename, where, returning
    | Delete table : String
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename column names, from
    | Copy table : String
           targetCols : StringList
           source : CopySource
    --represents inline data for copy statement
    | CopyData insData : String
    | Truncate tables: StringList
               restartIdentity : RestartIdentity
               cascade : Cascade

-- ddl

    | CreateTable name : String
                  atts : AttributeDefList
                  cons : ConstraintList
    | CreateTableAs name : String
                    expr : Statement
    | CreateView name : String
                 expr : Statement
    | CreateType name : String
                 atts : TypeAttributeDefList
    -- language name args rettype bodyquoteused body vol
    | CreateFunction lang : Language
                     name : String
                     params : ParamDefList
                     rettype : TypeName
                     bodyQuote : String
                     body : FnBody
                     vol : Volatility
    -- name type checkexpression
    | CreateDomain name : String
                   typ : TypeName
                   check : (Maybe Expression)
    -- ifexists (name,argtypes)* cascadeorrestrict
    | DropFunction ifE : IfExists
                   sigs : StringStringListPairList
                   cascade : Cascade
    -- ifexists names cascadeorrestrict
    | DropSomething dropType : DropType
                    ifE : IfExists
                    names : StringList
                    cascade : Cascade
    | Assignment target : String
                 value : Expression
    | Return value : (Maybe Expression)
    | ReturnNext expr : Expression
    | ReturnQuery sel : Statement
    | Raise level : RaiseType
            message : String
            args : ExpressionList
    | NullStatement
    | Perform expr : Expression
    | Execute expr : Expression
    | ExecuteInto expr : Expression
                  targets : StringList
    | ForSelectStatement var : String
                         sel : Statement
                         sts : StatementList
    | ForIntegerStatement var : String
                          from : Expression
                          to : Expression
                          sts : StatementList
    | WhileStatement expr : Expression
                     sts : StatementList
    | ContinueStatement
    --variable, list of when parts, else part
    | CaseStatement val : Expression
                    cases : ExpressionListStatementListPairList
                    els : StatementList
    --list is
    --first if (condition, statements):elseifs(condition, statements)
    --last bit is else statements
    | If cases : ExpressionStatementListPairList
         els : StatementList

-- =============================================================================

--Statement components

DATA FnBody | SqlFnBody sts : StatementList
            | PlpgsqlFnBody VarDefList sts : StatementList

DATA SetClause | SetClause String Expression | RowSetClause StringList ExpressionList

DATA TableRef | Tref String
              | TrefAlias tref : String
                          alias : String
              | JoinedTref tref : TableRef
                           nat : Natural
                           joinType : JoinType
                           jtref : TableRef
                           onExpr : (Maybe JoinExpression)
              | SubTref sel : Statement alias : String
              | TrefFun Expression
              | TrefFunAlias Expression String

DATA JoinExpression | JoinOn Expression | JoinUsing StringList

DATA JoinType | Inner | LeftOuter| RightOuter | FullOuter | Cross

-- select columns, into columns

DATA SelectList | SelectList SelectItemList StringList

DATA SelectItem | SelExp Expression
                | SelectItem Expression String

DATA CopySource | CopyFilename String | Stdin

--name type default null constraint

DATA AttributeDef | AttributeDef name : String
                                 typ : TypeName
                                 check : (Maybe Expression)
                                 cons : RowConstraintList

--Constraints which appear attached to an individual field

DATA RowConstraint | NullConstraint
                   | NotNullConstraint
                   | RowCheckConstraint Expression
                   | RowUniqueConstraint
                   | RowPrimaryKeyConstraint
                   | RowReferenceConstraint table : String
                                            att : (Maybe String)
                                            onUpdate : Cascade
                                            onDelete : Cascade

--constraints which appear on a separate row in the create table

DATA Constraint | UniqueConstraint StringList
                | PrimaryKeyConstraint StringList
                | CheckConstraint Expression
                  -- sourcecols targettable targetcols ondelete onupdate
                | ReferenceConstraint atts : StringList
                                      table : String
                                      tableAtts : StringList
                                      onUpdate : Cascade
                                      onDelete : Cascade

DATA TypeAttributeDef | TypeAttDef name : String
                                   typ : TypeName

DATA ParamDef | ParamDef String TypeName
              | ParamDefTp TypeName

DATA VarDef | VarDef name : String
                     typ : TypeName
                     value : (Maybe Expression)

DATA RaiseType | RNotice | RException | RError

DATA CombineType | Except | Union | Intersect | UnionAll

DATA Volatility | Volatile | Stable | Immutable

DATA Language | Sql | Plpgsql

DATA TypeName | SimpleType String
              | PrecType String Integer
              | ArrayType TypeName
              | SetOfType TypeName

DATA DropType | Table
         | Domain
         | View
         | Type

DATA Cascade | Cascade | Restrict

DATA Direction | Asc | Desc

DATA Distinct | Distinct | Dupes

DATA Natural | Natural | Unnatural

DATA IfExists | Require | IfExists

DATA RestartIdentity | RestartIdentity | ContinueIdentity

{-
================================================================================

Expressions

Will probably change the symbol operators to accept a string of the
symbol to support general pg operators, including user defined
ones. Then the number of special cases will probably be smaller than
the current two lists.

-}

DATA BinOp
    | Plus | Minus | Mult | Div | Pow | Mod | Eql
    | And | Or | Conc | Like
    | Cast | NotEql | Lt | Gt | Lte | Gte
    | DistBetween


DATA UnOp | Not | IsNull | IsNotNull | SetOf | Abs | Neg

{

binOpToSymbol :: BinOp -> String
binOpToSymbol op = case op of
                        Plus -> "+"
                        Minus -> "-"
                        Mult -> "*"
                        Div -> "/"
                        Pow -> "^"
                        Mod -> "%"
                        Eql -> "="
                        And -> "and"
                        Or -> "or"
                        Conc -> "||"
                        Like -> "like"
                        Cast -> "::"
                        NotEql -> "<>"
                        Lt -> "<"
                        Gt -> ">"
                        Lte -> "<="
                        Gte -> ">="
                        DistBetween -> "<->"

unOpToSymbol :: UnOp -> String
unOpToSymbol op = case op of
                         Not -> "not"
                         IsNull -> "is null"
                         IsNotNull -> "is not null"
                         --SetOf -> "setof"
                         Abs -> "@"
                         Neg -> "-"

}

{-
Similarly to the statement type, all expressions
are chucked into one even though there are many restrictions
on which expressions can appear in different places.
-}
DATA Expression | IntegerLit Integer
                | FloatLit Double
                | StringLit quote : String
                            value : String
                | NullLit
                | BooleanLit Bool
                | PositionalArg Integer
                | CastKeyword Expression TypeName
                  -- sourcestring start length
                | Substring str : Expression
                            from : Expression
                            for : Expression
                | Identifier String
                | Row ExpressionList
                | ArrayLit ExpressionList
                | Case cases : ExpressionListExpressionPairList
                       els : (Maybe Expression)
                | Exists sel : Statement
                | BinOpCall BinOp
                            arg1 : Expression
                            arg2 : Expression
                | UnOpCall UnOp Expression
                | FunCall String ExpressionList
                | InPredicate Expression Bool InList
                  -- windowfn selectitem partitionby orderby orderbyasc?
                | WindowFn fn : Expression
                           partitionBy : ExpressionList
                           orderBy : ExpressionList
                           dir : Direction
                | ScalarSubQuery sel : Statement
                | ArraySub Expression ExpressionList
                | Between val : Expression
                          lower : Expression
                          upper : Expression

DATA InList | InList ExpressionList | InSelect sel : Statement

TYPE ExpressionList = [Expression]
TYPE ExpressionListList = [ExpressionList]
TYPE StringList = [String]
TYPE SetClauseList = [SetClause]
TYPE AttributeDefList = [AttributeDef]
TYPE ConstraintList = [Constraint]
TYPE TypeAttributeDefList = [TypeAttributeDef]
TYPE ParamDefList = [ParamDef]
TYPE StringStringListPair = (String,StringList)
TYPE StringStringListPairList = [StringStringListPair]
TYPE SourcePosStatement = (MySourcePos, Statement)

-- slightly hacky, add the source positions only in statement lists
-- this includes top level statements, and statements inside createfunction,
-- and nested inside if, while, case statements, and the like, but
-- unfortunately not select expressions inside other
-- expressions/statements

TYPE StatementList = [SourcePosStatement]
TYPE ExpressionListStatementListPair = (ExpressionList,StatementList)
TYPE ExpressionListStatementListPairList = [ExpressionListStatementListPair]
TYPE ExpressionStatementListPair = (Expression, StatementList)
TYPE ExpressionStatementListPairList = [ExpressionStatementListPair]
TYPE VarDefList = [VarDef]
TYPE SelectItemList = [SelectItem]
TYPE RowConstraintList = [RowConstraint]
TYPE ExpressionListExpressionPair = (ExpressionList,Expression)
TYPE ExpressionListExpressionPairList = [ExpressionListExpressionPair]

{-
================================================================================
Type checking
-}

DATA Type | ScalarType String
          | UnknownType
DERIVING Type: Show,Eq

{-
================================================================================
Error reporting
-}

DATA Message | Error MySourcePos MessageStuff
             | Warning MySourcePos MessageStuff
             | Notice MySourcePos MessageStuff

DATA MessageStuff | ContinueNotInLoop
                  | NonSelectInSelectExpression
                  | CustomMessage String

DERIVING Message MessageStuff: Eq
DERIVING MessageStuff: Show
{

instance Show Message where
   show m = showMessage m
showMessage m = case m of
                  Error sp s -> showit "Error" sp s
                  Warning sp s -> showit "Warning" sp s
                  Notice sp s -> showit "Notice" sp s
                where
                  showit lev (fn,l,c) s = lev ++ "\n" ++ fn ++ ":"
                                          ++ show l ++ ":" ++ show c ++ ":\n"
                                          ++ show s ++ "\n"
}

-- Add a root data type so we can put initial values for inherited
-- attributes in the section which defines and uses those attributes
-- rather than in the sem_ calls

DATA Root | Root statements:StatementList
DERIVING Root: Show

DATA ExpressionRoot | ExpressionRoot expr:Expression
DERIVING ExpressionRoot: Show

-- =============================================================================

--attributes which every node has

SET AllNodes = Statement FnBody SetClause TableRef JoinExpression JoinType
               SelectList SelectItem CopySource AttributeDef RowConstraint
               Constraint TypeAttributeDef ParamDef VarDef RaiseType
               CombineType Volatility Language TypeName DropType Cascade
               Direction Distinct Natural IfExists RestartIdentity
               BinOp UnOp Expression InList
               ExpressionList ExpressionListList StringList SetClauseList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList StringStringListPair StringStringListPairList
               StatementList ExpressionListStatementListPair
               ExpressionListStatementListPairList ExpressionStatementListPair
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList ExpressionListExpressionPair
               ExpressionListExpressionPairList SourcePosStatement

DERIVING AllNodes: Show,Eq

-- use this attr to lift the source pos value so we can access it
-- couldn't find a way just to read the value direct from the tuple in
-- the semantic bit...

ATTR MySourcePos
         [
         |
         | val : SELF
         ]

SEM SourcePosStatement
    | Tuple x2.sourcePos = @x1.val


{-

================================================================================

attribute descriptions:

sourcePos - holds the source position used in messages, not very
accurate at the moment, just gives you the position of the first
character in the current statement

messages - used to collect error messages, also to be used for
warnings (e.g. $1 position argument used when all args have aliases),
and notices - will probably use these to highlight dodgy sql
code and idioms.


-}

ATTR AllNodes
  [ sourcePos: MySourcePos
  |
  |
  ]

ATTR AllNodes Root ExpressionRoot
  [
  |
  | messages USE {++} {[]} : {[Message]}
  ]

SEM Root
  | Root statements.sourcePos = ("",0,0)

SEM ExpressionRoot
  | ExpressionRoot expr.sourcePos = ("",0,0)


{-

================================================================================

= select statement testing

lots of places in the ast can only take a select statement (really a
select expression in these nodes), but select expressions don't exist
as a separate data type (maybe they should?), so the fields that hold
them can hold any statement type. The parser won't produce these bad
asts, but creating asts in other ways will, so we check them here

(Thinking about this, may change the ast to use a separate select
statement and select expression type, would probably work a lot
better, otoh, this approach may be able to support e.g insert
returning nested in a select and crazy stuff like that)

here is the checklist for these select expressions appearing in other nodes:

combineselect 2 selects
insert ?select
createtableas 1 select
createview 1 select
return query 1 select
forselect 1 select
select->subselect select
expression->exists select
            scalarsubquery select
            inselect select

the forselect also holds a statement list, so we need to make sure we
only pass the select only marker into the select part, all the others
we can pass it down to any subnodes.

Also, selects only actually means either a select statement or a
values statement (which is virtually a syntax sugered select
statement).

-}

ATTR AllNodes
  [ selectsOnly: Bool
  |
  |
  ]

SEM Root
  | Root statements.selectsOnly = False

SEM ExpressionRoot
  | ExpressionRoot expr.selectsOnly = True

-- set the selects only
SEM Statement
     | CombineSelect sel1.selectsOnly = True
                     sel2.selectsOnly = True
     | Insert insData.selectsOnly = True
     | CreateTableAs CreateView expr.selectsOnly = True
     | ReturnQuery ForSelectStatement sel.selectsOnly = True

SEM TableRef
     | SubTref sel.selectsOnly = True

SEM Expression
     | ScalarSubQuery Exists sel.selectsOnly = True

SEM InList
     | InSelect sel.selectsOnly = True

--check 'em
{-
disabled for the time being because of problems noted below
SEM Statement
    --all the statement types except select (shorthand for this?)
    | CombineSelect Values Insert Update Delete Copy CopyData
      Truncate CreateTable CreateTableAs CreateView CreateType CreateFunction
      CreateDomain DropFunction DropSomething Assignment Return ReturnNext
      ReturnQuery Raise NullStatement Perform Execute ExecuteInto
      ForSelectStatement ForIntegerStatement WhileStatement
      {-ContinueStatement-} CaseStatement If
          lhs.messages = if @lhs.selectsOnly
                                      then [Error @lhs.sourcePos NonSelectInSelectExpression]
                                      else []
-}
{-

Problem 1: can't have two sem statements for the same node type which
both add messages, and then the messages get combined to provide the
final message list attribute value for that node. Don't know how to
get round this.

Problem 2: no shorthand to combine what the default rule for messages
would be and then add a bit extra - so if you want all the children
messages, plus possiby an extra message or two, have to write out the
default rule in full explicitly. Can get round this by writing out
loads of code.

================================================================================

= inloop testing

inloop - use to check continue, exit, and other commands that can only
appear inside loops (for, while, loop)

-}

ATTR AllNodes
  [ inLoop: Bool
  |
  |
  ]

SEM Root
  | Root statements.inLoop = False

SEM ExpressionRoot
  | ExpressionRoot expr.inLoop = False

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

SEM Statement
     | ForSelectStatement ForIntegerStatement WhileStatement sts.inLoop = True
     | CreateFunction body.inLoop = False

-- now we can check when we hit a continue statement if it is in the
-- right context
SEM Statement
    | ContinueStatement  lhs.messages = if not @lhs.inLoop
                                          then [Error @lhs.sourcePos ContinueNotInLoop]
                                          else []

{-
save this so i don't have to type it all out again
SEM Statement
    | Select CombineSelect Values Insert Update Delete Copy CopyData
      Truncate CreateTable CreateTableAs CreateView CreateType CreateFunction
      CreateDomain DropFunction DropSomething Assignment Return ReturnNext
      ReturnQuery Raise NullStatement Perform Execute ExecuteInto
      ForSelectStatement ForIntegerStatement WhileStatement
      ContinueStatement CaseStatement If-}
{-
================================================================================

= typechecking
-}

ATTR AllNodes Root ExpressionRoot
  [
  |
  | nodeType USE {`setUnknown`} {UnknownType} : {Type}
  ]

{
setUnknown :: Type -> Type -> Type
setUnknown t1 t2 = UnknownType
}

SEM Expression
     | IntegerLit lhs.nodeType = ScalarType "Integer"

{-


================================================================================

Non attribute grammar stuff

-}
-- use to use record syntax to try to insulate code from field
-- changes, and not have to write out loads of nothings and [] for
-- simple selects, but don't know how to use haskell named records
-- from uuagc code
--makeSelect :: Statement
--makeSelect = Select Dupes (SelectList [SelExp (Identifier "*")] [])
--                    Nothing Nothing [] Nothing [] Asc Nothing Nothing

{-

================================================================================

= checkAst

Main function to run on asts, returns a list of errors, warnings, etc.

-}
{
checkAst :: StatementList -> [Message]
checkAst sts = let t = sem_Root (Root sts)
               in (messages_Syn_Root (wrap_Root t Inh_Root))
{-
================================================================================

= Types

== getExpressionType

Gets the type of an expression

-}

getExpressionType :: Expression -> Type
getExpressionType ex = let t = sem_ExpressionRoot (ExpressionRoot ex)
                       in (nodeType_Syn_ExpressionRoot
                           (wrap_ExpressionRoot t Inh_ExpressionRoot))


--hack job, often not interested in the source positions when testing
--the asts produced, so this function will reset all the source
--positions to empty ("", 0, 0)

resetSps :: [Statement] -> [Statement]
resetSps sts = map resetSp sts

resetSp (CreateFunction l n p r bq b v) = (CreateFunction l n p r bq
                                              (case b of
                                                SqlFnBody stss -> SqlFnBody (map resetSp' stss)
                                                PlpgsqlFnBody vd stss -> PlpgsqlFnBody vd (map resetSp' stss))
                                            v)
resetSp (ForSelectStatement v s stss) = ForSelectStatement v s (map resetSp' stss)
resetSp (ForIntegerStatement v f t stss) = ForIntegerStatement v f t (map resetSp' stss)
resetSp (CaseStatement v cs els) = CaseStatement v (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp (If cs els) = If (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp a = a
resetSp' (_,st) = (nsp,resetSp st)

resetSps' :: StatementList -> StatementList
resetSps' sts = map resetSp' sts

nsp :: MySourcePos
nsp = ("", 0,0)
}

{-

containment guide for statements:
combineselect 2 selects
insert ?select
createtableas 1 select
createview 1 select
return query 1 select
forselect 1 select, [statement]
forinteger [statement]
while [statement]
casestatement [[statement]]
if [[statement]]
createfunction->fnbody [Statement]
select->subselect select
expression->exists select
            scalarsubquery select
            inselect select

TODO

some non type-check checks:
check plpgsql only in plpgsql function
do all containment checks above
orderby in top level select only
copy followed immediately by copydata iff stdin, copydata only follows
copy from stdin
args to raise, etc, same number as placeholders in string
natural with correct join types
no natural with onexpr in joins
constraint column ref checks?
typename -> setof (& fix parsing), what else like this?
expressions: positionalarg in function, window function only in select
 list top level

review all ast checks, and see if we can also catch them during
parsing (e.g. typeName parses setof, but this should only be allowed
for a function return, and we can make this a parse error when parsing
from source code rather than checking a generated ast. This needs
judgement to say whether a parse error is better than a check error, I
think for setof it is, but e.g. for a continue not in a loop (which
could be caught during parsing) works better as a check error, looking
at the error message the user will get. This might be wrong, haven't
thought too carefully about it yet).


some sql support to add, common ones:
alter table
create index
create rule
create trigger
ctes
loop, exit, labels
easy ones: transactions, savepoints, listen
prepare, execute + using
proper general operator support & lex properly

Type checking

(Have no idea what I am doing, just going to try to bluff it, then
learn how to do it properly later)

Create a algebraic data type to represent types.

Add a type called Unknown which always passes. Add this to everything
by default - now all code type checks and we can add proper type
checking piecemeal.

Start with tables, and then simple select * from table, select a,b from table.
Then maybe do some simple expressions.

Add separate function to return the inferred types of statementlists/
expressions, etc., so the checkAst checks the types are consistent,
and them have something like getStatementType, getStatementsType,
getExpressionType (which works for selects and relation valued
expressions as well as scalars, tuples, etc).

-}
