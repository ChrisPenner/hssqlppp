{-
Copyright 2009 Jake Wheat

This file contains the ast nodes, which aren't brilliantly designed,
and the attribute grammar system which uses the Utrecht University
Attribute Grammar system:

http://www.cs.uu.nl/wiki/bin/view/HUT/AttributeGrammarSystem
http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter

There are no source positions in the ast at the moment. The grammar
system is intended to act a as type checker, and to do other static
checks for the time being, which is a work in progress and in a very
early state.

These ast nodes a are both used as the result of successful parsing,
and as the input to the pretty printer.

Lots of invalid sql is currently allowed if you construct the asts in
code, the parser isn't quite as lenient, but still can parse and not
complain about a lot of invalid sql.

use

uuagc -dcfws Ast.ag

to generate a new Ast.hs from this file

(install uuagc with
cabal install uuagc
)

Tip: after you've compiled this file with the above command, you can
get loads of warnings from ghc if you're the sort who enables
these. Using haskell-mode from emacs usually results in compiles being
really slow just cos emacs outputs all these warnings _really_ slowly,
and also any real warnings and errors can get drowned out. You can get
rid of these warnings by ghc compiling the produced Ast.hs on the
command line:
ghc -c Ast.hs

does the job, you can then compile from emacs and it will use the .o
file and you won't get any warnings about generated code in Ast.hs (if
the .o file gets stale, ghc / haskell mode will do the right thing and
ignore it, but it can't tell if the Ast.hs has gotten stale wrt
Ast.ag)
-}

MODULE {Ast}
{
    -- exports
    MySourcePos

    --ast nodes
   ,Statement (..)
   ,SelectExpression (..)
   ,FnBody (..)
   ,SetClause (..)
   ,TableRef (..)
   ,JoinExpression (..)
   ,JoinType (..)
   ,SelectList (..)
   ,SelectItem (..)
   ,CopySource (..)
   ,AttributeDef (..)
   ,RowConstraint (..)
   ,Constraint (..)
   ,TypeAttributeDef (..)
   ,ParamDef (..)
   ,VarDef (..)
   ,RaiseType (..)
   ,CombineType (..)
   ,Volatility (..)
   ,Language (..)
   ,TypeName (..)
   ,DropType (..)
   ,Cascade (..)
   ,Direction (..)
   ,Distinct (..)
   ,Natural (..)
   ,IfExists (..)
   ,RestartIdentity (..)
   ,Expression (..)
   ,FunName (..)
   ,KeywordOperator(..)
   ,OperatorType (..)
   ,getOperatorType
   ,InList (..)
   ,StatementList
   --checking stuff
   ,Message (..)
   ,MessageStuff (..)
   --types
   ,Type (..)
   ,TypeErrorInfo (..)
   --fns
   ,checkAst
   ,getExpressionType
   ,resetSps
   ,resetSp
   ,resetSp'
   ,resetSps'
   ,nsp
}
{} -- imports

{-
================================================================================

SQL top level statements

everything is chucked in here, in particular this means that many places where
a select can appear inside another statement (e.g. a subselect), you can
instead put any statement - this type checks but is totally invalid.

-}

TYPE MySourcePos = (String, Int, Int)

DATA Statement

--queries

    | SelectStatement SelectExpression

-- dml

    --table targetcolumns insertdata(values or select statement) returning
    | Insert table : String
             targetCols : StringList
             insData : SelectExpression
             returning : (Maybe SelectList)
    --tablename setitems where returning
    | Update table : String
             assigns : SetClauseList
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename, where, returning
    | Delete table : String
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename column names, from
    | Copy table : String
           targetCols : StringList
           source : CopySource
    --represents inline data for copy statement
    | CopyData insData : String
    | Truncate tables: StringList
               restartIdentity : RestartIdentity
               cascade : Cascade

-- ddl

    | CreateTable name : String
                  atts : AttributeDefList
                  cons : ConstraintList
    | CreateTableAs name : String
                    expr : SelectExpression
    | CreateView name : String
                 expr : SelectExpression
    | CreateType name : String
                 atts : TypeAttributeDefList
    -- language name args rettype bodyquoteused body vol
    | CreateFunction lang : Language
                     name : String
                     params : ParamDefList
                     rettype : TypeName
                     bodyQuote : String
                     body : FnBody
                     vol : Volatility
    -- name type checkexpression
    | CreateDomain name : String
                   typ : TypeName
                   check : (Maybe Expression)
    -- ifexists (name,argtypes)* cascadeorrestrict
    | DropFunction ifE : IfExists
                   sigs : StringStringListPairList
                   cascade : Cascade
    -- ifexists names cascadeorrestrict
    | DropSomething dropType : DropType
                    ifE : IfExists
                    names : StringList
                    cascade : Cascade
    | Assignment target : String
                 value : Expression
    | Return value : (Maybe Expression)
    | ReturnNext expr : Expression
    | ReturnQuery sel : SelectExpression
    | Raise level : RaiseType
            message : String
            args : ExpressionList
    | NullStatement
    | Perform expr : Expression
    | Execute expr : Expression
    | ExecuteInto expr : Expression
                  targets : StringList
    | ForSelectStatement var : String
                         sel : SelectExpression
                         sts : StatementList
    | ForIntegerStatement var : String
                          from : Expression
                          to : Expression
                          sts : StatementList
    | WhileStatement expr : Expression
                     sts : StatementList
    | ContinueStatement
    --variable, list of when parts, else part
    | CaseStatement val : Expression
                    cases : ExpressionListStatementListPairList
                    els : StatementList
    --list is
    --first if (condition, statements):elseifs(condition, statements)
    --last bit is else statements
    | If cases : ExpressionStatementListPairList
         els : StatementList

-- =============================================================================

--Statement components

-- maybe this should be called relation valued expression?
DATA SelectExpression
    | Select selDistinct : Distinct
             selSelectList : SelectList
             selTref : (Maybe TableRef)
             selWhere : (Maybe Expression)
             selGroupBy : ExpressionList
             selHaving : (Maybe Expression)
             selOrderBy : ExpressionList
             selDir : Direction
             selLimit : (Maybe Expression)
             selOffset : (Maybe Expression)
    | CombineSelect ctype : CombineType
                    sel1 : SelectExpression
                    sel2 : SelectExpression
    | Values ExpressionListList

DATA FnBody | SqlFnBody sts : StatementList
            | PlpgsqlFnBody VarDefList sts : StatementList

DATA SetClause | SetClause String Expression | RowSetClause StringList ExpressionList

DATA TableRef | Tref String
              | TrefAlias tref : String
                          alias : String
              | JoinedTref tref : TableRef
                           nat : Natural
                           joinType : JoinType
                           jtref : TableRef
                           onExpr : (Maybe JoinExpression)
              | SubTref sel : SelectExpression alias : String
              | TrefFun Expression
              | TrefFunAlias Expression String

DATA JoinExpression | JoinOn Expression | JoinUsing StringList

DATA JoinType | Inner | LeftOuter| RightOuter | FullOuter | Cross

-- select columns, into columns

DATA SelectList | SelectList SelectItemList StringList

DATA SelectItem | SelExp Expression
                | SelectItem Expression String

DATA CopySource | CopyFilename String | Stdin

--name type default null constraint

DATA AttributeDef | AttributeDef name : String
                                 typ : TypeName
                                 check : (Maybe Expression)
                                 cons : RowConstraintList

--Constraints which appear attached to an individual field

DATA RowConstraint | NullConstraint
                   | NotNullConstraint
                   | RowCheckConstraint Expression
                   | RowUniqueConstraint
                   | RowPrimaryKeyConstraint
                   | RowReferenceConstraint table : String
                                            att : (Maybe String)
                                            onUpdate : Cascade
                                            onDelete : Cascade

--constraints which appear on a separate row in the create table

DATA Constraint | UniqueConstraint StringList
                | PrimaryKeyConstraint StringList
                | CheckConstraint Expression
                  -- sourcecols targettable targetcols ondelete onupdate
                | ReferenceConstraint atts : StringList
                                      table : String
                                      tableAtts : StringList
                                      onUpdate : Cascade
                                      onDelete : Cascade

DATA TypeAttributeDef | TypeAttDef name : String
                                   typ : TypeName

DATA ParamDef | ParamDef String TypeName
              | ParamDefTp TypeName

DATA VarDef | VarDef name : String
                     typ : TypeName
                     value : (Maybe Expression)

DATA RaiseType | RNotice | RException | RError

DATA CombineType | Except | Union | Intersect | UnionAll

DATA Volatility | Volatile | Stable | Immutable

DATA Language | Sql | Plpgsql

DATA TypeName | SimpleTypeName tn:String
              | PrecTypeName tn:String prec:Integer
              | ArrayTypeName typ:TypeName
              | SetOfTypeName typ:TypeName

DATA DropType | Table
         | Domain
         | View
         | Type

DATA Cascade | Cascade | Restrict

DATA Direction | Asc | Desc

DATA Distinct | Distinct | Dupes

DATA Natural | Natural | Unnatural

DATA IfExists | Require | IfExists

DATA RestartIdentity | RestartIdentity | ContinueIdentity

{-
================================================================================

Expressions

Similarly to the statement type, all expressions
are chucked into one even though there are many restrictions
on which expressions can appear in different places.
Maybe this should be called scalar expression?
-}
DATA Expression | IntegerLit Integer
                | FloatLit Double
                | StringLit quote : String
                            value : String
                | NullLit
                | BooleanLit Bool
                | PositionalArg Integer
                | Cast expr:Expression tn:TypeName
                | Identifier String
                | Case cases : CaseExpressionListExpressionPairList
                       els : MaybeExpression
                | Exists sel : SelectExpression
                | FunCall funName:FunName args:ExpressionList
                | InPredicate Expression Bool InList
                  -- windowfn selectitem partitionby orderby orderbyasc?
                | WindowFn fn : Expression
                           partitionBy : ExpressionList
                           orderBy : ExpressionList
                           dir : Direction
                | ScalarSubQuery sel : SelectExpression

TYPE MaybeExpression = MAYBE Expression

{-

list of expression flavours from postgresql with this ast equivs
constant/literal               integerlit, floatlit, stringlit, nulllit, boollit
column reference               identifier
positional parameter reference   positionalarg
subscripted expression            fun arraysub
field selection expression        identifier
operator invocation               fun op
function call                     fun simple
aggregate expression              ?
window function call              windowfn
type cast                         cast
scalar subquery                   scalarsubquery
array constructor                 fun arrayval
row constructor                   fun rowctor

TODO: think about having separate parse tree which the parser produces,
and a proper set of ast types with no pollution from concrete syntax
or parsing considerations


Anything that is represented in the ast as some sort of name plus a
list of expressions as arguments is treated as the same type of node:
FunCall.

This includes
symbol operators
regular function calls
keyword operators e.g. and, like (ones which can be parsed as normal
  syntactic operators)
unusual syntax operators, e.g. between
unusual syntax function calls e.g. substring(x from 5 for 3)
arrayctors e.g. array[3,5,6]
rowctors e.g. ROW (2,4,6)
array subscripting

All of these could be considered concrete syntax variants of function
calls, which take none, one or more expressions as arguments, and
return a single expression as the result.

Divide them up into different flavours (corresponding to the FunName
algebraic data type constructors), which is guided by what the pretty
printer needs to work (maybe this is a bit inelegant):
all regular function calls like [name](args,...) are SimpleFuns
all regular operators (symbols, regular prefix,infix and postfix) are
  treated the same
arrayctors, rowctors, array subscript are each given their own ctor
all the standard keyword operators (prefix, infix and postfix) are
  given their own ctor
each unusual syntax keyword operator is given its own ctor
each unusual syntax function call is given its own ctor

keyword operators (regular prefix, infix and postfix):
and, or, not
is null, is not null, isnull, notnull
is distinct from, is not distinct from
is true, is not true,is false, is not false, is unknown, is not unknown
like, not like, ilike, not ilike
similar to, not similar to
in, not in (don't include these here since the argument isn't always an expr)

unusual syntax operators and fn calls
between, not between, between symmetric
overlay, substring, trim
any, some, all

-}


DATA FunName | SimpleFun String
             | Operator String
             | KOperator KeywordOperator
             | ArrayCtor
             | RowCtor
             | ArraySub
             | Substring
             | Between
               --add not between, overlay, any, etc.

DATA KeywordOperator | And | Or | Not
                     | IsNull | IsNotNull
                     | Like
                       -- add is distinct from, ilike, etc

DATA OperatorType | BinaryOp | PrefixOp | PostfixOp

{

-- for now, assume that all the overloaded operators that have the
-- same name are all either binary, prefix or postfix, otherwise the
-- getoperatortype would need the types of the arguments to determine
-- the operator type, and the parser would have to be a lot cleverer

getOperatorType :: String -> OperatorType
getOperatorType s = case () of
                      _ | any (\(x,_,_) -> x == s) binaryOperatorTypes ->
                            BinaryOp
                        | any (\(x,_,_) -> x == s ||
                                           (x=="-" && s=="u-"))
                              prefixOperatorTypes ->
                            PrefixOp
                        | any (\(x,_,_) -> x == s) postfixOperatorTypes ->
                            PostfixOp
                        --special case the keyword operators
                        | otherwise ->
                            error $ "don't know flavour of operator " ++ s
}


DATA InList | InList ExpressionList | InSelect sel : SelectExpression

-- some list nodes, not sure if all of these are needed as separately
-- named node types

TYPE ExpressionList = [Expression]
TYPE ExpressionListList = [ExpressionList]
TYPE StringList = [String]
TYPE SetClauseList = [SetClause]
TYPE AttributeDefList = [AttributeDef]
TYPE ConstraintList = [Constraint]
TYPE TypeAttributeDefList = [TypeAttributeDef]
TYPE ParamDefList = [ParamDef]
TYPE StringStringListPair = (String,StringList)
TYPE StringStringListPairList = [StringStringListPair]
TYPE ExpressionListStatementListPair = (ExpressionList,StatementList)
TYPE ExpressionListStatementListPairList = [ExpressionListStatementListPair]
TYPE ExpressionStatementListPair = (Expression, StatementList)
TYPE ExpressionStatementListPairList = [ExpressionStatementListPair]
TYPE VarDefList = [VarDef]
TYPE SelectItemList = [SelectItem]
TYPE RowConstraintList = [RowConstraint]
TYPE CaseExpressionListExpressionPair = (CaseExpressionList,Expression)
TYPE CaseExpressionList = [Expression]
TYPE CaseExpressionListExpressionPairList = [CaseExpressionListExpressionPair]

-- slightly hacky, add the source positions only in statement lists
-- this includes top level statements, and statements inside createfunction,
-- and nested inside if, while, case statements, and the like, but
-- unfortunately not select expressions inside other
-- expressions/statements

TYPE SourcePosStatement = (MySourcePos, Statement)
TYPE StatementList = [SourcePosStatement]


{-
================================================================================
Error reporting
-}

DATA Message | Error MySourcePos MessageStuff
             | Warning MySourcePos MessageStuff
             | Notice MySourcePos MessageStuff

DATA MessageStuff | ContinueNotInLoop
                  | CustomMessage String

DERIVING Message MessageStuff: Eq
DERIVING MessageStuff: Show
{

instance Show Message where
   show m = showMessage m

showMessage :: Message -> [Char]
showMessage m = case m of
                  Error sp s -> showit "Error" sp s
                  Warning sp s -> showit "Warning" sp s
                  Notice sp s -> showit "Notice" sp s
                where
                  showit lev (fn,l,c) s = lev ++ "\n" ++ fn ++ ":"
                                          ++ show l ++ ":" ++ show c ++ ":\n"
                                          ++ show s ++ "\n"
}

-- Add a root data type so we can put initial values for inherited
-- attributes in the section which defines and uses those attributes
-- rather than in the sem_ calls

DATA Root | Root statements:StatementList
DERIVING Root: Show

DATA ExpressionRoot | ExpressionRoot expr:Expression
DERIVING ExpressionRoot: Show

{-
================================================================================

=some basic bookkeeping

attributes which every node has
-}

SET AllNodes = Statement SelectExpression FnBody SetClause TableRef JoinExpression JoinType
               SelectList SelectItem CopySource AttributeDef RowConstraint
               Constraint TypeAttributeDef ParamDef VarDef RaiseType
               CombineType Volatility Language TypeName DropType Cascade
               Direction Distinct Natural IfExists RestartIdentity
               Expression InList MaybeExpression
               ExpressionList ExpressionListList StringList SetClauseList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList StringStringListPair StringStringListPairList
               StatementList ExpressionListStatementListPair
               ExpressionListStatementListPairList ExpressionStatementListPair
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList CaseExpressionListExpressionPair
               CaseExpressionListExpressionPairList CaseExpressionList
               SourcePosStatement FunName KeywordOperator


SET NonListNodes = Statement SelectExpression FnBody SetClause TableRef JoinExpression JoinType
               SelectItem CopySource AttributeDef RowConstraint
               Constraint TypeAttributeDef ParamDef VarDef RaiseType
               CombineType Volatility Language TypeName DropType Cascade
               Direction Distinct Natural IfExists RestartIdentity
               Expression InList MaybeExpression
               StringStringListPair ExpressionListStatementListPair
               ExpressionStatementListPair
               CaseExpressionListExpressionPair
               SourcePosStatement FunName


SET ListNodes = SelectList ExpressionList ExpressionListList StringList
                SetClauseList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList StringStringListPairList
               StatementList
               ExpressionListStatementListPairList
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList
               CaseExpressionListExpressionPairList CaseExpressionList

DERIVING AllNodes: Show,Eq

-- use this attr to lift the source pos value so we can access it
-- couldn't find a way just to read the value direct from the tuple in
-- the semantic bit...

ATTR MySourcePos
         [
         |
         | val : SELF
         ]

SEM SourcePosStatement
    | Tuple x2.sourcePos = @x1.val


{-

================================================================================

attribute descriptions:

sourcePos - holds the source position used in messages, not very
accurate at the moment, just gives you the position of the first
character in the current statement

messages - used to collect error messages, also to be used for
warnings (e.g. $1 position argument used when all args have aliases),
and notices - will probably use these to highlight dodgy sql
code and idioms.


-}

ATTR AllNodes
  [ sourcePos: MySourcePos
  |
  |
  ]

ATTR AllNodes Root ExpressionRoot
  [
  |
  | messages USE {++} {[]} : {[Message]}
  ]

SEM Root
  | Root statements.sourcePos = ("",0,0)

SEM ExpressionRoot
  | ExpressionRoot expr.sourcePos = ("",0,0)


{-

================================================================================

= static tests

Problem 1: can't have two sem statements for the same node type which
both add messages, and then the messages get combined to provide the
final message list attribute value for that node. Workaround is
instead of having each check in it's own section, to combine them all
into one SEM.

Problem 2: no shorthand to combine what the default rule for messages
would be and then add a bit extra - so if you want all the children
messages, plus possiby an extra message or two, have to write out the
default rule in full explicitly. Can get round this by writing out
loads of code.

Both the workarounds to these seem a bit tedious and error prone, and
will make the code much less readable. Maybe need a preprocessor to
produce the ag file?

================================================================================

= inloop testing

inloop - use to check continue, exit, and other commands that can only
appear inside loops (for, while, loop)

-}

ATTR AllNodes
  [ inLoop: Bool
  |
  |
  ]

SEM Root
  | Root statements.inLoop = False

SEM ExpressionRoot
  | ExpressionRoot expr.inLoop = False

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

SEM Statement
     | ForSelectStatement ForIntegerStatement WhileStatement sts.inLoop = True
     | CreateFunction body.inLoop = False

-- now we can check when we hit a continue statement if it is in the
-- right context
SEM Statement
    | ContinueStatement  lhs.messages = if not @lhs.inLoop
                                          then [Error @lhs.sourcePos ContinueNotInLoop]
                                          else []

{-
save this so i don't have to type it all out again
SEM Statement
    | SelectStatement CombineSelect Values Insert Update Delete Copy CopyData
      Truncate CreateTable CreateTableAs CreateView CreateType CreateFunction
      CreateDomain DropFunction DropSomething Assignment Return ReturnNext
      ReturnQuery Raise NullStatement Perform Execute ExecuteInto
      ForSelectStatement ForIntegerStatement WhileStatement
      ContinueStatement CaseStatement If-}

{-
================================================================================
Type checking

the current type checking approach doesn't quite match how SQL
works. What it will do when the first version is finished, is possibly
read the database catalogs, then read the source script(s) and
statically check the types are consistent, as if the scripts are
declarative descriptions rather than a series of imperative
commands. In particular, this means that it won't be able to type
check dynamically generated tables, functions, views, etc., in a sense
it is static whereas SQL is dynamic.

One possible solution to this is to defer type checking and use the
database to load the script bit by bit whilst type checking as bits
are loaded.

Part of the syntax extension system design is to provide some
specialized methods for generating sql code in a way that can be type
checked statically without having to run the code.

-}

DATA Type | ScalarType String
          | ArrayType Type
          | AnyArray
          | AnyElement
          | UnknownType
          | SetOfType Type
          | TypeList tps:{[Type]}
          | TypeError MySourcePos TypeErrorInfo

DATA TypeErrorInfo | WrongTypes expected:Type got:{[Type]}
                   | WrongTypeList expected:{[Type]} got:{[Type]}
                   | WrongNumArgs expected:Int got:Int
                   | WrongType expected:Type got:Type
                   | NotArrayType got:Type
                   | NeedOneOrMoreArgs
                   | OtherTypeError String
                   | UnknownTypeError String
                   | OperatorNeeds1Or2Args got:Int
                   | NoMatchingOperator o:String t:{[Type]}
                   | MultipleMatchingOperators o:String t:{[Type]}
                   | NoMatchingKOperator o:KeywordOperator t:{[Type]}
                   | MultipleMatchingKOperators o:KeywordOperator t:{[Type]}

DERIVING Type TypeErrorInfo: Show,Eq

ATTR NonListNodes Root ExpressionRoot
  [
  |
  | nodeType USE {`setUnknown`} {UnknownType} : {Type}
  ]


ATTR ListNodes
  [
  |
  | nodeType USE {`appendTypeList`} {TypeList []} : {Type}
  ]


-- type checking utilities

{
setUnknown :: Type -> Type -> Type
setUnknown _ _ = UnknownType

appendTypeList :: Type -> Type -> Type
appendTypeList t1 (TypeList ts) = TypeList (t1:ts)
appendTypeList t1 t2 = TypeList (t1:t2:[])

--if the first argument is unknown or type error, pass it on
--otherwise use the second argument
propagateUnknownError :: Type -> Type -> Type
propagateUnknownError t t1 =
    case t of
      a@(TypeError _ _) -> a
      UnknownType -> UnknownType
      TypeList l -> doTypeList l
      _ -> t1
    where
      -- run through the type list, if there are any eorors, collect
      -- them all into a list
      -- otherwise, if there are any unknowns, then the type is
      -- unknown
      -- otherwise, keep the list the same
      doTypeList ts =
          let unks = filter (\u -> case u of
                                     UnknownType -> True
                                     _ -> False) ts
              errs = filter (\u -> case u of
                                     TypeError _ _ -> True
                                     _ -> False) ts
          in case () of
               _ | length errs > 0 -> case () of
                                        _ | length errs == 1 -> head errs
                                          | otherwise -> TypeList errs
                 | length unks > 0 -> UnknownType
                 | otherwise -> t1

typesFromTypeList :: Type -> [Type]
typesFromTypeList (TypeList ts) = ts
typesFromTypeList x = error $ "can't get types from list " ++ show x

typeFromArray :: Type -> Type
typeFromArray (ArrayType t) = t
typeFromArray x = error $ "can't get types from non array " ++ show x

isArrayType :: Type -> Bool
isArrayType (ArrayType _) = True
isArrayType (AnyArray) = True
isArrayType _ = False

}
---------------------------------------------
-- some helpers to handle scalar expression type checking

-- idea is to pass in a list of types of arguments to a scalar valued
-- operator (or function, whatever), and a constraint on the arg list,
-- and a method of getting the type of the result of the operator
-- application

DATA ArgsCheck
    -- check any number of args, all have the same type
    | AllSameType Type
    -- check any one or more args, all have the same type
    | AllSameType1 Type
    -- check any one or more args, all have the same type as eachother
    | AllSameType1Any
    | AllSameTypeAny
    -- check all same type, exact number of args
    | AllSameTypeNum Type Int
    -- check all same type as each other, exact number of args
    | AllSameTypeNumAny Int
    -- check type list matches given list
    | ExactList TypeList
    -- check type list passes predicate list respectively
    | ExactPredList ArgCheckList
    -- check all types pass single predicate, exact number
    | AllSameTypePredNum ArgCheck Int

{
type TypeList = [Type]
type ArgCheckList = [ArgCheck]
}

DATA ArgCheck
    | ArgCheck TypePred TypePredError

{
type TypePred = (Type -> Bool)
type TypePredError = (Type -> TypeErrorInfo)

exactType :: Type -> ArgCheck
exactType t = ArgCheck (t==) (WrongType t)

checkPredList :: MySourcePos -> [ArgCheck] -> [Type] -> [Type]
checkPredList sp achks ats =
    if length achks /= length ats
      then [TypeError sp
            (WrongNumArgs
             (length achks)
             (length ats))]
      else checkArg 0 [] achks ats
    where
      checkArg :: Int -> [Type] -> [ArgCheck] -> [Type] -> [Type]
      checkArg n acc ((ArgCheck chk err):chks) (t:ts) =
          if chk t
            then checkArg (n+1) acc chks ts
            else checkArg (n+1) (acc ++ [TypeError sp $ err t]) chks ts
      checkArg n acc [] [] = acc
}

DATA RetType
    -- always returns fixed type
    | ConstRetType Type
    -- returns same type as argument n
    | RetTypeAsArgN Int
    -- use generic fn on arg list to produce return type
    | RetTypeFun RetTypeFunner

{
type RetTypeFunner = ([Type] -> Type)

checkTypes :: MySourcePos -> Type -> ArgsCheck -> RetType -> Type
checkTypes sp tl@(TypeList l) argC retT =
    --1: check tl for errors or unknowns
    --2: check the args against the constraints,
    --  filter this for unknown or errors
    --  (it returns Just error, or Nothing if ok)
    --3: get the return type, and check that for unknowns or errors
    --4: success, return the result type
    let c = case checkArgs of
              Just t -> t
              Nothing -> getRetType
    in pe tl $ pe c c
    where
      getRetType =
          case retT of
            ConstRetType t -> t
            RetTypeAsArgN n -> l !! n
            RetTypeFun f -> f l
      checkArgs =
          case argC of
            AllSameType t -> checkArgListMatches t l
            AllSameType1 t | length l == 0 ->
                                Just $ te NeedOneOrMoreArgs
                           | otherwise -> checkArgListMatches t l
            AllSameTypeNum t n | length l /= n ->
                                    Just $ te $ WrongNumArgs n (length l)
                               | otherwise -> checkArgListMatches t l
            AllSameTypeNumAny n | length l /= n ->
                                    Just $ te $ WrongNumArgs n (length l)
                                | otherwise -> checkArgListMatches (head l) l
            AllSameTypeAny -> checkArgListMatches (head l) l
            AllSameType1Any | length l == 0 ->
                                Just $ te NeedOneOrMoreArgs
                            | otherwise -> checkArgListMatches (head l) l
            ExactList ts | ts /= l ->
                              Just $ te $ WrongTypeList ts l
                         | otherwise -> Nothing
            ExactPredList chks -> case checkPredList sp chks l of
                                    x | length x == 0 -> Nothing
                                      | otherwise -> Just $ TypeList x
            AllSameTypePredNum p n -> case checkPredList sp
                                             (replicate n p)
                                             l of
                                        x | length x == 0 -> Nothing
                                          | otherwise -> Just $ TypeList x
      checkArgListMatches tc tcs = if all (==tc) tcs
                                   then Nothing
                                   else Just $ te (WrongTypes tc tcs)
      te = TypeError sp
      pe = propagateUnknownError


checkTypes _ x _ _ = error $ "can't check types of non type list: " ++ show x

}


--bit hacky, used to work with maybe bits in attribute grammar code
SEM MaybeExpression
    | Just lhs.nodeType = @just.nodeType
    | Nothing lhs.nodeType = AnyElement

{-
================================================================================

= type table
this holds the available types

notes on pg types:
pseudotypes:any,anyelement,anyarray,anynonarray.anyenum
cstring,internal,language_handler,opaque
void
trigger
composite types
row type
setof (relation valued expressions)
dynamically typed record (can be any composite type)
numerical types: smallint, integer, bigint, decimal/numeric, real, double precision, serial, big serial,
 (some of these are aliases/shorthands, other aliases are: float, int2, int4, int8)
money
varchar, char, text
"char",name
bytea
boolean
enum
groups of type: timestamp, geometric, netaddr, bitstring,tsearch,uuid,xml
array (one array type per type (dimensions and sizes not part of type so int[] same type as int[][] (!))
custom create type types

domains:
the point of domains is you can't put constraints on types, but you
can wrap a type up in a domain and put a constraint on it there


== literals/selectors
needs some notes for parsing and checking the various ways to
represent literals/selectors of various types in source code, e.g. ROW
for composite types, and e.g. '{}' for empty array, etc.

== notes on type checking types
prectypename: only for certain types
check types refered to appear in type catalog cache

- build this early in the checking process, want to feed in a default
  list, or load it from a database, then supplement it with the new
  type definitions in the ast

looking at the typename nodes:
check context: setof can only appear as return type of function
what other restrictions on context?
some types refer to other types:
e.g. domains, composite types, enum, row types?

how does pg treat row types: are they all the same, are ones with the
same number of elements the same, are they only the same when they
have the same number and types of elements?

is it worth splitting types into scalar and type generators, and
handling them differently?

how does name and structural equivalence apply to pg types?

== notes on implicit casting

type categories boolean, numeric, string, bitstring, datetime,
timespan, geometric, network, and user-defined

implicit 'functional' casts


=== types catalog
select typname from pg_type;
restrict this?


=== basic type checking
at the moment - just check type exists in predetermined list of type
names
todo: option to read types from database catalog at time of type
checking
todo: collect type names from current source file to check against
also


with ts as
(select pg_catalog.format_type(t.oid, null) as name
  from pg_catalog.pg_type t
  where (t.typrelid = 0
         or (select c.relkind = 'c'
             from pg_catalog.pg_class c
             where c.oid = t.typrelid))
        and not exists(select 1 from pg_catalog.pg_type el
                       where el.oid = t.typelem and el.typarray = t.oid)
        and pg_catalog.pg_type_is_visible(t.oid)
  order by name)
select '"' || name || '",' from ts;

where need to check type names?
casts, create table attrs, create type (composite) attrs, create
domain, create function: param defs, returns, var defs, drop function


Type aliases

Some types in postgresql have multiple names. I think this is
hardcoded in their parser. There are two canonicalize routines to work
with these aliases.

The first one is for the ast, these canonical names have been chosen
arbitrarily, but with some guidelines: where there is a choice, prefer
the sql standard name, where there are multiple sql standard names,
choose the most concise or common one.

The second one is for postgresql, and converts type names into the
name which appears in the pg_type catalog table.

ast canonical names:
numbers:
int2, int4/integer, int8 -> smallint, int, bigint
numeric, decimal -> numeric
float(1) to float(24), real -> float(24)
float, float(25) to float(53), double precision -> float
serial, serial4 -> int
bigserial, serial8 -> bigint
character varying(n), varchar(n)-> varchar(n)
character(n), char(n) -> char(n)

I think there has to be another layer of type equivalences, e.g. for
type checking expressions, text and varchar are equivalent, domains
and their underlying type are equivalent.


Need to filter this list since they are all treated as scalar type
names atm, and need to treat scalars, composites, domains, special
types differently

-}
{
defaultTypes = [
 "abstime",
 "aclitem",
 "\"any\"",
 "anyarray",
 "anyelement",
 "anyenum",
 "anynonarray",
 "bigint",
 "bit",
 "bit varying",
 "boolean",
 "box",
 "bytea",
 "\"char\"",
 "character",
 "character varying",
 "cid",
 "cidr",
 "circle",
 "cstring",
 "date",
 "double precision",
 "gtsvector",
 "inet",
 "int2vector",
 "integer",
 "internal",
 "interval",
 "language_handler",
 "line",
 "lseg",
 "macaddr",
 "money",
 "name",
 "numeric",
 "oid",
 "oidvector",
 "opaque",
 "path",
 "point",
 "polygon",
 "real",
 "record",
 "refcursor",
 "regclass",
 "regconfig",
 "regdictionary",
 "regoper",
 "regoperator",
 "regproc",
 "regprocedure",
 "regtype",
 "reltime",
 "smallint",
 "smgr",
 "text",
 "tid",
 "timestamp without time zone",
 "timestamp with time zone",
 "time without time zone",
 "time with time zone",
 "tinterval",
 "trigger",
 "tsquery",
 "tsvector",
 "txid_snapshot",
 "unknown",
 "uuid",
 "void",
 "xid",
 "xml"]
}

SEM TypeName
     | SimpleTypeName
          lhs.nodeType = if @tn `elem` defaultTypes
                           then ScalarType @tn
                           else TypeError @lhs.sourcePos
                                  (UnknownTypeError @tn)
--     | PrecTypeName
--          lhs.nodeType = if @tn `elem` defaultTypes
--                           then ScalarType @tn
--                           else TypeError @lhs.sourcePos
--                                  (UnknownTypeError @tn)
     | ArrayTypeName
          lhs.nodeType = propagateUnknownError @typ.nodeType
                           (ArrayType @typ.nodeType)
     | SetOfTypeName
          lhs.nodeType = propagateUnknownError @typ.nodeType
                           (SetOfType @typ.nodeType)

--todo: some sort of validation on whether the cast will work
SEM Expression
    | Cast lhs.nodeType = propagateUnknownError
                            (TypeList
                             [@expr.nodeType])
                            @tn.nodeType

{-
= literals

This isn't right. The type of a literal is determined by its
context. The lexer produces the following flavours of tokens which are
relevant:
integer
non integer number
string

This follows how the pg parser works. The types of these are
determined by context, and then can have implicit casts applied.

An integer token, with implicit casting, can effectively have any
number type (and maybe other custom types also?).

A non integer number can have any non integer number type in the same
way (e.g. real, double precision, usertype?)

Strings is where it gets really messy, since a string token is
regarded as an unknown type, and can represent a literal of all sorts
of types, including numbers, text, arrays, row types, all sorts of
customer and user types.

Since we don't know the type until the type checking time, we can't
e.g. push the types into the parser, by determining the type of a
string token then checking that its text value parses ok to a value of
that type.

Will have to add some polymorphic type placeholders to be resolved
later, and add parsing of string literals to different kinds of types
here in the type checker so that we can syntax check/type check these
sorts of things.

-}

SEM Expression
     | IntegerLit lhs.nodeType = ScalarType "integer"
     | StringLit lhs.nodeType = ScalarType "text"
     | FloatLit lhs.nodeType = ScalarType "float"
     | BooleanLit lhs.nodeType = ScalarType "boolean"


{-

================================================================================

= function table
this holds the types of functions for lookup and checking

functions plus types:

create or replace function output_function_types() returns void as $$
declare
  r record;
  s text := '';
  i int;
  oids int8[];
begin
  for r in select p.proname, p.proargtypes, pg_get_function_result(p.oid) as ret
  from pg_proc p
  left join pg_catalog.pg_namespace n
    on n.oid = p.pronamespace
  where
       pg_catalog.pg_function_is_visible(p.oid)
       and not (p.proisagg
                or p.proiswindow
                or (p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype))
  order by p.proname loop
    raise notice 'fuck pg %', r.proname;
    s := s || r.proname ||  '",[';
    oids := (r.proargtypes::int8[]);
    if array_length(oids,1) = 0 or array_length(oids,1) is null then
      null;
    else
      for i in 0..array_upper(oids,1) loop
        s := s || (oids)[i];
        if i <> array_upper(oids,1) then
          s := s || ',*';
        end if;
      end loop;
    end if;
    s := s || '],"' ||
       r.ret || E'"),\n';
  end loop;
  raise notice E'\n%\n',s;
end;
$$ language plpgsql;

select output_function_types();


select a as array, s as subscript, a[s] as value
from (select generate_subscripts(, 1) as s, a from arrays) foo;


with a as (
 select p.proname, p.proargtypes::int8[], pg_get_function_result(p.oid) as ret
  from pg_proc p
  left join pg_catalog.pg_namespace n
    on n.oid = p.pronamespace
  where
       pg_catalog.pg_function_is_visible(p.oid)
       and not (p.proisagg
                or p.proiswindow
                or (p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype)))
select proname, proargtypes,
array_length(proargtypes,1),
array_lower(proargtypes,1),array_upper(proargtypes,1) from a order by proname;

-}


{-
================================================================================

= operator table
-}
{
binaryOperatorTypes = [
    ("!~",[ScalarType "character",ScalarType "text"],ScalarType "boolean"),
    ("!~",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("!~",[ScalarType "name",ScalarType "text"],ScalarType "boolean"),
    ("!~*",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("!~*",[ScalarType "name",ScalarType "text"],ScalarType "boolean"),
    ("!~*",[ScalarType "character",ScalarType "text"],ScalarType "boolean"),
    ("!~~",[ScalarType "character",ScalarType "text"],ScalarType "boolean"),
    ("!~~",[ScalarType "bytea",ScalarType "bytea"],ScalarType "boolean"),
    ("!~~",[ScalarType "name",ScalarType "text"],ScalarType "boolean"),
    ("!~~",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("!~~*",[ScalarType "name",ScalarType "text"],ScalarType "boolean"),
    ("!~~*",[ScalarType "character",ScalarType "text"],ScalarType "boolean"),
    ("!~~*",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("#",[ScalarType "bigint",ScalarType "bigint"],ScalarType "bigint"),
    ("#",[ScalarType "bit",ScalarType "bit"],ScalarType "bit"),
    ("#",[ScalarType "line",ScalarType "line"],ScalarType "point"),
    ("#",[ScalarType "box",ScalarType "box"],ScalarType "box"),
    ("#",[ScalarType "smallint",ScalarType "smallint"],ScalarType "smallint"),
    ("#",[ScalarType "lseg",ScalarType "lseg"],ScalarType "point"),
    ("#",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    ("##",[ScalarType "lseg",ScalarType "box"],ScalarType "point"),
    ("##",[ScalarType "point",ScalarType "lseg"],ScalarType "point"),
    ("##",[ScalarType "point",ScalarType "box"],ScalarType "point"),
    ("##",[ScalarType "lseg",ScalarType "lseg"],ScalarType "point"),
    ("##",[ScalarType "point",ScalarType "line"],ScalarType "point"),
    ("##",[ScalarType "lseg",ScalarType "line"],ScalarType "point"),
    ("##",[ScalarType "line",ScalarType "box"],ScalarType "point"),
    ("##",[ScalarType "line",ScalarType "lseg"],ScalarType "point"),
    ("#<",[ScalarType "tinterval",ScalarType "reltime"],ScalarType "boolean"),
    ("#<=",[ScalarType "tinterval",ScalarType "reltime"],ScalarType "boolean"),
    ("#<>",[ScalarType "tinterval",ScalarType "reltime"],ScalarType "boolean"),
    ("#=",[ScalarType "tinterval",ScalarType "reltime"],ScalarType "boolean"),
    ("#>",[ScalarType "tinterval",ScalarType "reltime"],ScalarType "boolean"),
    ("#>=",[ScalarType "tinterval",ScalarType "reltime"],ScalarType "boolean"),
    ("%",[ScalarType "bigint",ScalarType "bigint"],ScalarType "bigint"),
    ("%",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    ("%",[ScalarType "smallint",ScalarType "smallint"],ScalarType "smallint"),
    ("%",[ScalarType "numeric",ScalarType "numeric"],ScalarType "numeric"),
    ("&",[ScalarType "smallint",ScalarType "smallint"],ScalarType "smallint"),
    ("&",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    ("&",[ScalarType "bigint",ScalarType "bigint"],ScalarType "bigint"),
    ("&",[ScalarType "bit",ScalarType "bit"],ScalarType "bit"),
    ("&",[ScalarType "inet",ScalarType "inet"],ScalarType "inet"),
    ("&&",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("&&",[ScalarType "tinterval",ScalarType "tinterval"],ScalarType "boolean"),
    ("&&",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("&&",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "tsquery"),
    ("&&",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("&&",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "boolean"),
    ("&<",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("&<",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("&<",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("&<|",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("&<|",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("&<|",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("&>",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("&>",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("&>",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("*",[ScalarType "integer",ScalarType "smallint"],ScalarType "integer"),
    ("*",[ScalarType "bigint",ScalarType "bigint"],ScalarType "bigint"),
    ("*",[ScalarType "money",ScalarType "real"],ScalarType "money"),
    ("*",[ScalarType "smallint",ScalarType "bigint"],ScalarType "bigint"),
    ("*",[ScalarType "integer",ScalarType "money"],ScalarType "money"),
    ("*",[ScalarType "double precision",ScalarType "real"],ScalarType "double precision"),
    ("*",[ScalarType "path",ScalarType "point"],ScalarType "path"),
    ("*",[ScalarType "money",ScalarType "integer"],ScalarType "money"),
    ("*",[ScalarType "double precision",ScalarType "money"],ScalarType "money"),
    ("*",[ScalarType "double precision",ScalarType "interval"],ScalarType "interval"),
    ("*",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    ("*",[ScalarType "real",ScalarType "double precision"],ScalarType "double precision"),
    ("*",[ScalarType "real",ScalarType "real"],ScalarType "real"),
    ("*",[ScalarType "bigint",ScalarType "integer"],ScalarType "bigint"),
    ("*",[ScalarType "smallint",ScalarType "money"],ScalarType "money"),
    ("*",[ScalarType "money",ScalarType "smallint"],ScalarType "money"),
    ("*",[ScalarType "point",ScalarType "point"],ScalarType "point"),
    ("*",[ScalarType "circle",ScalarType "point"],ScalarType "circle"),
    ("*",[ScalarType "integer",ScalarType "bigint"],ScalarType "bigint"),
    ("*",[ScalarType "smallint",ScalarType "smallint"],ScalarType "smallint"),
    ("*",[ScalarType "interval",ScalarType "double precision"],ScalarType "interval"),
    ("*",[ScalarType "real",ScalarType "money"],ScalarType "money"),
    ("*",[ScalarType "box",ScalarType "point"],ScalarType "box"),
    ("*",[ScalarType "smallint",ScalarType "integer"],ScalarType "integer"),
    ("*",[ScalarType "double precision",ScalarType "double precision"],ScalarType "double precision"),
    ("*",[ScalarType "numeric",ScalarType "numeric"],ScalarType "numeric"),
    ("*",[ScalarType "bigint",ScalarType "smallint"],ScalarType "bigint"),
    ("*",[ScalarType "money",ScalarType "double precision"],ScalarType "money"),
    ("+",[ScalarType "real",ScalarType "real"],ScalarType "real"),
    ("+",[ScalarType "path",ScalarType "point"],ScalarType "path"),
    ("+",[ScalarType "path",ScalarType "path"],ScalarType "path"),
    ("+",[ScalarType "point",ScalarType "point"],ScalarType "point"),
    ("+",[ScalarType "bigint",ScalarType "bigint"],ScalarType "bigint"),
    ("+",[ScalarType "bigint",ScalarType "integer"],ScalarType "bigint"),
    ("+",[ScalarType "integer",ScalarType "bigint"],ScalarType "bigint"),
    ("+",[ScalarType "bigint",ScalarType "smallint"],ScalarType "bigint"),
    ("+",[ScalarType "smallint",ScalarType "bigint"],ScalarType "bigint"),
    ("+",[ScalarType "date",ScalarType "time with time zone"],ScalarType "timestamp with time zone"),
    ("+",[ScalarType "date",ScalarType "time without time zone"],ScalarType "timestamp without time zone"),
    ("+",[ScalarType "inet",ScalarType "bigint"],ScalarType "inet"),
    ("+",[ScalarType "interval",ScalarType "interval"],ScalarType "interval"),
    ("+",[ScalarType "timestamp with time zone",ScalarType "interval"],ScalarType "timestamp with time zone"),
    ("+",[ScalarType "bigint",ScalarType "inet"],ScalarType "inet"),
    ("+",[ScalarType "numeric",ScalarType "numeric"],ScalarType "numeric"),
    ("+",[ScalarType "double precision",ScalarType "real"],ScalarType "double precision"),
    ("+",[ScalarType "integer",ScalarType "date"],ScalarType "date"),
    ("+",[ScalarType "interval",ScalarType "timestamp with time zone"],ScalarType "timestamp with time zone"),
    ("+",[ScalarType "real",ScalarType "double precision"],ScalarType "double precision"),
    ("+",[ScalarType "interval",ScalarType "timestamp without time zone"],ScalarType "timestamp without time zone"),
    ("+",[ScalarType "interval",ScalarType "time with time zone"],ScalarType "time with time zone"),
    ("+",[ScalarType "time without time zone",ScalarType "interval"],ScalarType "time without time zone"),
    ("+",[ScalarType "interval",ScalarType "date"],ScalarType "timestamp without time zone"),
    ("+",[ScalarType "time with time zone",ScalarType "interval"],ScalarType "time with time zone"),
    ("+",[ScalarType "date",ScalarType "integer"],ScalarType "date"),
    ("+",[ScalarType "smallint",ScalarType "smallint"],ScalarType "smallint"),
    ("+",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    ("+",[ScalarType "smallint",ScalarType "integer"],ScalarType "integer"),
    ("+",[ScalarType "integer",ScalarType "smallint"],ScalarType "integer"),
    ("+",[ScalarType "date",ScalarType "interval"],ScalarType "timestamp without time zone"),
    ("+",[ScalarType "circle",ScalarType "point"],ScalarType "circle"),
    ("+",[ScalarType "interval",ScalarType "time without time zone"],ScalarType "time without time zone"),
    ("+",[ScalarType "time with time zone",ScalarType "date"],ScalarType "timestamp with time zone"),
    ("+",[ScalarType "aclitem[]",ScalarType "aclitem"],ScalarType "aclitem[]"),
    ("+",[ScalarType "abstime",ScalarType "reltime"],ScalarType "abstime"),
    ("+",[ScalarType "timestamp without time zone",ScalarType "interval"],ScalarType "timestamp without time zone"),
    ("+",[ScalarType "double precision",ScalarType "double precision"],ScalarType "double precision"),
    ("+",[ScalarType "time without time zone",ScalarType "date"],ScalarType "timestamp without time zone"),
    ("+",[ScalarType "money",ScalarType "money"],ScalarType "money"),
    ("+",[ScalarType "box",ScalarType "point"],ScalarType "box"),
    ("-",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    ("-",[ScalarType "double precision",ScalarType "double precision"],ScalarType "double precision"),
    ("-",[ScalarType "real",ScalarType "double precision"],ScalarType "double precision"),
    ("-",[ScalarType "double precision",ScalarType "real"],ScalarType "double precision"),
    ("-",[ScalarType "money",ScalarType "money"],ScalarType "money"),
    ("-",[ScalarType "inet",ScalarType "bigint"],ScalarType "inet"),
    ("-",[ScalarType "path",ScalarType "point"],ScalarType "path"),
    ("-",[ScalarType "numeric",ScalarType "numeric"],ScalarType "numeric"),
    ("-",[ScalarType "timestamp with time zone",ScalarType "timestamp with time zone"],ScalarType "interval"),
    ("-",[ScalarType "timestamp with time zone",ScalarType "interval"],ScalarType "timestamp with time zone"),
    ("-",[ScalarType "interval",ScalarType "interval"],ScalarType "interval"),
    ("-",[ScalarType "smallint",ScalarType "bigint"],ScalarType "bigint"),
    ("-",[ScalarType "box",ScalarType "point"],ScalarType "box"),
    ("-",[ScalarType "timestamp without time zone",ScalarType "timestamp without time zone"],ScalarType "interval"),
    ("-",[ScalarType "bigint",ScalarType "smallint"],ScalarType "bigint"),
    ("-",[ScalarType "integer",ScalarType "bigint"],ScalarType "bigint"),
    ("-",[ScalarType "bigint",ScalarType "integer"],ScalarType "bigint"),
    ("-",[ScalarType "date",ScalarType "interval"],ScalarType "timestamp without time zone"),
    ("-",[ScalarType "integer",ScalarType "smallint"],ScalarType "integer"),
    ("-",[ScalarType "time without time zone",ScalarType "time without time zone"],ScalarType "interval"),
    ("-",[ScalarType "aclitem[]",ScalarType "aclitem"],ScalarType "aclitem[]"),
    ("-",[ScalarType "bigint",ScalarType "bigint"],ScalarType "bigint"),
    ("-",[ScalarType "smallint",ScalarType "integer"],ScalarType "integer"),
    ("-",[ScalarType "smallint",ScalarType "smallint"],ScalarType "smallint"),
    ("-",[ScalarType "time with time zone",ScalarType "interval"],ScalarType "time with time zone"),
    ("-",[ScalarType "date",ScalarType "date"],ScalarType "integer"),
    ("-",[ScalarType "date",ScalarType "integer"],ScalarType "date"),
    ("-",[ScalarType "time without time zone",ScalarType "interval"],ScalarType "time without time zone"),
    ("-",[ScalarType "point",ScalarType "point"],ScalarType "point"),
    ("-",[ScalarType "abstime",ScalarType "reltime"],ScalarType "abstime"),
    ("-",[ScalarType "circle",ScalarType "point"],ScalarType "circle"),
    ("-",[ScalarType "real",ScalarType "real"],ScalarType "real"),
    ("-",[ScalarType "inet",ScalarType "inet"],ScalarType "bigint"),
    ("-",[ScalarType "timestamp without time zone",ScalarType "interval"],ScalarType "timestamp without time zone"),
    ("/",[ScalarType "integer",ScalarType "smallint"],ScalarType "integer"),
    ("/",[ScalarType "smallint",ScalarType "integer"],ScalarType "integer"),
    ("/",[ScalarType "circle",ScalarType "point"],ScalarType "circle"),
    ("/",[ScalarType "money",ScalarType "double precision"],ScalarType "money"),
    ("/",[ScalarType "double precision",ScalarType "real"],ScalarType "double precision"),
    ("/",[ScalarType "numeric",ScalarType "numeric"],ScalarType "numeric"),
    ("/",[ScalarType "box",ScalarType "point"],ScalarType "box"),
    ("/",[ScalarType "smallint",ScalarType "bigint"],ScalarType "bigint"),
    ("/",[ScalarType "integer",ScalarType "bigint"],ScalarType "bigint"),
    ("/",[ScalarType "interval",ScalarType "double precision"],ScalarType "interval"),
    ("/",[ScalarType "path",ScalarType "point"],ScalarType "path"),
    ("/",[ScalarType "real",ScalarType "real"],ScalarType "real"),
    ("/",[ScalarType "money",ScalarType "real"],ScalarType "money"),
    ("/",[ScalarType "bigint",ScalarType "integer"],ScalarType "bigint"),
    ("/",[ScalarType "bigint",ScalarType "smallint"],ScalarType "bigint"),
    ("/",[ScalarType "double precision",ScalarType "double precision"],ScalarType "double precision"),
    ("/",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    ("/",[ScalarType "money",ScalarType "smallint"],ScalarType "money"),
    ("/",[ScalarType "smallint",ScalarType "smallint"],ScalarType "smallint"),
    ("/",[ScalarType "bigint",ScalarType "bigint"],ScalarType "bigint"),
    ("/",[ScalarType "point",ScalarType "point"],ScalarType "point"),
    ("/",[ScalarType "real",ScalarType "double precision"],ScalarType "double precision"),
    ("/",[ScalarType "money",ScalarType "integer"],ScalarType "money"),
    ("<",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "boolean"),
    ("<",[ScalarType "tsvector",ScalarType "tsvector"],ScalarType "boolean"),
    ("<",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    ("<",[ScalarType "lseg",ScalarType "lseg"],ScalarType "boolean"),
    ("<",[ScalarType "macaddr",ScalarType "macaddr"],ScalarType "boolean"),
    ("<",[ScalarType "bigint",ScalarType "integer"],ScalarType "boolean"),
    ("<",[ScalarType "anyenum",ScalarType "anyenum"],ScalarType "boolean"),
    ("<",[ScalarType "uuid",ScalarType "uuid"],ScalarType "boolean"),
    ("<",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("<",[ScalarType "smallint",ScalarType "smallint"],ScalarType "boolean"),
    ("<",[ScalarType "record",ScalarType "record"],ScalarType "boolean"),
    ("<",[ScalarType "smallint",ScalarType "integer"],ScalarType "boolean"),
    ("<",[ScalarType "integer",ScalarType "smallint"],ScalarType "boolean"),
    ("<",[ScalarType "timestamp with time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("<",[ScalarType "integer",ScalarType "integer"],ScalarType "boolean"),
    ("<",[ScalarType "abstime",ScalarType "abstime"],ScalarType "boolean"),
    ("<",[ScalarType "boolean",ScalarType "boolean"],ScalarType "boolean"),
    ("<",[ScalarType "reltime",ScalarType "reltime"],ScalarType "boolean"),
    ("<",[ScalarType "timestamp without time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("<",[ScalarType "oid",ScalarType "oid"],ScalarType "boolean"),
    ("<",[ScalarType "timestamp with time zone",ScalarType "date"],ScalarType "boolean"),
    ("<",[ScalarType "oidvector",ScalarType "oidvector"],ScalarType "boolean"),
    ("<",[ScalarType "timestamp without time zone",ScalarType "date"],ScalarType "boolean"),
    ("<",[ScalarType "real",ScalarType "real"],ScalarType "boolean"),
    ("<",[ScalarType "\"char\"",ScalarType "\"char\""],ScalarType "boolean"),
    ("<",[ScalarType "date",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("<",[ScalarType "date",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("<",[ScalarType "name",ScalarType "name"],ScalarType "boolean"),
    ("<",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("<",[ScalarType "timestamp without time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("<",[ScalarType "double precision",ScalarType "double precision"],ScalarType "boolean"),
    ("<",[ScalarType "bytea",ScalarType "bytea"],ScalarType "boolean"),
    ("<",[ScalarType "path",ScalarType "path"],ScalarType "boolean"),
    ("<",[ScalarType "tinterval",ScalarType "tinterval"],ScalarType "boolean"),
    ("<",[ScalarType "money",ScalarType "money"],ScalarType "boolean"),
    ("<",[ScalarType "bigint",ScalarType "smallint"],ScalarType "boolean"),
    ("<",[ScalarType "smallint",ScalarType "bigint"],ScalarType "boolean"),
    ("<",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    ("<",[ScalarType "tid",ScalarType "tid"],ScalarType "boolean"),
    ("<",[ScalarType "bit varying",ScalarType "bit varying"],ScalarType "boolean"),
    ("<",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "boolean"),
    ("<",[ScalarType "date",ScalarType "date"],ScalarType "boolean"),
    ("<",[ScalarType "time without time zone",ScalarType "time without time zone"],ScalarType "boolean"),
    ("<",[ScalarType "time with time zone",ScalarType "time with time zone"],ScalarType "boolean"),
    ("<",[ScalarType "integer",ScalarType "bigint"],ScalarType "boolean"),
    ("<",[ScalarType "real",ScalarType "double precision"],ScalarType "boolean"),
    ("<",[ScalarType "double precision",ScalarType "real"],ScalarType "boolean"),
    ("<",[ScalarType "bit",ScalarType "bit"],ScalarType "boolean"),
    ("<",[ScalarType "bigint",ScalarType "bigint"],ScalarType "boolean"),
    ("<",[ScalarType "timestamp with time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("<",[ScalarType "numeric",ScalarType "numeric"],ScalarType "boolean"),
    ("<",[ScalarType "interval",ScalarType "interval"],ScalarType "boolean"),
    ("<",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("<#>",[ScalarType "abstime",ScalarType "abstime"],ScalarType "tinterval"),
    ("<->",[ScalarType "point",ScalarType "box"],ScalarType "double precision"),
    ("<->",[ScalarType "lseg",ScalarType "line"],ScalarType "double precision"),
    ("<->",[ScalarType "line",ScalarType "line"],ScalarType "double precision"),
    ("<->",[ScalarType "polygon",ScalarType "polygon"],ScalarType "double precision"),
    ("<->",[ScalarType "path",ScalarType "path"],ScalarType "double precision"),
    ("<->",[ScalarType "box",ScalarType "box"],ScalarType "double precision"),
    ("<->",[ScalarType "circle",ScalarType "circle"],ScalarType "double precision"),
    ("<->",[ScalarType "point",ScalarType "circle"],ScalarType "double precision"),
    ("<->",[ScalarType "circle",ScalarType "polygon"],ScalarType "double precision"),
    ("<->",[ScalarType "line",ScalarType "box"],ScalarType "double precision"),
    ("<->",[ScalarType "point",ScalarType "point"],ScalarType "double precision"),
    ("<->",[ScalarType "point",ScalarType "path"],ScalarType "double precision"),
    ("<->",[ScalarType "lseg",ScalarType "lseg"],ScalarType "double precision"),
    ("<->",[ScalarType "point",ScalarType "line"],ScalarType "double precision"),
    ("<->",[ScalarType "lseg",ScalarType "box"],ScalarType "double precision"),
    ("<->",[ScalarType "point",ScalarType "lseg"],ScalarType "double precision"),
    ("<<",[ScalarType "tinterval",ScalarType "tinterval"],ScalarType "boolean"),
    ("<<",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    ("<<",[ScalarType "smallint",ScalarType "integer"],ScalarType "smallint"),
    ("<<",[ScalarType "bigint",ScalarType "integer"],ScalarType "bigint"),
    ("<<",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("<<",[ScalarType "bit",ScalarType "integer"],ScalarType "bit"),
    ("<<",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    ("<<",[ScalarType "point",ScalarType "point"],ScalarType "boolean"),
    ("<<",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("<<",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("<<=",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    ("<<|",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("<<|",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("<<|",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("<=",[ScalarType "anyenum",ScalarType "anyenum"],ScalarType "boolean"),
    ("<=",[ScalarType "oidvector",ScalarType "oidvector"],ScalarType "boolean"),
    ("<=",[ScalarType "timestamp without time zone",ScalarType "date"],ScalarType "boolean"),
    ("<=",[ScalarType "oid",ScalarType "oid"],ScalarType "boolean"),
    ("<=",[ScalarType "bytea",ScalarType "bytea"],ScalarType "boolean"),
    ("<=",[ScalarType "timestamp with time zone",ScalarType "date"],ScalarType "boolean"),
    ("<=",[ScalarType "reltime",ScalarType "reltime"],ScalarType "boolean"),
    ("<=",[ScalarType "smallint",ScalarType "bigint"],ScalarType "boolean"),
    ("<=",[ScalarType "bigint",ScalarType "bigint"],ScalarType "boolean"),
    ("<=",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    ("<=",[ScalarType "timestamp without time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("<=",[ScalarType "abstime",ScalarType "abstime"],ScalarType "boolean"),
    ("<=",[ScalarType "bit varying",ScalarType "bit varying"],ScalarType "boolean"),
    ("<=",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "boolean"),
    ("<=",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("<=",[ScalarType "date",ScalarType "date"],ScalarType "boolean"),
    ("<=",[ScalarType "timestamp with time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("<=",[ScalarType "integer",ScalarType "smallint"],ScalarType "boolean"),
    ("<=",[ScalarType "smallint",ScalarType "integer"],ScalarType "boolean"),
    ("<=",[ScalarType "tid",ScalarType "tid"],ScalarType "boolean"),
    ("<=",[ScalarType "time without time zone",ScalarType "time without time zone"],ScalarType "boolean"),
    ("<=",[ScalarType "time with time zone",ScalarType "time with time zone"],ScalarType "boolean"),
    ("<=",[ScalarType "macaddr",ScalarType "macaddr"],ScalarType "boolean"),
    ("<=",[ScalarType "integer",ScalarType "integer"],ScalarType "boolean"),
    ("<=",[ScalarType "smallint",ScalarType "smallint"],ScalarType "boolean"),
    ("<=",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    ("<=",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "boolean"),
    ("<=",[ScalarType "real",ScalarType "double precision"],ScalarType "boolean"),
    ("<=",[ScalarType "bit",ScalarType "bit"],ScalarType "boolean"),
    ("<=",[ScalarType "double precision",ScalarType "real"],ScalarType "boolean"),
    ("<=",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("<=",[ScalarType "integer",ScalarType "bigint"],ScalarType "boolean"),
    ("<=",[ScalarType "uuid",ScalarType "uuid"],ScalarType "boolean"),
    ("<=",[ScalarType "lseg",ScalarType "lseg"],ScalarType "boolean"),
    ("<=",[ScalarType "timestamp with time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("<=",[ScalarType "numeric",ScalarType "numeric"],ScalarType "boolean"),
    ("<=",[ScalarType "real",ScalarType "real"],ScalarType "boolean"),
    ("<=",[ScalarType "bigint",ScalarType "integer"],ScalarType "boolean"),
    ("<=",[ScalarType "money",ScalarType "money"],ScalarType "boolean"),
    ("<=",[ScalarType "tsvector",ScalarType "tsvector"],ScalarType "boolean"),
    ("<=",[ScalarType "date",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("<=",[ScalarType "interval",ScalarType "interval"],ScalarType "boolean"),
    ("<=",[ScalarType "record",ScalarType "record"],ScalarType "boolean"),
    ("<=",[ScalarType "\"char\"",ScalarType "\"char\""],ScalarType "boolean"),
    ("<=",[ScalarType "path",ScalarType "path"],ScalarType "boolean"),
    ("<=",[ScalarType "double precision",ScalarType "double precision"],ScalarType "boolean"),
    ("<=",[ScalarType "timestamp without time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("<=",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("<=",[ScalarType "name",ScalarType "name"],ScalarType "boolean"),
    ("<=",[ScalarType "date",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("<=",[ScalarType "tinterval",ScalarType "tinterval"],ScalarType "boolean"),
    ("<=",[ScalarType "boolean",ScalarType "boolean"],ScalarType "boolean"),
    ("<=",[ScalarType "bigint",ScalarType "smallint"],ScalarType "boolean"),
    ("<>",[ScalarType "double precision",ScalarType "double precision"],ScalarType "boolean"),
    ("<>",[ScalarType "integer",ScalarType "integer"],ScalarType "boolean"),
    ("<>",[ScalarType "interval",ScalarType "interval"],ScalarType "boolean"),
    ("<>",[ScalarType "real",ScalarType "double precision"],ScalarType "boolean"),
    ("<>",[ScalarType "timestamp with time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("<>",[ScalarType "date",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("<>",[ScalarType "date",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("<>",[ScalarType "integer",ScalarType "smallint"],ScalarType "boolean"),
    ("<>",[ScalarType "name",ScalarType "name"],ScalarType "boolean"),
    ("<>",[ScalarType "time without time zone",ScalarType "time without time zone"],ScalarType "boolean"),
    ("<>",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    ("<>",[ScalarType "point",ScalarType "point"],ScalarType "boolean"),
    ("<>",[ScalarType "smallint",ScalarType "integer"],ScalarType "boolean"),
    ("<>",[ScalarType "timestamp with time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("<>",[ScalarType "tsvector",ScalarType "tsvector"],ScalarType "boolean"),
    ("<>",[ScalarType "time with time zone",ScalarType "time with time zone"],ScalarType "boolean"),
    ("<>",[ScalarType "timestamp without time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("<>",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("<>",[ScalarType "bigint",ScalarType "integer"],ScalarType "boolean"),
    ("<>",[ScalarType "smallint",ScalarType "smallint"],ScalarType "boolean"),
    ("<>",[ScalarType "record",ScalarType "record"],ScalarType "boolean"),
    ("<>",[ScalarType "money",ScalarType "money"],ScalarType "boolean"),
    ("<>",[ScalarType "oidvector",ScalarType "oidvector"],ScalarType "boolean"),
    ("<>",[ScalarType "bytea",ScalarType "bytea"],ScalarType "boolean"),
    ("<>",[ScalarType "bigint",ScalarType "bigint"],ScalarType "boolean"),
    ("<>",[ScalarType "double precision",ScalarType "real"],ScalarType "boolean"),
    ("<>",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "boolean"),
    ("<>",[ScalarType "numeric",ScalarType "numeric"],ScalarType "boolean"),
    ("<>",[ScalarType "lseg",ScalarType "lseg"],ScalarType "boolean"),
    ("<>",[ScalarType "bit",ScalarType "bit"],ScalarType "boolean"),
    ("<>",[ScalarType "oid",ScalarType "oid"],ScalarType "boolean"),
    ("<>",[ScalarType "integer",ScalarType "bigint"],ScalarType "boolean"),
    ("<>",[ScalarType "macaddr",ScalarType "macaddr"],ScalarType "boolean"),
    ("<>",[ScalarType "bigint",ScalarType "smallint"],ScalarType "boolean"),
    ("<>",[ScalarType "timestamp with time zone",ScalarType "date"],ScalarType "boolean"),
    ("<>",[ScalarType "\"char\"",ScalarType "\"char\""],ScalarType "boolean"),
    ("<>",[ScalarType "tid",ScalarType "tid"],ScalarType "boolean"),
    ("<>",[ScalarType "reltime",ScalarType "reltime"],ScalarType "boolean"),
    ("<>",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    ("<>",[ScalarType "uuid",ScalarType "uuid"],ScalarType "boolean"),
    ("<>",[ScalarType "smallint",ScalarType "bigint"],ScalarType "boolean"),
    ("<>",[ScalarType "boolean",ScalarType "boolean"],ScalarType "boolean"),
    ("<>",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("<>",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "boolean"),
    ("<>",[ScalarType "anyenum",ScalarType "anyenum"],ScalarType "boolean"),
    ("<>",[ScalarType "timestamp without time zone",ScalarType "date"],ScalarType "boolean"),
    ("<>",[ScalarType "timestamp without time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("<>",[ScalarType "abstime",ScalarType "abstime"],ScalarType "boolean"),
    ("<>",[ScalarType "date",ScalarType "date"],ScalarType "boolean"),
    ("<>",[ScalarType "tinterval",ScalarType "tinterval"],ScalarType "boolean"),
    ("<>",[ScalarType "real",ScalarType "real"],ScalarType "boolean"),
    ("<>",[ScalarType "bit varying",ScalarType "bit varying"],ScalarType "boolean"),
    ("<?>",[ScalarType "abstime",ScalarType "tinterval"],ScalarType "boolean"),
    ("<@",[ScalarType "point",ScalarType "line"],ScalarType "boolean"),
    ("<@",[ScalarType "point",ScalarType "path"],ScalarType "boolean"),
    ("<@",[ScalarType "point",ScalarType "box"],ScalarType "boolean"),
    ("<@",[ScalarType "lseg",ScalarType "line"],ScalarType "boolean"),
    ("<@",[ScalarType "point",ScalarType "lseg"],ScalarType "boolean"),
    ("<@",[ScalarType "lseg",ScalarType "box"],ScalarType "boolean"),
    ("<@",[ScalarType "point",ScalarType "circle"],ScalarType "boolean"),
    ("<@",[ScalarType "point",ScalarType "polygon"],ScalarType "boolean"),
    ("<@",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("<@",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("<@",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "boolean"),
    ("<@",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "boolean"),
    ("<@",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("<^",[ScalarType "point",ScalarType "point"],ScalarType "boolean"),
    ("<^",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("=",[ScalarType "integer",ScalarType "bigint"],ScalarType "boolean"),
    ("=",[ScalarType "boolean",ScalarType "boolean"],ScalarType "boolean"),
    ("=",[ScalarType "\"char\"",ScalarType "\"char\""],ScalarType "boolean"),
    ("=",[ScalarType "name",ScalarType "name"],ScalarType "boolean"),
    ("=",[ScalarType "smallint",ScalarType "smallint"],ScalarType "boolean"),
    ("=",[ScalarType "integer",ScalarType "integer"],ScalarType "boolean"),
    ("=",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("=",[ScalarType "xid",ScalarType "xid"],ScalarType "boolean"),
    ("=",[ScalarType "xid",ScalarType "integer"],ScalarType "boolean"),
    ("=",[ScalarType "cid",ScalarType "cid"],ScalarType "boolean"),
    ("=",[ScalarType "int2vector",ScalarType "int2vector"],ScalarType "boolean"),
    ("=",[ScalarType "tid",ScalarType "tid"],ScalarType "boolean"),
    ("=",[ScalarType "bigint",ScalarType "bigint"],ScalarType "boolean"),
    ("=",[ScalarType "bigint",ScalarType "integer"],ScalarType "boolean"),
    ("=",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("=",[ScalarType "smallint",ScalarType "integer"],ScalarType "boolean"),
    ("=",[ScalarType "integer",ScalarType "smallint"],ScalarType "boolean"),
    ("=",[ScalarType "abstime",ScalarType "abstime"],ScalarType "boolean"),
    ("=",[ScalarType "reltime",ScalarType "reltime"],ScalarType "boolean"),
    ("=",[ScalarType "oid",ScalarType "oid"],ScalarType "boolean"),
    ("=",[ScalarType "oidvector",ScalarType "oidvector"],ScalarType "boolean"),
    ("=",[ScalarType "real",ScalarType "real"],ScalarType "boolean"),
    ("=",[ScalarType "double precision",ScalarType "double precision"],ScalarType "boolean"),
    ("=",[ScalarType "path",ScalarType "path"],ScalarType "boolean"),
    ("=",[ScalarType "tinterval",ScalarType "tinterval"],ScalarType "boolean"),
    ("=",[ScalarType "money",ScalarType "money"],ScalarType "boolean"),
    ("=",[ScalarType "aclitem",ScalarType "aclitem"],ScalarType "boolean"),
    ("=",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    ("=",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "boolean"),
    ("=",[ScalarType "date",ScalarType "date"],ScalarType "boolean"),
    ("=",[ScalarType "time without time zone",ScalarType "time without time zone"],ScalarType "boolean"),
    ("=",[ScalarType "time with time zone",ScalarType "time with time zone"],ScalarType "boolean"),
    ("=",[ScalarType "real",ScalarType "double precision"],ScalarType "boolean"),
    ("=",[ScalarType "double precision",ScalarType "real"],ScalarType "boolean"),
    ("=",[ScalarType "timestamp with time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("=",[ScalarType "interval",ScalarType "interval"],ScalarType "boolean"),
    ("=",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("=",[ScalarType "lseg",ScalarType "lseg"],ScalarType "boolean"),
    ("=",[ScalarType "line",ScalarType "line"],ScalarType "boolean"),
    ("=",[ScalarType "macaddr",ScalarType "macaddr"],ScalarType "boolean"),
    ("=",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    ("=",[ScalarType "numeric",ScalarType "numeric"],ScalarType "boolean"),
    ("=",[ScalarType "bit",ScalarType "bit"],ScalarType "boolean"),
    ("=",[ScalarType "bit varying",ScalarType "bit varying"],ScalarType "boolean"),
    ("=",[ScalarType "smallint",ScalarType "bigint"],ScalarType "boolean"),
    ("=",[ScalarType "bigint",ScalarType "smallint"],ScalarType "boolean"),
    ("=",[ScalarType "bytea",ScalarType "bytea"],ScalarType "boolean"),
    ("=",[ScalarType "timestamp without time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("=",[ScalarType "date",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("=",[ScalarType "date",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("=",[ScalarType "timestamp without time zone",ScalarType "date"],ScalarType "boolean"),
    ("=",[ScalarType "timestamp with time zone",ScalarType "date"],ScalarType "boolean"),
    ("=",[ScalarType "timestamp without time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    ("=",[ScalarType "timestamp with time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    ("=",[ScalarType "uuid",ScalarType "uuid"],ScalarType "boolean"),
    ("=",[ScalarType "anyenum",ScalarType "anyenum"],ScalarType "boolean"),
    ("=",[ScalarType "tsvector",ScalarType "tsvector"],ScalarType "boolean"),
    ("=",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "boolean"),
    ("=",[ScalarType "record",ScalarType "record"],ScalarType "boolean"),
    (">",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    (">",[ScalarType "bigint",ScalarType "smallint"],ScalarType "boolean"),
    (">",[ScalarType "money",ScalarType "money"],ScalarType "boolean"),
    (">",[ScalarType "reltime",ScalarType "reltime"],ScalarType "boolean"),
    (">",[ScalarType "timestamp with time zone",ScalarType "date"],ScalarType "boolean"),
    (">",[ScalarType "tsvector",ScalarType "tsvector"],ScalarType "boolean"),
    (">",[ScalarType "tinterval",ScalarType "tinterval"],ScalarType "boolean"),
    (">",[ScalarType "date",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    (">",[ScalarType "boolean",ScalarType "boolean"],ScalarType "boolean"),
    (">",[ScalarType "uuid",ScalarType "uuid"],ScalarType "boolean"),
    (">",[ScalarType "oid",ScalarType "oid"],ScalarType "boolean"),
    (">",[ScalarType "anyenum",ScalarType "anyenum"],ScalarType "boolean"),
    (">",[ScalarType "bigint",ScalarType "integer"],ScalarType "boolean"),
    (">",[ScalarType "name",ScalarType "name"],ScalarType "boolean"),
    (">",[ScalarType "timestamp without time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    (">",[ScalarType "smallint",ScalarType "smallint"],ScalarType "boolean"),
    (">",[ScalarType "macaddr",ScalarType "macaddr"],ScalarType "boolean"),
    (">",[ScalarType "path",ScalarType "path"],ScalarType "boolean"),
    (">",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    (">",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "boolean"),
    (">",[ScalarType "double precision",ScalarType "double precision"],ScalarType "boolean"),
    (">",[ScalarType "bigint",ScalarType "bigint"],ScalarType "boolean"),
    (">",[ScalarType "integer",ScalarType "smallint"],ScalarType "boolean"),
    (">",[ScalarType "bytea",ScalarType "bytea"],ScalarType "boolean"),
    (">",[ScalarType "bit",ScalarType "bit"],ScalarType "boolean"),
    (">",[ScalarType "record",ScalarType "record"],ScalarType "boolean"),
    (">",[ScalarType "double precision",ScalarType "real"],ScalarType "boolean"),
    (">",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    (">",[ScalarType "timestamp with time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    (">",[ScalarType "lseg",ScalarType "lseg"],ScalarType "boolean"),
    (">",[ScalarType "real",ScalarType "double precision"],ScalarType "boolean"),
    (">",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    (">",[ScalarType "timestamp without time zone",ScalarType "date"],ScalarType "boolean"),
    (">",[ScalarType "tid",ScalarType "tid"],ScalarType "boolean"),
    (">",[ScalarType "time with time zone",ScalarType "time with time zone"],ScalarType "boolean"),
    (">",[ScalarType "interval",ScalarType "interval"],ScalarType "boolean"),
    (">",[ScalarType "time without time zone",ScalarType "time without time zone"],ScalarType "boolean"),
    (">",[ScalarType "integer",ScalarType "integer"],ScalarType "boolean"),
    (">",[ScalarType "integer",ScalarType "bigint"],ScalarType "boolean"),
    (">",[ScalarType "date",ScalarType "date"],ScalarType "boolean"),
    (">",[ScalarType "timestamp with time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    (">",[ScalarType "bit varying",ScalarType "bit varying"],ScalarType "boolean"),
    (">",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "boolean"),
    (">",[ScalarType "numeric",ScalarType "numeric"],ScalarType "boolean"),
    (">",[ScalarType "smallint",ScalarType "integer"],ScalarType "boolean"),
    (">",[ScalarType "oidvector",ScalarType "oidvector"],ScalarType "boolean"),
    (">",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    (">",[ScalarType "real",ScalarType "real"],ScalarType "boolean"),
    (">",[ScalarType "smallint",ScalarType "bigint"],ScalarType "boolean"),
    (">",[ScalarType "date",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    (">",[ScalarType "abstime",ScalarType "abstime"],ScalarType "boolean"),
    (">",[ScalarType "timestamp without time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    (">",[ScalarType "\"char\"",ScalarType "\"char\""],ScalarType "boolean"),
    (">=",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    (">=",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    (">=",[ScalarType "interval",ScalarType "interval"],ScalarType "boolean"),
    (">=",[ScalarType "timestamp with time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    (">=",[ScalarType "numeric",ScalarType "numeric"],ScalarType "boolean"),
    (">=",[ScalarType "macaddr",ScalarType "macaddr"],ScalarType "boolean"),
    (">=",[ScalarType "double precision",ScalarType "real"],ScalarType "boolean"),
    (">=",[ScalarType "bit",ScalarType "bit"],ScalarType "boolean"),
    (">=",[ScalarType "real",ScalarType "double precision"],ScalarType "boolean"),
    (">=",[ScalarType "time with time zone",ScalarType "time with time zone"],ScalarType "boolean"),
    (">=",[ScalarType "lseg",ScalarType "lseg"],ScalarType "boolean"),
    (">=",[ScalarType "time without time zone",ScalarType "time without time zone"],ScalarType "boolean"),
    (">=",[ScalarType "date",ScalarType "date"],ScalarType "boolean"),
    (">=",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "boolean"),
    (">=",[ScalarType "bit varying",ScalarType "bit varying"],ScalarType "boolean"),
    (">=",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    (">=",[ScalarType "smallint",ScalarType "bigint"],ScalarType "boolean"),
    (">=",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "boolean"),
    (">=",[ScalarType "money",ScalarType "money"],ScalarType "boolean"),
    (">=",[ScalarType "bigint",ScalarType "smallint"],ScalarType "boolean"),
    (">=",[ScalarType "tinterval",ScalarType "tinterval"],ScalarType "boolean"),
    (">=",[ScalarType "tsvector",ScalarType "tsvector"],ScalarType "boolean"),
    (">=",[ScalarType "tid",ScalarType "tid"],ScalarType "boolean"),
    (">=",[ScalarType "path",ScalarType "path"],ScalarType "boolean"),
    (">=",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    (">=",[ScalarType "bytea",ScalarType "bytea"],ScalarType "boolean"),
    (">=",[ScalarType "double precision",ScalarType "double precision"],ScalarType "boolean"),
    (">=",[ScalarType "bigint",ScalarType "bigint"],ScalarType "boolean"),
    (">=",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    (">=",[ScalarType "timestamp without time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    (">=",[ScalarType "name",ScalarType "name"],ScalarType "boolean"),
    (">=",[ScalarType "anyenum",ScalarType "anyenum"],ScalarType "boolean"),
    (">=",[ScalarType "bigint",ScalarType "integer"],ScalarType "boolean"),
    (">=",[ScalarType "integer",ScalarType "bigint"],ScalarType "boolean"),
    (">=",[ScalarType "uuid",ScalarType "uuid"],ScalarType "boolean"),
    (">=",[ScalarType "date",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    (">=",[ScalarType "\"char\"",ScalarType "\"char\""],ScalarType "boolean"),
    (">=",[ScalarType "real",ScalarType "real"],ScalarType "boolean"),
    (">=",[ScalarType "date",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    (">=",[ScalarType "oidvector",ScalarType "oidvector"],ScalarType "boolean"),
    (">=",[ScalarType "boolean",ScalarType "boolean"],ScalarType "boolean"),
    (">=",[ScalarType "timestamp without time zone",ScalarType "date"],ScalarType "boolean"),
    (">=",[ScalarType "oid",ScalarType "oid"],ScalarType "boolean"),
    (">=",[ScalarType "timestamp with time zone",ScalarType "date"],ScalarType "boolean"),
    (">=",[ScalarType "reltime",ScalarType "reltime"],ScalarType "boolean"),
    (">=",[ScalarType "abstime",ScalarType "abstime"],ScalarType "boolean"),
    (">=",[ScalarType "timestamp without time zone",ScalarType "timestamp with time zone"],ScalarType "boolean"),
    (">=",[ScalarType "integer",ScalarType "smallint"],ScalarType "boolean"),
    (">=",[ScalarType "smallint",ScalarType "integer"],ScalarType "boolean"),
    (">=",[ScalarType "record",ScalarType "record"],ScalarType "boolean"),
    (">=",[ScalarType "timestamp with time zone",ScalarType "timestamp without time zone"],ScalarType "boolean"),
    (">=",[ScalarType "integer",ScalarType "integer"],ScalarType "boolean"),
    (">=",[ScalarType "smallint",ScalarType "smallint"],ScalarType "boolean"),
    (">>",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    (">>",[ScalarType "bigint",ScalarType "integer"],ScalarType "bigint"),
    (">>",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    (">>",[ScalarType "smallint",ScalarType "integer"],ScalarType "smallint"),
    (">>",[ScalarType "point",ScalarType "point"],ScalarType "boolean"),
    (">>",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    (">>",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    (">>",[ScalarType "bit",ScalarType "integer"],ScalarType "bit"),
    (">>",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    (">>=",[ScalarType "inet",ScalarType "inet"],ScalarType "boolean"),
    (">^",[ScalarType "point",ScalarType "point"],ScalarType "boolean"),
    (">^",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("?#",[ScalarType "lseg",ScalarType "line"],ScalarType "boolean"),
    ("?#",[ScalarType "line",ScalarType "box"],ScalarType "boolean"),
    ("?#",[ScalarType "path",ScalarType "path"],ScalarType "boolean"),
    ("?#",[ScalarType "line",ScalarType "line"],ScalarType "boolean"),
    ("?#",[ScalarType "lseg",ScalarType "box"],ScalarType "boolean"),
    ("?#",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("?#",[ScalarType "lseg",ScalarType "lseg"],ScalarType "boolean"),
    ("?-",[ScalarType "point",ScalarType "point"],ScalarType "boolean"),
    ("?-|",[ScalarType "lseg",ScalarType "lseg"],ScalarType "boolean"),
    ("?-|",[ScalarType "line",ScalarType "line"],ScalarType "boolean"),
    ("?|",[ScalarType "point",ScalarType "point"],ScalarType "boolean"),
    ("?||",[ScalarType "line",ScalarType "line"],ScalarType "boolean"),
    ("?||",[ScalarType "lseg",ScalarType "lseg"],ScalarType "boolean"),
    -- ("@",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    -- ("@",[ScalarType "point",ScalarType "box"],ScalarType "boolean"),
    -- ("@",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    -- ("@",[ScalarType "point",ScalarType "path"],ScalarType "boolean"),
    -- ("@",[ScalarType "point",ScalarType "line"],ScalarType "boolean"),
    -- ("@",[ScalarType "point",ScalarType "circle"],ScalarType "boolean"),
    -- ("@",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    -- ("@",[ScalarType "lseg",ScalarType "box"],ScalarType "boolean"),
    -- ("@",[ScalarType "lseg",ScalarType "line"],ScalarType "boolean"),
    -- ("@",[ScalarType "point",ScalarType "polygon"],ScalarType "boolean"),
    -- ("@",[ScalarType "point",ScalarType "lseg"],ScalarType "boolean"),
    ("@>",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "boolean"),
    ("@>",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("@>",[ScalarType "aclitem[]",ScalarType "aclitem"],ScalarType "boolean"),
    ("@>",[ScalarType "circle",ScalarType "point"],ScalarType "boolean"),
    ("@>",[ScalarType "polygon",ScalarType "point"],ScalarType "boolean"),
    ("@>",[ScalarType "path",ScalarType "point"],ScalarType "boolean"),
    ("@>",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "boolean"),
    ("@>",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("@>",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("@@",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("@@",[ScalarType "tsquery",ScalarType "tsvector"],ScalarType "boolean"),
    ("@@",[ScalarType "text",ScalarType "tsquery"],ScalarType "boolean"),
    ("@@",[ScalarType "tsvector",ScalarType "tsquery"],ScalarType "boolean"),
    ("@@@",[ScalarType "tsvector",ScalarType "tsquery"],ScalarType "boolean"),
    ("@@@",[ScalarType "tsquery",ScalarType "tsvector"],ScalarType "boolean"),
    ("^",[ScalarType "double precision",ScalarType "double precision"],ScalarType "double precision"),
    ("^",[ScalarType "numeric",ScalarType "numeric"],ScalarType "numeric"),
    ("|",[ScalarType "bigint",ScalarType "bigint"],ScalarType "bigint"),
    ("|",[ScalarType "integer",ScalarType "integer"],ScalarType "integer"),
    ("|",[ScalarType "bit",ScalarType "bit"],ScalarType "bit"),
    ("|",[ScalarType "inet",ScalarType "inet"],ScalarType "inet"),
    ("|",[ScalarType "smallint",ScalarType "smallint"],ScalarType "smallint"),
    ("|&>",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("|&>",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("|&>",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("|>>",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("|>>",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("|>>",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("||",[ScalarType "tsvector",ScalarType "tsvector"],ScalarType "tsvector"),
    ("||",[ScalarType "text",ScalarType "anynonarray"],ScalarType "text"),
    ("||",[ScalarType "anynonarray",ScalarType "text"],ScalarType "text"),
    ("||",[ScalarType "tsquery",ScalarType "tsquery"],ScalarType "tsquery"),
    ("||",[ScalarType "anyarray",ScalarType "anyarray"],ScalarType "anyarray"),
    ("||",[ScalarType "bit varying",ScalarType "bit varying"],ScalarType "bit varying"),
    ("||",[ScalarType "anyelement",ScalarType "anyarray"],ScalarType "anyarray"),
    ("||",[ScalarType "text",ScalarType "text"],ScalarType "text"),
    ("||",[ScalarType "anyarray",ScalarType "anyelement"],ScalarType "anyarray"),
    ("||",[ScalarType "bytea",ScalarType "bytea"],ScalarType "bytea"),
    ("~",[ScalarType "character",ScalarType "text"],ScalarType "boolean"),
    ("~",[ScalarType "circle",ScalarType "point"],ScalarType "boolean"),
    ("~",[ScalarType "polygon",ScalarType "point"],ScalarType "boolean"),
    ("~",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("~",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("~",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("~",[ScalarType "aclitem[]",ScalarType "aclitem"],ScalarType "boolean"),
    ("~",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("~",[ScalarType "path",ScalarType "point"],ScalarType "boolean"),
    ("~",[ScalarType "name",ScalarType "text"],ScalarType "boolean"),
    ("~*",[ScalarType "name",ScalarType "text"],ScalarType "boolean"),
    ("~*",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("~*",[ScalarType "character",ScalarType "text"],ScalarType "boolean"),
    ("~<=~",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    ("~<=~",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("~<~",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("~<~",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    ("~=",[ScalarType "tinterval",ScalarType "tinterval"],ScalarType "boolean"),
    ("~=",[ScalarType "circle",ScalarType "circle"],ScalarType "boolean"),
    ("~=",[ScalarType "point",ScalarType "point"],ScalarType "boolean"),
    ("~=",[ScalarType "polygon",ScalarType "polygon"],ScalarType "boolean"),
    ("~=",[ScalarType "box",ScalarType "box"],ScalarType "boolean"),
    ("~>=~",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("~>=~",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    ("~>~",[ScalarType "character",ScalarType "character"],ScalarType "boolean"),
    ("~>~",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("~~",[ScalarType "character",ScalarType "text"],ScalarType "boolean"),
    ("~~",[ScalarType "text",ScalarType "text"],ScalarType "boolean"),
    ("~~",[ScalarType "name",ScalarType "text"],ScalarType "boolean"),
    ("~~",[ScalarType "bytea",ScalarType "bytea"],ScalarType "boolean"),
    ("~~*",[ScalarType "name",ScalarType "text"],ScalarType "boolean"),
    ("~~*",[ScalarType "character",ScalarType "text"],ScalarType "boolean"),
    ("~~*",[ScalarType "text",ScalarType "text"],ScalarType "boolean")
    ]
prefixOperatorTypes = [
    ("!!",[ScalarType "tsquery"],ScalarType "tsquery"),
    ("!!",[ScalarType "bigint"],ScalarType "numeric"),
    ("#",[ScalarType "polygon"],ScalarType "integer"),
    ("#",[ScalarType "path"],ScalarType "integer"),
    ("+",[ScalarType "double precision"],ScalarType "double precision"),
    ("+",[ScalarType "integer"],ScalarType "integer"),
    ("+",[ScalarType "real"],ScalarType "real"),
    ("+",[ScalarType "smallint"],ScalarType "smallint"),
    ("+",[ScalarType "bigint"],ScalarType "bigint"),
    ("+",[ScalarType "numeric"],ScalarType "numeric"),
    ("-",[ScalarType "smallint"],ScalarType "smallint"),
    ("-",[ScalarType "bigint"],ScalarType "bigint"),
    ("-",[ScalarType "integer"],ScalarType "integer"),
    ("-",[ScalarType "real"],ScalarType "real"),
    ("-",[ScalarType "double precision"],ScalarType "double precision"),
    ("-",[ScalarType "interval"],ScalarType "interval"),
    ("-",[ScalarType "numeric"],ScalarType "numeric"),
    ("?-",[ScalarType "lseg"],ScalarType "boolean"),
    ("?-",[ScalarType "line"],ScalarType "boolean"),
    ("?|",[ScalarType "line"],ScalarType "boolean"),
    ("?|",[ScalarType "lseg"],ScalarType "boolean"),
    ("@",[ScalarType "numeric"],ScalarType "numeric"),
    ("@",[ScalarType "smallint"],ScalarType "smallint"),
    ("@",[ScalarType "real"],ScalarType "real"),
    ("@",[ScalarType "bigint"],ScalarType "bigint"),
    ("@",[ScalarType "integer"],ScalarType "integer"),
    ("@",[ScalarType "double precision"],ScalarType "double precision"),
    ("@-@",[ScalarType "path"],ScalarType "double precision"),
    ("@-@",[ScalarType "lseg"],ScalarType "double precision"),
    ("@@",[ScalarType "box"],ScalarType "point"),
    ("@@",[ScalarType "circle"],ScalarType "point"),
    ("@@",[ScalarType "lseg"],ScalarType "point"),
    ("@@",[ScalarType "path"],ScalarType "point"),
    ("@@",[ScalarType "polygon"],ScalarType "point"),
    ("|",[ScalarType "tinterval"],ScalarType "abstime"),
    ("|/",[ScalarType "double precision"],ScalarType "double precision"),
    ("||/",[ScalarType "double precision"],ScalarType "double precision"),
    ("~",[ScalarType "integer"],ScalarType "integer"),
    ("~",[ScalarType "smallint"],ScalarType "smallint"),
    ("~",[ScalarType "bit"],ScalarType "bit"),
    ("~",[ScalarType "bigint"],ScalarType "bigint"),
    ("~",[ScalarType "inet"],ScalarType "inet")
    ]
postfixOperatorTypes = [
    ("!",[ScalarType "bigint"],ScalarType "numeric")
    ]

allOpsAndFns = binaryOperatorTypes ++ prefixOperatorTypes ++ postfixOperatorTypes

keywordBinaryOperatorTypes = [
 (And, [ScalarType "boolean", ScalarType "boolean"], ScalarType "boolean"),
 (Or, [ScalarType "boolean", ScalarType "boolean"], ScalarType "boolean"),
 (Like, [ScalarType "text", ScalarType "text"], ScalarType "boolean")]
keywordUnaryOperatorTypes = [
 (Not, [ScalarType "boolean"], ScalarType "boolean"),
 (IsNull, [ScalarType "any"], ScalarType "boolean"),
 (IsNotNull, [ScalarType "any"], ScalarType "boolean")]

allKeywordOps = keywordBinaryOperatorTypes ++ keywordUnaryOperatorTypes

}

{-

todo:
basic operator lookup
overloading tests
wrong name
wrong args
add implicit cast tests
determining type of token by context for int, float and string tokens
 (need a wide selection of tests for string tokens for various types)
row ctor implicitly and explicitly cast to a composite type

== simple operators
-}

ATTR KeywordOperator
  [
  |
  | val : SELF
  ]

ATTR FunName
  [
  |
  | val : SELF
  ]
{-
ATA FunName | SimpleFun String
             | Operator String
             | KOperator KeywordOperator
             | ArrayCtor
             | RowCtor
             | ArraySub
             | Substring
             | Between
               --add not between, overlay, any, etc.

DATA KeywordOperator | And | Or | Not
                     | IsNull | IsNotNull
                     | Like
-}

SEM Expression
    | FunCall lhs.nodeType =
        case @funName.val of
          ArrayCtor -> ct AllSameType1Any
                         (RetTypeFun (\t -> ArrayType $ head t))
          Substring -> ct
                         (ExactList [ScalarType "text"
                                    ,ScalarType "integer"
                                    ,ScalarType "integer"])
                         (ConstRetType (ScalarType "text"))
          Between -> ct
                         (AllSameTypeNumAny 3)
                         (ConstRetType (ScalarType "boolean"))
          ArraySub -> ct
                         (ExactPredList
                           [ArgCheck isArrayType NotArrayType
                           ,exactType (ScalarType "integer")])
                         (RetTypeFun (\t -> typeFromArray $ head t))
          Operator s -> lookupFn s (typesFromTypeList @args.nodeType)
          KOperator k -> lookupKop k (typesFromTypeList @args.nodeType)
          SimpleFun f -> lookupFn f (typesFromTypeList @args.nodeType)
          _ -> UnknownType
        where
          ct = checkTypes @lhs.sourcePos @args.nodeType
          lookupFn s1 args = let s = (if s1 == "u-" then "-" else s1)
                                 cands = filter (\(o,a,_) ->
                                                   (o,a) == (s,args))
                                           allOpsAndFns
                             in case () of
                                 _ | length cands == 0 -> TypeError @lhs.sourcePos (NoMatchingOperator s args)
                                   | length cands == 1 -> let (_,_,rettype) = (head cands)
                                                          in rettype
                                   | otherwise -> TypeError @lhs.sourcePos (MultipleMatchingOperators s args)
          lookupKop s args = let cands = filter (\(o,a,_) ->
                                                   (o,a) == (s,args))
                                           allKeywordOps
                             in case () of
                                 _ | length cands == 0 -> TypeError @lhs.sourcePos (NoMatchingKOperator s args)
                                   | length cands == 1 -> let (_,_,rettype) = (head cands)
                                                          in rettype
                                   | otherwise -> TypeError @lhs.sourcePos (MultipleMatchingKOperators s args)

{-
== case expression
check the when expressions are boolean
inside the pairs, then just propagate the then type

-}

SEM CaseExpressionListExpressionPair
    | Tuple lhs.nodeType = checkTypes
                             @lhs.sourcePos
                             @x1.nodeType
                             (AllSameType $ ScalarType "boolean")
                             (ConstRetType @x2.nodeType)

SEM Expression
    | Case lhs.nodeType = checkTypes
                             @lhs.sourcePos
                             (case @els.nodeType of
                                AnyElement -> @cases.nodeType
                                e -> TypeList
                                       ((typesFromTypeList @cases.nodeType)
                                        ++ [e]))
                             AllSameTypeAny
                             (RetTypeAsArgN 0)

{-


================================================================================

Non attribute grammar stuff

-}
-- use to use record syntax to try to insulate code from field
-- changes, and not have to write out loads of nothings and [] for
-- simple selects, but don't know how to use haskell named records
-- from uuagc code
--makeSelect :: Statement
--makeSelect = Select Dupes (SelectList [SelExp (Identifier "*")] [])
--                    Nothing Nothing [] Nothing [] Asc Nothing Nothing

{-

================================================================================

= checkAst

Main function to run on asts, returns a list of errors, warnings, etc.

-}
{
checkAst :: StatementList -> [Message]
checkAst sts = let t = sem_Root (Root sts)
               in (messages_Syn_Root (wrap_Root t Inh_Root))
{-
================================================================================

= Types

== getExpressionType

Gets the type of an expression

-}

getExpressionType :: Expression -> Type
getExpressionType ex = let t = sem_ExpressionRoot (ExpressionRoot ex)
                       in (nodeType_Syn_ExpressionRoot
                           (wrap_ExpressionRoot t Inh_ExpressionRoot))


--hack job, often not interested in the source positions when testing
--the asts produced, so this function will reset all the source
--positions to empty ("", 0, 0)

resetSps :: [Statement] -> [Statement]
resetSps sts = map resetSp sts

resetSp :: Statement -> Statement
resetSp (CreateFunction l n p r bq b v) = (CreateFunction l n p r bq
                                              (case b of
                                                SqlFnBody stss -> SqlFnBody (map resetSp' stss)
                                                PlpgsqlFnBody vd stss -> PlpgsqlFnBody vd (map resetSp' stss))
                                            v)
resetSp (ForSelectStatement v s stss) = ForSelectStatement v s (map resetSp' stss)
resetSp (ForIntegerStatement v f t stss) = ForIntegerStatement v f t (map resetSp' stss)
resetSp (CaseStatement v cs els) = CaseStatement v (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp (If cs els) = If (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp a = a

resetSp' :: SourcePosStatement -> SourcePosStatement
resetSp' (_,st) = (nsp,resetSp st)

resetSps' :: StatementList -> StatementList
resetSps' sts = map resetSp' sts

nsp :: MySourcePos
nsp = ("", 0,0)
}

{-

containment guide for select expressions:
combineselect 2 selects
insert ?select
createtableas 1 select
createview 1 select
return query 1 select
forselect 1 select
select->subselect select
expression->exists select
            scalarsubquery select
            inselect select

containment guide for statements:
forselect [statement]
forinteger [statement]
while [statement]
casestatement [[statement]]
if [[statement]]
createfunction->fnbody [Statement]

TODO

some non type-check checks:
check plpgsql only in plpgsql function
do all containment checks above
orderby in top level select only
copy followed immediately by copydata iff stdin, copydata only follows
copy from stdin
args to raise, etc, same number as placeholders in string
natural with correct join types
no natural with onexpr in joins
constraint column ref checks?
typename -> setof (& fix parsing), what else like this?
expressions: positionalarg in function, window function only in select
 list top level

review all ast checks, and see if we can also catch them during
parsing (e.g. typeName parses setof, but this should only be allowed
for a function return, and we can make this a parse error when parsing
from source code rather than checking a generated ast. This needs
judgement to say whether a parse error is better than a check error, I
think for setof it is, but e.g. for a continue not in a loop (which
could be caught during parsing) works better as a check error, looking
at the error message the user will get. This might be wrong, haven't
thought too carefully about it yet).

Type checking

(Have no idea what I am doing, just going to try to bluff it, then
learn how to do it properly later)

Create a algebraic data type to represent types.

Add a type called Unknown which always passes. Add this to everything
by default - now all code type checks and we can add proper type
checking piecemeal.

Start with tables, and then simple select * from table, select a,b from table.
Then maybe do some simple expressions.

Add separate function to return the inferred types of statementlists/
expressions, etc., so the checkAst checks the types are consistent,
and them have something like getStatementType, getStatementsType,
getExpressionType (which works for selects and relation valued
expressions as well as scalars, tuples, etc).


TODO: canonicalize ast process, as part of type checking produces a canonicalized ast which:
all casts are explicit
all names fully qualified
all types use canonical names
literal values and selectors in one form (use row style?)
what else?

Canonical form only defined for type consistent asts.

This canonical form should pretty print and parse back to the same
form, and type check correctly.

-}
