{-
Copyright 2009 Jake Wheat

This file contains the ast nodes, which aren't brilliantly designed.
It uses the Utrecht University Attribute Grammar system:

http://www.cs.uu.nl/wiki/bin/view/HUT/AttributeGrammarSystem
http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter

The attr and sem definitions are in TypeChecking.ag, which is included
into this file

There is very limited source position information in the ast at the
moment.

These ast nodes a are both used as the result of successful parsing,
and as the input to the pretty printer.

Lots of invalid sql is currently allowed if you construct the asts in
code, the parser isn't quite as lenient, but still can parse and not
complain about a lot of invalid sql.

use

uuagc -dcfws Ast.ag

to generate a new Ast.hs from this file

(install uuagc with
cabal install uuagc
)

Tip: after you've compiled this file with the above command, you can
get loads of warnings from ghc if you're the sort who enables
these. Using haskell-mode from emacs usually results in compiles being
really slow just cos emacs outputs all these warnings _really_ slowly,
and also any real warnings and errors can get drowned out. You can get
rid of these warnings by ghc compiling the produced Ast.hs on the
command line:
ghc -c TypeType.lhs FnTypes.hs PGTypes.hs Ast.hs

does the job, you can then compile from emacs and it will use the .o
file and you won't get any warnings about generated code in Ast.hs (if
the .o file gets stale, ghc / haskell mode will do the right thing and
ignore it, but it can't tell if the Ast.hs has gotten stale wrt
Ast.ag)
-}

MODULE {Ast}
{
    -- exports
    MySourcePos

    --ast nodes
   ,Statement (..)
   ,SelectExpression (..)
   ,FnBody (..)
   ,SetClause (..)
   ,TableRef (..)
   ,JoinExpression (..)
   ,JoinType (..)
   ,SelectList (..)
   ,SelectItem (..)
   ,CopySource (..)
   ,AttributeDef (..)
   ,RowConstraint (..)
   ,Constraint (..)
   ,TypeAttributeDef (..)
   ,ParamDef (..)
   ,VarDef (..)
   ,RaiseType (..)
   ,CombineType (..)
   ,Volatility (..)
   ,Language (..)
   ,TypeName (..)
   ,DropType (..)
   ,Cascade (..)
   ,Direction (..)
   ,Distinct (..)
   ,Natural (..)
   ,IfExists (..)
   ,RestartIdentity (..)
   ,Expression (..)
   ,FunName (..)
   ,KeywordOperator(..)
   ,OperatorType (..)
   ,getOperatorType
   ,InList (..)
   ,StatementList
   --checking stuff
   ,Message (..)
   ,MessageStuff (..)
   --types
   ,Type (..)
   ,PseudoType (..)
   ,TypeErrorInfo (..)
   ,Scope(..)
   ,defaultScope
   ,emptyScope
   --fns
   ,checkAst
   ,getExpressionType
   ,getStatementsType
   ,resetSps
   ,resetSp
   ,resetSp'
   ,resetSps'
   ,nsp
   ,typeSmallInt
   ,typeBigInt
   ,typeInt
   ,typeNumeric
   ,typeFloat4
   ,typeFloat8
   ,typeVarChar
   ,typeChar
   ,typeBool

}
{
import Data.Maybe
import Data.List
import Debug.Trace
import qualified Data.Map as M

import TypeType
import AstUtils
import Scope
import DefaultScope

}

{-
================================================================================

SQL top level statements

everything is chucked in here, in particular this means that many places where
a select can appear inside another statement (e.g. a subselect), you can
instead put any statement - this type checks but is totally invalid.

-}

DATA Statement

--queries

    | SelectStatement ex:SelectExpression

-- dml

    --table targetcolumns insertdata(values or select statement) returning
    | Insert table : String
             targetCols : StringList
             insData : SelectExpression
             returning : (Maybe SelectList)
    --tablename setitems where returning
    | Update table : String
             assigns : SetClauseList
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename, where, returning
    | Delete table : String
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename column names, from
    | Copy table : String
           targetCols : StringList
           source : CopySource
    --represents inline data for copy statement
    | CopyData insData : String
    | Truncate tables: StringList
               restartIdentity : RestartIdentity
               cascade : Cascade

-- ddl

    | CreateTable name : String
                  atts : AttributeDefList
                  cons : ConstraintList
    | CreateTableAs name : String
                    expr : SelectExpression
    | CreateView name : String
                 expr : SelectExpression
    | CreateType name : String
                 atts : TypeAttributeDefList
    -- language name args rettype bodyquoteused body vol
    | CreateFunction lang : Language
                     name : String
                     params : ParamDefList
                     rettype : TypeName
                     bodyQuote : String
                     body : FnBody
                     vol : Volatility
    -- name type checkexpression
    | CreateDomain name : String
                   typ : TypeName
                   check : (Maybe Expression)
    -- ifexists (name,argtypes)* cascadeorrestrict
    | DropFunction ifE : IfExists
                   sigs : StringStringListPairList
                   cascade : Cascade
    -- ifexists names cascadeorrestrict
    | DropSomething dropType : DropType
                    ifE : IfExists
                    names : StringList
                    cascade : Cascade
    | Assignment target : String
                 value : Expression
    | Return value : (Maybe Expression)
    | ReturnNext expr : Expression
    | ReturnQuery sel : SelectExpression
    | Raise level : RaiseType
            message : String
            args : ExpressionList
    | NullStatement
    | Perform expr : Expression
    | Execute expr : Expression
    | ExecuteInto expr : Expression
                  targets : StringList
    | ForSelectStatement var : String
                         sel : SelectExpression
                         sts : StatementList
    | ForIntegerStatement var : String
                          from : Expression
                          to : Expression
                          sts : StatementList
    | WhileStatement expr : Expression
                     sts : StatementList
    | ContinueStatement
    --variable, list of when parts, else part
    | CaseStatement val : Expression
                    cases : ExpressionListStatementListPairList
                    els : StatementList
    --list is
    --first if (condition, statements):elseifs(condition, statements)
    --last bit is else statements
    | If cases : ExpressionStatementListPairList
         els : StatementList

-- =============================================================================

--Statement components

-- maybe this should be called relation valued expression?
DATA SelectExpression
    | Select selDistinct : Distinct
             selSelectList : SelectList
             selTref : MTableRef
             selWhere : (Maybe Expression)
             selGroupBy : ExpressionList
             selHaving : (Maybe Expression)
             selOrderBy : ExpressionList
             selDir : Direction
             selLimit : (Maybe Expression)
             selOffset : (Maybe Expression)
    | CombineSelect ctype : CombineType
                    sel1 : SelectExpression
                    sel2 : SelectExpression
    | Values vll:ExpressionListList

TYPE MTableRef = MAYBE TableRef

DATA FnBody | SqlFnBody sts : StatementList
            | PlpgsqlFnBody VarDefList sts : StatementList

DATA SetClause | SetClause String Expression | RowSetClause StringList ExpressionList

DATA TableRef | Tref String
              | TrefAlias tref : String
                          alias : String
              | JoinedTref tref : TableRef
                           nat : Natural
                           joinType : JoinType
                           jtref : TableRef
                           onExpr : (Maybe JoinExpression)
              | SubTref sel : SelectExpression alias : String
              | TrefFun Expression
              | TrefFunAlias Expression String

DATA JoinExpression | JoinOn Expression | JoinUsing StringList

DATA JoinType | Inner | LeftOuter| RightOuter | FullOuter | Cross

-- select columns, into columns

DATA SelectList | SelectList items:SelectItemList StringList

DATA SelectItem | SelExp ex:Expression
                | SelectItem ex:Expression name:String

DATA CopySource | CopyFilename String | Stdin

--name type default null constraint

DATA AttributeDef | AttributeDef name : String
                                 typ : TypeName
                                 check : (Maybe Expression)
                                 cons : RowConstraintList

--Constraints which appear attached to an individual field

DATA RowConstraint | NullConstraint
                   | NotNullConstraint
                   | RowCheckConstraint Expression
                   | RowUniqueConstraint
                   | RowPrimaryKeyConstraint
                   | RowReferenceConstraint table : String
                                            att : (Maybe String)
                                            onUpdate : Cascade
                                            onDelete : Cascade

--constraints which appear on a separate row in the create table

DATA Constraint | UniqueConstraint StringList
                | PrimaryKeyConstraint StringList
                | CheckConstraint Expression
                  -- sourcecols targettable targetcols ondelete onupdate
                | ReferenceConstraint atts : StringList
                                      table : String
                                      tableAtts : StringList
                                      onUpdate : Cascade
                                      onDelete : Cascade

DATA TypeAttributeDef | TypeAttDef name : String
                                   typ : TypeName

DATA ParamDef | ParamDef String TypeName
              | ParamDefTp TypeName

DATA VarDef | VarDef name : String
                     typ : TypeName
                     value : (Maybe Expression)

DATA RaiseType | RNotice | RException | RError

DATA CombineType | Except | Union | Intersect | UnionAll

DATA Volatility | Volatile | Stable | Immutable

DATA Language | Sql | Plpgsql

DATA TypeName | SimpleTypeName tn:String
              | PrecTypeName tn:String prec:Integer
              | ArrayTypeName typ:TypeName
              | SetOfTypeName typ:TypeName

DATA DropType | Table
              | Domain
              | View
              | Type

DATA Cascade | Cascade | Restrict

DATA Direction | Asc | Desc

DATA Distinct | Distinct | Dupes

DATA Natural | Natural | Unnatural

DATA IfExists | Require | IfExists

DATA RestartIdentity | RestartIdentity | ContinueIdentity

{-
================================================================================

Expressions

Similarly to the statement type, all expressions
are chucked into one even though there are many restrictions
on which expressions can appear in different places.
Maybe this should be called scalar expression?
-}
DATA Expression | IntegerLit Integer
                | FloatLit Double
                | StringLit quote : String
                            value : String
                | NullLit
                | BooleanLit Bool
                | PositionalArg Integer
                | Cast expr:Expression tn:TypeName
                | Identifier i:String
                | Case cases : CaseExpressionListExpressionPairList
                       els : MaybeExpression
                | Exists sel : SelectExpression
                | FunCall funName:FunName args:ExpressionList
                | InPredicate Expression Bool InList
                  -- windowfn selectitem partitionby orderby orderbyasc?
                | WindowFn fn : Expression
                           partitionBy : ExpressionList
                           orderBy : ExpressionList
                           dir : Direction
                | ScalarSubQuery sel : SelectExpression

TYPE MaybeExpression = MAYBE Expression

{-

list of expression flavours from postgresql with this ast equivs
constant/literal               integerlit, floatlit, stringlit, nulllit, boollit
column reference               identifier
positional parameter reference   positionalarg
subscripted expression            fun arraysub
field selection expression        identifier
operator invocation               fun op
function call                     fun simple
aggregate expression              ?
window function call              windowfn
type cast                         cast
scalar subquery                   scalarsubquery
array constructor                 fun arrayval
row constructor                   fun rowctor

TODO: think about having separate parse tree which the parser produces,
and a proper set of ast types with no pollution from concrete syntax
or parsing considerations


Anything that is represented in the ast as some sort of name plus a
list of expressions as arguments is treated as the same type of node:
FunCall.

This includes
symbol operators
regular function calls
keyword operators e.g. and, like (ones which can be parsed as normal
  syntactic operators)
unusual syntax operators, e.g. between
unusual syntax function calls e.g. substring(x from 5 for 3)
arrayctors e.g. array[3,5,6]
rowctors e.g. ROW (2,4,6)
array subscripting

All of these could be considered concrete syntax variants of function
calls, which take none, one or more expressions as arguments, and
return a single expression as the result.

Divide them up into different flavours (corresponding to the FunName
algebraic data type constructors), the flavour divisions are guided
only by what the pretty printer needs to work (maybe this is a bit
inelegant):
all regular function calls like [name](args,...) are SimpleFuns
all regular operators (symbols, regular prefix,infix and postfix) are
  treated the same
arrayctors, rowctors, array subscript are each given their own ctor
all the standard keyword operators (prefix, infix and postfix) are
  given their own ctor
each unusual syntax keyword operator is given its own ctor
each unusual syntax function call is given its own ctor

keyword operators (regular prefix, infix and postfix):
and, or, not
is null, is not null, isnull, notnull
is distinct from, is not distinct from
is true, is not true,is false, is not false, is unknown, is not unknown
like, not like, ilike, not ilike
similar to, not similar to
in, not in (don't include these here since the argument isn't always an expr)

unusual syntax operators and fn calls
between, not between, between symmetric
overlay, substring, trim
any, some, all

-}


DATA FunName | SimpleFun String
             | Operator String
             | KOperator KeywordOperator
             | ArrayCtor
             | RowCtor
             | ArraySub
             | Substring
             | Between
               --add not between, overlay, any, etc.

DATA InList | InList ExpressionList | InSelect sel : SelectExpression

-- some list nodes, not sure if all of these are needed as separately
-- named node types

TYPE ExpressionList = [Expression]
TYPE ExpressionListList = [ExpressionList]
TYPE StringList = [String]
TYPE SetClauseList = [SetClause]
TYPE AttributeDefList = [AttributeDef]
TYPE ConstraintList = [Constraint]
TYPE TypeAttributeDefList = [TypeAttributeDef]
TYPE ParamDefList = [ParamDef]
TYPE StringStringListPair = (String,StringList)
TYPE StringStringListPairList = [StringStringListPair]
TYPE ExpressionListStatementListPair = (ExpressionList,StatementList)
TYPE ExpressionListStatementListPairList = [ExpressionListStatementListPair]
TYPE ExpressionStatementListPair = (Expression, StatementList)
TYPE ExpressionStatementListPairList = [ExpressionStatementListPair]
TYPE VarDefList = [VarDef]
TYPE SelectItemList = [SelectItem]
TYPE RowConstraintList = [RowConstraint]
TYPE CaseExpressionListExpressionPair = (CaseExpressionList,Expression)
TYPE CaseExpressionList = [Expression]
TYPE CaseExpressionListExpressionPairList = [CaseExpressionListExpressionPair]

-- slightly hacky, add the source positions only in statement lists
-- this includes top level statements, and statements inside createfunction,
-- and nested inside if, while, case statements, and the like, but
-- unfortunately not select expressions inside other
-- expressions/statements

TYPE SourcePosStatement = (MySourcePos, Statement)
TYPE StatementList = [SourcePosStatement]



-- Add a root data type so we can put initial values for inherited
-- attributes in the section which defines and uses those attributes
-- rather than in the sem_ calls

DATA Root | Root statements:StatementList
DERIVING Root: Show

DATA ExpressionRoot | ExpressionRoot expr:Expression
DERIVING ExpressionRoot: Show

{-
================================================================================

=some basic bookkeeping

attributes which every node has
-}

SET AllNodes = Statement SelectExpression FnBody SetClause TableRef JoinExpression JoinType
               SelectList SelectItem CopySource AttributeDef RowConstraint
               Constraint TypeAttributeDef ParamDef VarDef RaiseType
               CombineType Volatility Language TypeName DropType Cascade
               Direction Distinct Natural IfExists RestartIdentity
               Expression InList MaybeExpression
               ExpressionList ExpressionListList StringList SetClauseList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList StringStringListPair StringStringListPairList
               StatementList ExpressionListStatementListPair
               ExpressionListStatementListPairList ExpressionStatementListPair
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList CaseExpressionListExpressionPair
               CaseExpressionListExpressionPairList CaseExpressionList
               SourcePosStatement FunName MTableRef


SET NonListNodes = Statement SelectExpression FnBody SetClause TableRef JoinExpression JoinType
               SelectItem CopySource AttributeDef RowConstraint
               Constraint TypeAttributeDef ParamDef VarDef RaiseType
               CombineType Volatility Language TypeName DropType Cascade
               Direction Distinct Natural IfExists RestartIdentity
               Expression InList MaybeExpression
               StringStringListPair ExpressionListStatementListPair
               ExpressionStatementListPair
               CaseExpressionListExpressionPair
               SourcePosStatement FunName


SET ListNodes = SelectList ExpressionList ExpressionListList StringList
                SetClauseList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList StringStringListPairList
               StatementList
               ExpressionListStatementListPairList
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList
               CaseExpressionListExpressionPairList CaseExpressionList

DERIVING AllNodes: Show,Eq

INCLUDE "TypeChecking.ag"

{-

================================================================================

used to use record syntax to try to insulate code from field changes,
and not have to write out loads of nothings and [] for simple selects,
but don't know how to create haskell named records from uuagc DATA
things

makeSelect :: Statement
makeSelect = Select Dupes (SelectList [SelExp (Identifier "*")] [])
                   Nothing Nothing [] Nothing [] Asc Nothing Nothing


================================================================================

= checkAst

test function to run on asts, returns a list of errors, warnings, etc.

-}
{
checkAst :: StatementList -> [Message]
checkAst sts = let t = sem_Root (Root sts)
               in (messages_Syn_Root (wrap_Root t Inh_Root {scope_Inh_Root = defaultScope}))
{-
================================================================================

= Types

-}

getExpressionType :: Scope -> Expression -> Type
getExpressionType scope ex =
    let t = sem_ExpressionRoot (ExpressionRoot ex)
    in (nodeType_Syn_ExpressionRoot
        (wrap_ExpressionRoot t Inh_ExpressionRoot {scope_Inh_ExpressionRoot = combineScopes defaultScope scope}))


getStatementsType :: StatementList -> [Type]
getStatementsType st = let t = sem_Root (Root st)
                           tl = (nodeType_Syn_Root
                                 (wrap_Root t Inh_Root {scope_Inh_Root = defaultScope}))
                       in typesFromTypeList tl


--hack job, often not interested in the source positions when testing
--the asts produced, so this function will reset all the source
--positions to empty ("", 0, 0)

resetSps :: [Statement] -> [Statement]
resetSps sts = map resetSp sts

resetSp :: Statement -> Statement
resetSp (CreateFunction l n p r bq b v) = (CreateFunction l n p r bq
                                              (case b of
                                                SqlFnBody stss -> SqlFnBody (map resetSp' stss)
                                                PlpgsqlFnBody vd stss -> PlpgsqlFnBody vd (map resetSp' stss))
                                            v)
resetSp (ForSelectStatement v s stss) = ForSelectStatement v s (map resetSp' stss)
resetSp (ForIntegerStatement v f t stss) = ForIntegerStatement v f t (map resetSp' stss)
resetSp (CaseStatement v cs els) = CaseStatement v (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp (If cs els) = If (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp a = a

resetSp' :: SourcePosStatement -> SourcePosStatement
resetSp' (_,st) = (nsp,resetSp st)

resetSps' :: StatementList -> StatementList
resetSps' sts = map resetSp' sts

nsp :: MySourcePos
nsp = ("", 0,0)
}
