{-
Copyright 2009 Jake Wheat

This file contains the ast nodes, which aren't brilliantly designed,
and the attribute grammar system which uses the Utrecht University
Attribute Grammar system:

http://www.cs.uu.nl/wiki/bin/view/HUT/AttributeGrammarSystem
http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter

There are no source positions in the ast at the moment. The grammar
system is intended to act a as type checker, and to do other static
checks for the time being, which is a work in progress and in a very
early state.

These ast nodes a are both used as the result of successful parsing,
and as the input to the pretty printer.

Lots of invalid sql is currently allowed if you construct the asts in
code, the parser isn't quite as lenient, but still can parse and not
complain about a lot of invalid sql.

use

uuagc -dcfws Ast.ag

to generate a new Ast.hs from this file

(install uuagc with
cabal install uuagc
)

Tip: after you've compiled this file with the above command, you can
get loads of warnings from ghc if you're the sort who enables
these. Using haskell-mode from emacs usually results in compiles being
really slow just cos emacs outputs all these warnings _really_ slowly,
and also any real warnings and errors can get drowned out. You can get
rid of these warnings by ghc compiling the produced Ast.hs on the
command line:
ghc -c Ast.hs

does the job, you can then compile from emacs and it will use the .o
file and you won't get any warnings about generated code in Ast.hs (if
the .o file gets stale, ghc / haskell mode will do the right thing and
ignore it, but it can't tell if the Ast.hs has gotten stale wrt
Ast.ag)
-}

MODULE {Ast}
{} -- exports
{} -- imports

{-
================================================================================

SQL top level statements

everything is chucked in here, in particular this means that many places where
a select can appear inside another statement (e.g. a subselect), you can
instead put any statement - this type checks but is totally invalid.

> -- | Statement represents a single sql or plpgsql statement.

-}

TYPE MySourcePos = (String, Int, Int)

DATA Statement

--queries

    | SelectStatement SelectExpression

-- dml

    --table targetcolumns insertdata(values or select statement) returning
    | Insert table : String
             targetCols : StringList
             insData : SelectExpression
             returning : (Maybe SelectList)
    --tablename setitems where returning
    | Update table : String
             assigns : SetClauseList
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename, where, returning
    | Delete table : String
             whr : (Maybe Expression)
             returning : (Maybe SelectList)
    --tablename column names, from
    | Copy table : String
           targetCols : StringList
           source : CopySource
    --represents inline data for copy statement
    | CopyData insData : String
    | Truncate tables: StringList
               restartIdentity : RestartIdentity
               cascade : Cascade

-- ddl

    | CreateTable name : String
                  atts : AttributeDefList
                  cons : ConstraintList
    | CreateTableAs name : String
                    expr : SelectExpression
    | CreateView name : String
                 expr : SelectExpression
    | CreateType name : String
                 atts : TypeAttributeDefList
    -- language name args rettype bodyquoteused body vol
    | CreateFunction lang : Language
                     name : String
                     params : ParamDefList
                     rettype : TypeName
                     bodyQuote : String
                     body : FnBody
                     vol : Volatility
    -- name type checkexpression
    | CreateDomain name : String
                   typ : TypeName
                   check : (Maybe Expression)
    -- ifexists (name,argtypes)* cascadeorrestrict
    | DropFunction ifE : IfExists
                   sigs : StringStringListPairList
                   cascade : Cascade
    -- ifexists names cascadeorrestrict
    | DropSomething dropType : DropType
                    ifE : IfExists
                    names : StringList
                    cascade : Cascade
    | Assignment target : String
                 value : Expression
    | Return value : (Maybe Expression)
    | ReturnNext expr : Expression
    | ReturnQuery sel : SelectExpression
    | Raise level : RaiseType
            message : String
            args : ExpressionList
    | NullStatement
    | Perform expr : Expression
    | Execute expr : Expression
    | ExecuteInto expr : Expression
                  targets : StringList
    | ForSelectStatement var : String
                         sel : SelectExpression
                         sts : StatementList
    | ForIntegerStatement var : String
                          from : Expression
                          to : Expression
                          sts : StatementList
    | WhileStatement expr : Expression
                     sts : StatementList
    | ContinueStatement
    --variable, list of when parts, else part
    | CaseStatement val : Expression
                    cases : ExpressionListStatementListPairList
                    els : StatementList
    --list is
    --first if (condition, statements):elseifs(condition, statements)
    --last bit is else statements
    | If cases : ExpressionStatementListPairList
         els : StatementList

-- =============================================================================

--Statement components

-- maybe this should be called relation valued expression?
DATA SelectExpression
    | Select selDistinct : Distinct
             selSelectList : SelectList
             selTref : (Maybe TableRef)
             selWhere : (Maybe Expression)
             selGroupBy : ExpressionList
             selHaving : (Maybe Expression)
             selOrderBy : ExpressionList
             selDir : Direction
             selLimit : (Maybe Expression)
             selOffset : (Maybe Expression)
    | CombineSelect ctype : CombineType
                    sel1 : SelectExpression
                    sel2 : SelectExpression
    | Values ExpressionListList

DATA FnBody | SqlFnBody sts : StatementList
            | PlpgsqlFnBody VarDefList sts : StatementList

DATA SetClause | SetClause String Expression | RowSetClause StringList ExpressionList

DATA TableRef | Tref String
              | TrefAlias tref : String
                          alias : String
              | JoinedTref tref : TableRef
                           nat : Natural
                           joinType : JoinType
                           jtref : TableRef
                           onExpr : (Maybe JoinExpression)
              | SubTref sel : SelectExpression alias : String
              | TrefFun Expression
              | TrefFunAlias Expression String

DATA JoinExpression | JoinOn Expression | JoinUsing StringList

DATA JoinType | Inner | LeftOuter| RightOuter | FullOuter | Cross

-- select columns, into columns

DATA SelectList | SelectList SelectItemList StringList

DATA SelectItem | SelExp Expression
                | SelectItem Expression String

DATA CopySource | CopyFilename String | Stdin

--name type default null constraint

DATA AttributeDef | AttributeDef name : String
                                 typ : TypeName
                                 check : (Maybe Expression)
                                 cons : RowConstraintList

--Constraints which appear attached to an individual field

DATA RowConstraint | NullConstraint
                   | NotNullConstraint
                   | RowCheckConstraint Expression
                   | RowUniqueConstraint
                   | RowPrimaryKeyConstraint
                   | RowReferenceConstraint table : String
                                            att : (Maybe String)
                                            onUpdate : Cascade
                                            onDelete : Cascade

--constraints which appear on a separate row in the create table

DATA Constraint | UniqueConstraint StringList
                | PrimaryKeyConstraint StringList
                | CheckConstraint Expression
                  -- sourcecols targettable targetcols ondelete onupdate
                | ReferenceConstraint atts : StringList
                                      table : String
                                      tableAtts : StringList
                                      onUpdate : Cascade
                                      onDelete : Cascade

DATA TypeAttributeDef | TypeAttDef name : String
                                   typ : TypeName

DATA ParamDef | ParamDef String TypeName
              | ParamDefTp TypeName

DATA VarDef | VarDef name : String
                     typ : TypeName
                     value : (Maybe Expression)

DATA RaiseType | RNotice | RException | RError

DATA CombineType | Except | Union | Intersect | UnionAll

DATA Volatility | Volatile | Stable | Immutable

DATA Language | Sql | Plpgsql

DATA TypeName | SimpleTypeName String
              | PrecTypeName String Integer
              | ArrayTypeName TypeName
              | SetOfTypeName TypeName

DATA DropType | Table
         | Domain
         | View
         | Type

DATA Cascade | Cascade | Restrict

DATA Direction | Asc | Desc

DATA Distinct | Distinct | Dupes

DATA Natural | Natural | Unnatural

DATA IfExists | Require | IfExists

DATA RestartIdentity | RestartIdentity | ContinueIdentity

{-
================================================================================

Expressions

Similarly to the statement type, all expressions
are chucked into one even though there are many restrictions
on which expressions can appear in different places.
Maybe this should be called scalar expression?
-}
DATA Expression | IntegerLit Integer
                | FloatLit Double
                | StringLit quote : String
                            value : String
                | NullLit
                | BooleanLit Bool
                | PositionalArg Integer
                | CastOp Expression TypeName
                | CastKeyword Expression TypeName
                | Identifier String
                | Case cases : CaseExpressionListExpressionPairList
                       els : MaybeExpression
                | Exists sel : SelectExpression
                | FunCall funName:FunName args:ExpressionList
                | InPredicate Expression Bool InList
                  -- windowfn selectitem partitionby orderby orderbyasc?
                | WindowFn fn : Expression
                           partitionBy : ExpressionList
                           orderBy : ExpressionList
                           dir : Direction
                | ScalarSubQuery sel : SelectExpression

TYPE MaybeExpression = MAYBE Expression

-- we need information possibly for the lexer and parser for the
-- pretty printer, and type information (including num arguments, type
-- constraints on these, and the type of the result), also need
-- operator precedence and associativity for binary operators
-- some of this information is spread out over the code
-- variantions for funcalls include:
-- normal pg function call
-- unusual syntax function calls (e.g. substring from for)
-- unusual syntax operators (e.g. between x and y)
-- row ctor
-- array selector
-- unary and binary operators (both text and symbol)
-- array subscripting

DATA FunName | SimpleFun String
             | Operator String
             | ArrayVal
             | RowCtor
             | ArraySub
             | Substring
             | Between

DATA OperatorType | BinaryOp | LeftUnary | RightUnary

{
getOperatorType :: String -> OperatorType
getOperatorType s = case () of
                      _ | s `elem` ["not", "@", "u-"] -> LeftUnary
                        | s `elem` ["is null", "is not null"] -> RightUnary
                        | s `elem` ["+", "-", "*", "/","^",
                                    "%","=","and","or","||",
                                    "like","<>","<",">",
                                    "<=",">=","<->"] -> BinaryOp
                        | otherwise -> error $ "don't know flavour of operator " ++ s
}


DATA InList | InList ExpressionList | InSelect sel : SelectExpression

-- some list nodes, not sure if all of these are needed as separately
-- named node types

TYPE ExpressionList = [Expression]
TYPE ExpressionListList = [ExpressionList]
TYPE StringList = [String]
TYPE SetClauseList = [SetClause]
TYPE AttributeDefList = [AttributeDef]
TYPE ConstraintList = [Constraint]
TYPE TypeAttributeDefList = [TypeAttributeDef]
TYPE ParamDefList = [ParamDef]
TYPE StringStringListPair = (String,StringList)
TYPE StringStringListPairList = [StringStringListPair]
TYPE ExpressionListStatementListPair = (ExpressionList,StatementList)
TYPE ExpressionListStatementListPairList = [ExpressionListStatementListPair]
TYPE ExpressionStatementListPair = (Expression, StatementList)
TYPE ExpressionStatementListPairList = [ExpressionStatementListPair]
TYPE VarDefList = [VarDef]
TYPE SelectItemList = [SelectItem]
TYPE RowConstraintList = [RowConstraint]
TYPE CaseExpressionListExpressionPair = (CaseExpressionList,Expression)
TYPE CaseExpressionList = [Expression]
TYPE CaseExpressionListExpressionPairList = [CaseExpressionListExpressionPair]

-- slightly hacky, add the source positions only in statement lists
-- this includes top level statements, and statements inside createfunction,
-- and nested inside if, while, case statements, and the like, but
-- unfortunately not select expressions inside other
-- expressions/statements

TYPE SourcePosStatement = (MySourcePos, Statement)
TYPE StatementList = [SourcePosStatement]


{-
================================================================================
Error reporting
-}

DATA Message | Error MySourcePos MessageStuff
             | Warning MySourcePos MessageStuff
             | Notice MySourcePos MessageStuff

DATA MessageStuff | ContinueNotInLoop
                  | NonSelectInSelectExpression
                  | CustomMessage String

DERIVING Message MessageStuff: Eq
DERIVING MessageStuff: Show
{

instance Show Message where
   show m = showMessage m

showMessage :: Message -> [Char]
showMessage m = case m of
                  Error sp s -> showit "Error" sp s
                  Warning sp s -> showit "Warning" sp s
                  Notice sp s -> showit "Notice" sp s
                where
                  showit lev (fn,l,c) s = lev ++ "\n" ++ fn ++ ":"
                                          ++ show l ++ ":" ++ show c ++ ":\n"
                                          ++ show s ++ "\n"
}

-- Add a root data type so we can put initial values for inherited
-- attributes in the section which defines and uses those attributes
-- rather than in the sem_ calls

DATA Root | Root statements:StatementList
DERIVING Root: Show

DATA ExpressionRoot | ExpressionRoot expr:Expression
DERIVING ExpressionRoot: Show

{-
================================================================================

=some basic bookkeeping

attributes which every node has
-}

SET AllNodes = Statement SelectExpression FnBody SetClause TableRef JoinExpression JoinType
               SelectList SelectItem CopySource AttributeDef RowConstraint
               Constraint TypeAttributeDef ParamDef VarDef RaiseType
               CombineType Volatility Language TypeName DropType Cascade
               Direction Distinct Natural IfExists RestartIdentity
               Expression InList MaybeExpression
               ExpressionList ExpressionListList StringList SetClauseList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList StringStringListPair StringStringListPairList
               StatementList ExpressionListStatementListPair
               ExpressionListStatementListPairList ExpressionStatementListPair
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList CaseExpressionListExpressionPair
               CaseExpressionListExpressionPairList CaseExpressionList
               SourcePosStatement FunName


SET NonListNodes = Statement SelectExpression FnBody SetClause TableRef JoinExpression JoinType
               SelectItem CopySource AttributeDef RowConstraint
               Constraint TypeAttributeDef ParamDef VarDef RaiseType
               CombineType Volatility Language TypeName DropType Cascade
               Direction Distinct Natural IfExists RestartIdentity
               Expression InList MaybeExpression
               StringStringListPair ExpressionListStatementListPair
               ExpressionStatementListPair
               CaseExpressionListExpressionPair
               SourcePosStatement FunName


SET ListNodes = SelectList ExpressionList ExpressionListList StringList
                SetClauseList
               AttributeDefList ConstraintList TypeAttributeDefList
               ParamDefList StringStringListPairList
               StatementList
               ExpressionListStatementListPairList
               ExpressionStatementListPairList VarDefList SelectItemList
               RowConstraintList
               CaseExpressionListExpressionPairList CaseExpressionList

DERIVING AllNodes: Show,Eq

-- use this attr to lift the source pos value so we can access it
-- couldn't find a way just to read the value direct from the tuple in
-- the semantic bit...

ATTR MySourcePos
         [
         |
         | val : SELF
         ]

SEM SourcePosStatement
    | Tuple x2.sourcePos = @x1.val


{-

================================================================================

attribute descriptions:

sourcePos - holds the source position used in messages, not very
accurate at the moment, just gives you the position of the first
character in the current statement

messages - used to collect error messages, also to be used for
warnings (e.g. $1 position argument used when all args have aliases),
and notices - will probably use these to highlight dodgy sql
code and idioms.


-}

ATTR AllNodes
  [ sourcePos: MySourcePos
  |
  |
  ]

ATTR AllNodes Root ExpressionRoot
  [
  |
  | messages USE {++} {[]} : {[Message]}
  ]

SEM Root
  | Root statements.sourcePos = ("",0,0)

SEM ExpressionRoot
  | ExpressionRoot expr.sourcePos = ("",0,0)


{-

================================================================================

= static tests

Problem 1: can't have two sem statements for the same node type which
both add messages, and then the messages get combined to provide the
final message list attribute value for that node. Workaround is
instead of having each check in it's own section, to combine them all
into one SEM.

Problem 2: no shorthand to combine what the default rule for messages
would be and then add a bit extra - so if you want all the children
messages, plus possiby an extra message or two, have to write out the
default rule in full explicitly. Can get round this by writing out
loads of code.

Both the workarounds to these seem a bit tedious and error prone, and
will make the code much less readable. Maybe need a preprocessor to
produce the ag file?

================================================================================

= inloop testing

inloop - use to check continue, exit, and other commands that can only
appear inside loops (for, while, loop)

-}

ATTR AllNodes
  [ inLoop: Bool
  |
  |
  ]

SEM Root
  | Root statements.inLoop = False

SEM ExpressionRoot
  | ExpressionRoot expr.inLoop = False

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

SEM Statement
     | ForSelectStatement ForIntegerStatement WhileStatement sts.inLoop = True
     | CreateFunction body.inLoop = False

-- now we can check when we hit a continue statement if it is in the
-- right context
SEM Statement
    | ContinueStatement  lhs.messages = if not @lhs.inLoop
                                          then [Error @lhs.sourcePos ContinueNotInLoop]
                                          else []

{-
save this so i don't have to type it all out again
SEM Statement
    | SelectStatement CombineSelect Values Insert Update Delete Copy CopyData
      Truncate CreateTable CreateTableAs CreateView CreateType CreateFunction
      CreateDomain DropFunction DropSomething Assignment Return ReturnNext
      ReturnQuery Raise NullStatement Perform Execute ExecuteInto
      ForSelectStatement ForIntegerStatement WhileStatement
      ContinueStatement CaseStatement If-}

{-
================================================================================
Type checking
-}

DATA Type | ScalarType String
          | ArrayType Type
          | AnyArray
          | AnyElement
          | UnknownType
          | TypeList tps:{[Type]}
          | TypeError MySourcePos TypeErrorInfo

DATA TypeErrorInfo | WrongTypes expected:Type got:{[Type]}
                   | WrongTypeList expected:{[Type]} got:{[Type]}
                   | WrongNumArgs expected:Int got:Int

DERIVING Type TypeErrorInfo: Show,Eq

ATTR NonListNodes Root ExpressionRoot
  [
  |
  | nodeType USE {`setUnknown`} {UnknownType} : {Type}
  ]


ATTR ListNodes
  [
  |
  | nodeType USE {`appendTypeList`} {TypeList []} : {Type}
  ]


-- type checking utilities

{
setUnknown :: Type -> Type -> Type
setUnknown _ _ = UnknownType

appendTypeList :: Type -> Type -> Type
appendTypeList t1 (TypeList ts) = TypeList (t1:ts)
appendTypeList t1 t2 = TypeList (t1:t2:[])


--if the first argument is unknown or type error, pass it on
--otherwise use the second argument
propagateUnknownError :: Type -> Type -> Type
propagateUnknownError t t1 = case t of
                               a@(TypeError _ _) -> a
                               UnknownType -> UnknownType
                               _ -> t1
--list version, if you need to propagate two or more types when
--unknown or error
propagateUnknownErrors :: [Type] -> Type -> Type
propagateUnknownErrors ts t1 =
    let unks = filter (\t -> case t of
                               UnknownType -> True
                               _ -> False) ts
        errs = filter (\t -> case t of
                               TypeError _ _ -> True
                               _ -> False) ts
    in case () of
         _ | length errs > 0 -> head errs --should probably pass all of them forward
           | length unks > 0 -> UnknownType
           | otherwise -> t1

checkTypesAre :: Type -> MySourcePos -> [Type] -> Type
checkTypesAre typ sp l = propagateUnknownErrors l
                          (let bad = filter (\t -> t /= typ) l
                           in if length bad == 0
                                then typ
                                else TypeError sp (WrongTypes typ bad))

checkSameTypes :: MySourcePos -> [Type] -> Type
checkSameTypes sp l = propagateUnknownErrors l
                        (if length l == 0
                           then AnyElement
                           else checkTypesAre (head l) sp l)

checkSameTypesNum :: MySourcePos -> Int -> [Type] -> Type
checkSameTypesNum sp n l = propagateUnknownErrors l
                        (if length l /= n
                           then TypeError sp (WrongNumArgs n (length l))
                           else checkTypesAre (head l) sp l)


checkExactTypes :: MySourcePos -> [Type] -> [Type] -> Type
checkExactTypes sp ts es = propagateUnknownErrors es
                           (if ts /= es
                              then TypeError sp (WrongTypeList ts es)
                              else AnyElement)

typesFromTypeList :: Type -> [Type]
typesFromTypeList (TypeList ts) = ts
typesFromTypeList x = error $ "can't get types from list " ++ show x
}

SEM MaybeExpression
    | Just lhs.nodeType = @just.nodeType
    | Nothing lhs.nodeType = AnyElement
{-
== literals
-}

SEM Expression
     | IntegerLit lhs.nodeType = ScalarType "Integer"
     | StringLit lhs.nodeType = ScalarType "String"
     | FloatLit lhs.nodeType = ScalarType "Float"
     | BooleanLit lhs.nodeType = ScalarType "Boolean"

{-
== simple operators
-}

ATTR FunName
  [
  |
  | val : SELF
  ]

SEM Expression
    | FunCall lhs.nodeType = case @funName.val of
                               ArrayVal ->
                                       (let t = (checkSameTypes
                                                 @lhs.sourcePos
                                                 (typesFromTypeList @args.nodeType))
                                        in propagateUnknownError
                                            t
                                            (ArrayType t))
                               Substring ->
                                   propagateUnknownError
                                     (checkExactTypes
                                      @lhs.sourcePos
                                      [ScalarType "String"
                                      ,ScalarType "Integer"
                                      ,ScalarType "Integer"]
                                      (typesFromTypeList @args.nodeType))
                                     (ScalarType "String")
                               Between ->
                                   propagateUnknownError
                                     (checkSameTypesNum
                                      @lhs.sourcePos
                                      3
                                      (typesFromTypeList @args.nodeType))
                                     (ScalarType "Boolean")

                               Operator s ->
                                     (if s == "="
                                       then let t = (checkSameTypes
                                                     @lhs.sourcePos
                                                     (typesFromTypeList @args.nodeType))
                                            in propagateUnknownError
                                                 t
                                                 (ScalarType "Boolean")
                                       else UnknownType)
                               _ -> UnknownType


{-
== case expression
check the when expressions are boolean
inside the pairs, then just propagate the then type

-}

SEM CaseExpressionListExpressionPair
    | Tuple lhs.nodeType = propagateUnknownError
                             (checkTypesAre
                               (ScalarType "Boolean")
                               @lhs.sourcePos
                               (typesFromTypeList @x1.nodeType))
                             @x2.nodeType

SEM Expression
    | Case lhs.nodeType = propagateUnknownErrors (typesFromTypeList @cases.nodeType)
                            (checkSameTypes
                             @lhs.sourcePos
                             (case @els.nodeType of
                                AnyElement -> typesFromTypeList @cases.nodeType
                                e -> (typesFromTypeList @cases.nodeType) ++ [e]))


{-


================================================================================

Non attribute grammar stuff

-}
-- use to use record syntax to try to insulate code from field
-- changes, and not have to write out loads of nothings and [] for
-- simple selects, but don't know how to use haskell named records
-- from uuagc code
--makeSelect :: Statement
--makeSelect = Select Dupes (SelectList [SelExp (Identifier "*")] [])
--                    Nothing Nothing [] Nothing [] Asc Nothing Nothing

{-

================================================================================

= checkAst

Main function to run on asts, returns a list of errors, warnings, etc.

-}
{
checkAst :: StatementList -> [Message]
checkAst sts = let t = sem_Root (Root sts)
               in (messages_Syn_Root (wrap_Root t Inh_Root))
{-
================================================================================

= Types

== getExpressionType

Gets the type of an expression

-}

getExpressionType :: Expression -> Type
getExpressionType ex = let t = sem_ExpressionRoot (ExpressionRoot ex)
                       in (nodeType_Syn_ExpressionRoot
                           (wrap_ExpressionRoot t Inh_ExpressionRoot))


--hack job, often not interested in the source positions when testing
--the asts produced, so this function will reset all the source
--positions to empty ("", 0, 0)

resetSps :: [Statement] -> [Statement]
resetSps sts = map resetSp sts

resetSp :: Statement -> Statement
resetSp (CreateFunction l n p r bq b v) = (CreateFunction l n p r bq
                                              (case b of
                                                SqlFnBody stss -> SqlFnBody (map resetSp' stss)
                                                PlpgsqlFnBody vd stss -> PlpgsqlFnBody vd (map resetSp' stss))
                                            v)
resetSp (ForSelectStatement v s stss) = ForSelectStatement v s (map resetSp' stss)
resetSp (ForIntegerStatement v f t stss) = ForIntegerStatement v f t (map resetSp' stss)
resetSp (CaseStatement v cs els) = CaseStatement v (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp (If cs els) = If (map (\(el,st) -> (el,map resetSp' st)) cs) (map resetSp' els)
resetSp a = a

resetSp' :: SourcePosStatement -> SourcePosStatement
resetSp' (_,st) = (nsp,resetSp st)

resetSps' :: StatementList -> StatementList
resetSps' sts = map resetSp' sts

nsp :: MySourcePos
nsp = ("", 0,0)
}

{-

containment guide for statements:
combineselect 2 selects
insert ?select
createtableas 1 select
createview 1 select
return query 1 select
forselect 1 select, [statement]
forinteger [statement]
while [statement]
casestatement [[statement]]
if [[statement]]
createfunction->fnbody [Statement]
select->subselect select
expression->exists select
            scalarsubquery select
            inselect select

TODO

some non type-check checks:
check plpgsql only in plpgsql function
do all containment checks above
orderby in top level select only
copy followed immediately by copydata iff stdin, copydata only follows
copy from stdin
args to raise, etc, same number as placeholders in string
natural with correct join types
no natural with onexpr in joins
constraint column ref checks?
typename -> setof (& fix parsing), what else like this?
expressions: positionalarg in function, window function only in select
 list top level

review all ast checks, and see if we can also catch them during
parsing (e.g. typeName parses setof, but this should only be allowed
for a function return, and we can make this a parse error when parsing
from source code rather than checking a generated ast. This needs
judgement to say whether a parse error is better than a check error, I
think for setof it is, but e.g. for a continue not in a loop (which
could be caught during parsing) works better as a check error, looking
at the error message the user will get. This might be wrong, haven't
thought too carefully about it yet).

Type checking

(Have no idea what I am doing, just going to try to bluff it, then
learn how to do it properly later)

Create a algebraic data type to represent types.

Add a type called Unknown which always passes. Add this to everything
by default - now all code type checks and we can add proper type
checking piecemeal.

Start with tables, and then simple select * from table, select a,b from table.
Then maybe do some simple expressions.

Add separate function to return the inferred types of statementlists/
expressions, etc., so the checkAst checks the types are consistent,
and them have something like getStatementType, getStatementsType,
getExpressionType (which works for selects and relation valued
expressions as well as scalars, tuples, etc).

-}
