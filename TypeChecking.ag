{-
Copyright 2009 Jake Wheat

This file contains the attr and sem definitions, which do the type
checking, etc..

A lot of the haskell code has been moved into AstUtils.lhs, it is
intended that only small amounts of code appear (i.e. one-liners)
inline in this file, and larger bits go in AstUtils.lhs. These are
only divided because the attribute grammar system uses a custom syntax
with a custom preprocessor. These guidelines aren't followed very
well.

Dynamic note:

The current type checking approach doesn't quite match how SQL
works. The main problem is that you can e.g. exec create table
statements inside a function. This is something that the type checker
will probably not be able to deal for a while if ever. (Will need
hooks into postgresql to do this properly, which might not be
impossible...).

================================================================================

= main attributes used

Here are the main attributes used in the type checking:

sourcePos - holds the source position used in messages, not very
accurate at the moment, just gives you the position of the first
character in the current statement

actual value - add this to all nodes out of lazy programming. We use
these values in a limited number of places in the code

-}

ATTR AllNodes
  [ sourcePos: MySourcePos
  |
  |
  ]

ATTR AllNodes Root ExpressionRoot
  [ scope : Scope
  |
  | actualValue: SELF
  ]

{-

Node types

we set all the node types to unknown to start with, this allows the
type checking to be implemented bit by bit. When the type checking is
more complete, these might be removed or changed to something more
specific. The listnodes' behaviour is actually used by the working
typing checking code in places.

-}

ATTR NonListNodes Root ExpressionRoot
  [
  |
  | nodeType USE {`setUnknown`} {UnknownType} : {Type}
  ]

ATTR ListNodes
  [
  |
  | nodeType USE {`appendTypeList`} {TypeList []} : {Type}
  ]

{
setUnknown :: Type -> Type -> Type
setUnknown _ _ = UnknownType

appendTypeList :: Type -> Type -> Type
appendTypeList t1 (TypeList ts) = TypeList (t1:ts)
appendTypeList t1 t2 = TypeList [t1,t2]
}

{-

this bit goes with the default rules above, just a hack to get things
working, will probably disappear at some point.
-}
SEM MaybeExpression
    | Just lhs.nodeType = @just.nodeType
    | Nothing lhs.nodeType = TypeList []


{-

================================================================================

semantics for source positions

source positions aren't collected by the parser properly yet, so we
just get what's available and propagate that. All the type errors
should collect the source position information properly, so when it
appears in the ast nodes, we can hook it up here and the errors should
start giving accurate positions.

-}

SEM SourcePosStatement
    | Tuple x2.sourcePos = @x1

SEM Root
  | Root statements.sourcePos = ("",0,0)

SEM ExpressionRoot
  | ExpressionRoot expr.sourcePos = ("",0,0)

{-
================================================================================

= some basic typing

== type names

Types with type modifiers (called PrecTypeName here, to be changed),
are not supported at the moment.

-}

SEM TypeName
     | SimpleTypeName
          --this needs to work a bit better, a simpletypename can match
          --domains, composite types, etc., not just scalar types
          lhs.nodeType = lookupTypeByName @lhs.scope @lhs.sourcePos $ canonicalizeTypeName @tn

--              let st = canonicalizeType $ ScalarType @tn
--                         in checkErrors
--                                [checkTypeExists @lhs.scope @lhs.sourcePos st]
--                                st
--     | PrecTypeName
--          lhs.nodeType = if @tn `elem` defaultTypes
--                           then ScalarType @tn
--                           else TypeError @lhs.sourcePos
--                                  (UnknownTypeError @tn)
     | ArrayTypeName
          lhs.nodeType = let t = ArrayType @typ.nodeType
                         in checkErrors
                                [@typ.nodeType
                                ,checkTypeExists @lhs.scope @lhs.sourcePos t]
                                t
     | SetOfTypeName
          lhs.nodeType = checkErrors [@typ.nodeType]
                           (SetOfType @typ.nodeType)

{-
== literals
-}

SEM Expression
     | IntegerLit lhs.nodeType = typeInt
     | StringLit lhs.nodeType = UnknownStringLit
     | FloatLit lhs.nodeType = typeNumeric
     | BooleanLit lhs.nodeType = typeBool
     -- I think a null types like an unknown string lit
     | NullLit lhs.nodeType = UnknownStringLit



{-
================================================================================

= expressions

== cast expression

-}

SEM Expression
    | Cast lhs.nodeType = checkErrors [@expr.nodeType]
                            @tn.nodeType

{-
== operators and functions
-}

SEM Expression
    | FunCall lhs.nodeType =
        checkErrors [@args.nodeType] $
          typeCheckFunCall
            @lhs.scope
            @lhs.sourcePos
            @funName
            @args.nodeType

{-
== case expression

for non simple cases, we need all the when expressions to be bool, and
then to collect the types of the then parts to see if we can resolve a
common type

for simple cases, we need to check all the when parts have the same type
as the value to check against, then we collect the then parts as above.

so, the caseexpressionlistexpressionpair items each set their node
type to a typelist with two elements, the first is a typelist of the
when expressions, and the second is the type of the then
expression. These can then be checked appropriately in the case or
casesimple sem code.

-}

SEM Expression
    | Case lhs.nodeType =
        let elseThen =
                case @els.nodeType of
                  TypeList [] -> []
                  t -> [t]
            unwrappedLists = map unwrapTypeList $ unwrapTypeList @cases.nodeType
            whenTypes :: [Type]
            whenTypes = concat $ map unwrapTypeList $ map head unwrappedLists
            thenTypes :: [Type]
            thenTypes = map (head . tail) unwrappedLists ++ elseThen
            whensAllBool :: Type
            whensAllBool = if any (/= typeBool) whenTypes
                             then TypeError @lhs.sourcePos
                                      (WrongTypes typeBool whenTypes)
                             else TypeList []
        in checkErrors (whenTypes ++ thenTypes ++ [whensAllBool]) $
             resolveResultSetType
               @lhs.scope
               @lhs.sourcePos
               thenTypes

SEM Expression
    | CaseSimple lhs.nodeType =
        let elseThen =
                case @els.nodeType of
                  TypeList [] -> []
                  t -> [t]
            unwrappedLists = map unwrapTypeList $ unwrapTypeList @cases.nodeType
            whenTypes :: [Type]
            whenTypes = concat $ map unwrapTypeList $ map head unwrappedLists
            thenTypes :: [Type]
            thenTypes = map (head . tail) unwrappedLists ++ elseThen
            checkWhenTypes = resolveResultSetType
                               @lhs.scope
                               @lhs.sourcePos
                               (@value.nodeType:whenTypes)
        in checkErrors (whenTypes ++ thenTypes ++ [checkWhenTypes]) $
             resolveResultSetType
               @lhs.scope
               @lhs.sourcePos
               thenTypes


{-
== identifiers
pull id types out of scope for identifiers

-}

SEM Expression
    | Identifier lhs.nodeType =
                   let (correlationName,iden) = splitIdentifier @i
                   in scopeLookupID @lhs.scope @lhs.sourcePos correlationName iden

{
-- i think this should be alright, an identifier referenced in an
-- expression can only have zero or one dot in it.

splitIdentifier :: String -> (String,String)
splitIdentifier s = let (a,b) = span (/= '.') s
                    in if b == ""
                         then ("", a)
                         else (a,tail b)
}

SEM Expression
    | Exists lhs.nodeType = checkErrors [@sel.nodeType] typeBool

{-
================================================================================

= basic select statements

== nodeTypes

-}

SEM Statement
    | SelectStatement lhs.nodeType = @ex.nodeType

SEM SelectExpression
    --assume we get TypeList (TypeList (Type)) out of vll
    | Values lhs.nodeType =
        checkErrors [@vll.nodeType] $
                    typeCheckValuesExpr
                              @lhs.scope
                              @lhs.sourcePos
                              @vll.nodeType
    | Select
         lhs.nodeType = checkErrors
                          [@selTref.nodeType
                          ,@selSelectList.nodeType
                          ,@selWhere.nodeType]
                          (let t = @selSelectList.nodeType
                           in if t == UnnamedCompositeType [("?column?",Pseudo Void)]
                              then Pseudo Void
                              else SetOfType @selSelectList.nodeType)
    | CombineSelect lhs.nodeType =
        checkErrors [@sel1.nodeType,@sel2.nodeType] $
                    typeCheckCombineSelect
                              @lhs.scope
                              @lhs.sourcePos
                              @sel1.nodeType
                              @sel2.nodeType

SEM TableRef
    | SubTref lhs.nodeType = checkErrors [@sel.nodeType] $ unwrapSetOfComposite @sel.nodeType
              lhs.idens = [(@alias, (unwrapComposite $ unwrapSetOf @sel.nodeType, []))]
              lhs.joinIdens = []
    | TrefAlias Tref
        lhs.nodeType = fst $ getRelationType @lhs.scope @lhs.sourcePos @tbl
        lhs.joinIdens = []
    | Tref
        lhs.idens = [(@tbl, both unwrapComposite $ getRelationType @lhs.scope @lhs.sourcePos @tbl)]
    | TrefAlias
        lhs.idens = [(@alias, both unwrapComposite $ getRelationType @lhs.scope @lhs.sourcePos @tbl)]
    | TrefFun
        lhs.nodeType = getFnType @lhs.scope @lhs.sourcePos "" @fn.actualValue @fn.nodeType
        lhs.joinIdens = []
        lhs.idens = [second (\l -> (unwrapComposite l, [])) $ getFunIdens @lhs.scope @lhs.sourcePos "" @fn.actualValue @fn.nodeType]
    | TrefFunAlias
        lhs.nodeType = getFnType @lhs.scope @lhs.sourcePos @alias @fn.actualValue @fn.nodeType
        lhs.joinIdens = []
        lhs.idens = [second (\l -> (unwrapComposite l, [])) $ getFunIdens @lhs.scope @lhs.sourcePos @alias @fn.actualValue @fn.nodeType]
    | JoinedTref
        lhs.nodeType =
            checkErrors [@tbl.nodeType
                        ,@tbl1.nodeType]
                        ret
            where
              ret = case (@nat.actualValue, @onExpr.actualValue) of
                      (Natural, _) -> unionJoinList $ commonFieldNames
                                                        @tbl.nodeType
                                                        @tbl1.nodeType
                      (_,Just (JoinUsing s)) -> unionJoinList s
                      _ -> unionJoinList []
              unionJoinList s = combineTableTypesWithUsingList
                                  @lhs.scope
                                  @lhs.sourcePos
                                  s
                                  @tbl.nodeType
                                  @tbl1.nodeType
        lhs.idens = @tbl.idens ++ @tbl1.idens
        lhs.joinIdens = commonFieldNames @tbl.nodeType @tbl1.nodeType
{
--returns the type of the relation, and the system columns also
getRelationType :: Scope -> MySourcePos -> String -> (Type,Type)
getRelationType scope sp tbl =
          case getAttrs scope [TableComposite, ViewComposite] tbl of
            Just ((_,_,a@(UnnamedCompositeType _))
                 ,(_,_,s@(UnnamedCompositeType _)) ) -> (a,s)
            _ -> (TypeError sp (UnrecognisedRelation tbl), TypeList [])

getFnType :: Scope -> MySourcePos -> String -> Expression -> Type -> Type
getFnType scope sp alias fnVal fnType =
    checkErrors [fnType] $ snd $ getFunIdens scope sp alias fnVal fnType

getFunIdens :: Scope -> MySourcePos -> String -> Expression -> Type -> (String, Type)
getFunIdens scope sp alias fnVal fnType =
   case fnVal of
       FunCall f _ ->
           let correlationName = if alias /= ""
                                   then alias
                                   else f
           in (correlationName, case fnType of
                SetOfType (CompositeType t) -> getCompositeType t
                SetOfType x -> UnnamedCompositeType [(correlationName,x)]
                y -> UnnamedCompositeType [(correlationName,y)])
       x -> ("", TypeError sp (ContextError "FunCall"))
   where
     getCompositeType t =
                    case getAttrs scope [Composite
                                              ,TableComposite
                                              ,ViewComposite] t of
                      Just ((_,_,a@(UnnamedCompositeType _)), _) -> a
                      _ -> UnnamedCompositeType []

commonFieldNames t1 t2 =
    intersect (fn t1) (fn t2)
    where
      fn (UnnamedCompositeType s) = map fst s
      fn _ = []

both :: (a->b) -> (a,a) -> (b,b)
both fn (x,y) = (fn x, fn y)

}



SEM MTableRef
    | Nothing lhs.nodeType = TypeList []
              lhs.idens = []
              lhs.joinIdens = []
    | Just lhs.nodeType = @just.nodeType


SEM Where
    | Nothing lhs.nodeType = typeBool
    | Just lhs.nodeType =
        checkErrors
          [@just.nodeType]
          (if @just.nodeType /= typeBool
             then TypeError @lhs.sourcePos ExpressionMustBeBool
             else typeBool)

SEM SelectItem
    | SelExp SelectItem lhs.nodeType = @ex.nodeType

SEM SelectItemList
    | Cons lhs.nodeType =
        foldr consComposite @tl.nodeType
           (let (correlationName,iden) = splitIdentifier @hd.columnName
            in if iden == "*"
                then scopeExpandStar @lhs.scope @lhs.sourcePos correlationName
                else [(iden, @hd.nodeType)])
    | Nil lhs.nodeType = UnnamedCompositeType []

SEM SelectList
    | SelectList lhs.nodeType = @items.nodeType

{-

== scope passing

scope flow:
current simple version:
from tref -> select list
          -> where

(so we take the identifiers and types from the tref part, and send
them into the selectlist and where parts)

-}

ATTR TableRef
         [
         |
         | idens : {[QualifiedScope]} joinIdens : {[String]}
         ]

ATTR MTableRef
         [
         |
         | idens : {[QualifiedScope]} joinIdens : {[String]}
         ]


SEM SelectExpression
    | Select
         selSelectList.scope = scopeReplaceIds @lhs.scope @selTref.idens @selTref.joinIdens
         selWhere.scope = scopeReplaceIds @lhs.scope @selTref.idens @selTref.joinIdens

{-

== attributes

columnName is used to collect the column names that the select list
produces, it is combined into an unnamedcompositetype in
selectitemlist, which is also where star expansion happens.

-}

ATTR SelectItem
  [
  |
  | columnName : String
  ]

{-
if the select item is just an identifier, then that column is named
after the identifier
e.g. select a, b as c, b + c from d, gives three columns one named
a, one named c, and one unnamed, even though only one has an alias
if the select item is a function or aggregate call at the top level,
then it is named after that function or aggregate
-}

--default value for non identifier nodes

ATTR Expression
  [
  |
  | liftedColumnName USE {`(fixedValue "")`} {""}: String
  ]

{
fixedValue :: a -> a -> a -> a
fixedValue a _ _ = a
}

{-
override for identifier nodes, this only makes it out to the selectitem
node if the identifier is not wrapped in parens, function calls, etc.
-}

SEM Expression
  | Identifier lhs.liftedColumnName = @i
  | FunCall lhs.liftedColumnName =
      if isOperator @funName
         then ""
         else @funName

-- collect the aliases and column names for use by the selectitemlist nodes
SEM SelectItem
    | SelExp lhs.columnName = case @ex.liftedColumnName of
                                "" -> "?column?"
                                s -> s
    | SelectItem lhs.columnName = @name

{-
================================================================================

= static tests

Try to use a list of message data types to hold all sorts of
information which works its way out to the top level where the client
code gets it. Want to have the lists concatenated together
automatically from subnodes to parent node, and then to be able to add
extra messages to this list at each node also.

Problem 1: can't have two sem statements for the same node type which
both add messages, and then the messages get combined to provide the
final message list attribute value for that node. You want this so
that e.g. that different sorts of checks appear in different
sections. Workaround is instead of having each check in it's own
section, to combine them all into one SEM.

Problem 2: no shorthand to combine what the default rule for messages
would be and then add a bit extra - so if you want all the children
messages, plus possibly an extra message or two, have to write out the
default rule in full explicitly. Can get round this by writing out
loads of code.

Both the workarounds to these seem a bit tedious and error prone, and
will make the code much less readable. Maybe need a preprocessor to
produce the ag file? Alternatively, just attach the messages to each
node (so this appears in the data types and isn't an attribute, then
have a tree walker collect them all). Since an annotation field in
each node is going to be added anyway, so each node can be labelled
with a type, will probably do this at some point.

================================================================================

= inloop testing

inloop - use to check continue, exit, and other commands that can only
appear inside loops (for, while, loop)

the only nodes that really need this attribute are the ones which can
contain statements

The inloop test is the only thing which uses the messages atm. It
shouldn't, at some point inloop testing will become part of the type
checking.

This is just some example code, will probably do something a lot more
heavy weight like symbolic interpretation - want to do all sorts of
loop, return, nullability, etc. analysis.

-}

ATTR AllNodes Root ExpressionRoot
  [
  |
  | messages USE {++} {[]} : {[Message]}
  ]

ATTR AllNodes
  [ inLoop: Bool
  |
  |
  ]

SEM Root
  | Root statements.inLoop = False

SEM ExpressionRoot
  | ExpressionRoot expr.inLoop = False

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

SEM Statement
     | ForSelectStatement ForIntegerStatement WhileStatement sts.inLoop = True
     | CreateFunction body.inLoop = False

-- now we can check when we hit a continue statement if it is in the
-- right context
SEM Statement
    | ContinueStatement  lhs.messages = if not @lhs.inLoop
                                          then [Error @lhs.sourcePos ContinueNotInLoop]
                                          else []

{-
================================================================================

= notes and todo


containment guide for select expressions:
combineselect 2 selects
insert ?select
createtableas 1 select
createview 1 select
return query 1 select
forselect 1 select
select->subselect select
expression->exists select
            scalarsubquery select
            inselect select

containment guide for statements:
forselect [statement]
forinteger [statement]
while [statement]
casestatement [[statement]]
if [[statement]]
createfunction->fnbody [Statement]

TODO

some non type-check checks:
check plpgsql only in plpgsql function
orderby in top level select only
copy followed immediately by copydata iff stdin, copydata only follows
  copy from stdin
count args to raise, etc., check same number as placeholders in string
no natural with onexpr in joins
typename -> setof (& fix parsing), what else like this?
expressions: positionalarg in function, window function only in select
 list top level

review all ast checks, and see if we can also catch them during
parsing (e.g. typeName parses setof, but this should only be allowed
for a function return, and we can make this a parse error when parsing
from source code rather than checking a generated ast. This needs
judgement to say whether a parse error is better than a check error, I
think for setof it is, but e.g. for a continue not in a loop (which
could be caught during parsing) works better as a check error, looking
at the error message the user will get. This might be wrong, haven't
thought too carefully about it yet).


TODO: canonicalize ast process, as part of type checking produces a
canonicalized ast which:
all implicit casts appear explicitly in the ast (maybe distinguished
from explicit casts?)
all names fully qualified
all types use canonical names
literal values and selectors in one form (use row style?)
nodes are tagged with types
what else?

Canonical form only defined for type consistent asts.

This canonical form should pretty print and parse back to the same
form, and type check correctly.


-}
