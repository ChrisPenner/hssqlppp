{-
Copyright 2009 Jake Wheat

This file contains the attr and sem definitions, which do the type
checking, etc..

A lot of the haskell code has been moved into AstUtils.lhs, it is
intended that only small amounts of code appear (i.e. one-liners)
inline in this file, and larger bits go in AstUtils.lhs. These are
only divided because the attribute grammar system uses a custom syntax
with a custom preprocessor.

Dynamic note:

The current type checking approach doesn't quite match how SQL
works. The main problem is that you can e.g. exec create table
statements inside a function. This is something that the type checker
will probably not be able to deal for a while if ever. (Will need
hooks into postgresql to do this properly, which might not be
impossible...)

Part of the syntax extension system design is to provide some
specialized methods for generating sql code in a way that can be type
checked statically without having to run the code.

Probably not many people do this sort of thing so it might not be a
big limitation for most.

================================================================================

Basic common attributes:

sourcePos - holds the source position used in messages, not very
accurate at the moment, just gives you the position of the first
character in the current statement

messages - used to collect error messages, also to be used for
warnings (e.g. $1 position argument used when all args have aliases),
and notices - will probably use these to highlight dodgy sql
code and idioms. This is probably going to disappear and the nodeTypes
will carry much of this information.

actual value - add this to all nodes out of lazy programming. We use
these values in a limited number of places in the code

-}

ATTR AllNodes
  [ sourcePos: MySourcePos
  |
  |
  ]

ATTR AllNodes Root ExpressionRoot
  [ scope : Scope
  |
  | messages USE {++} {[]} : {[Message]}
    actualValue: SELF
  ]

{-

we set all the node types to unknown to start with, this allows the
type checking to be implemented bit by bit. When the type checking is
more complete, these might be removed or changed to something more
specific. The listnodes' behaviour is actually used by the working
typing checking code.

-}

ATTR NonListNodes Root ExpressionRoot
  [
  |
  | nodeType USE {`setUnknown`} {UnknownType} : {Type}
  ]

ATTR ListNodes
  [
  |
  | nodeType USE {`appendTypeList`} {TypeList []} : {Type}
  ]

{
setUnknown :: Type -> Type -> Type
setUnknown _ _ = UnknownType

appendTypeList :: Type -> Type -> Type
appendTypeList t1 (TypeList ts) = TypeList (t1:ts)
appendTypeList t1 t2 = TypeList (t1:t2:[])
}

{-

source positions aren't collected by the parser properly yet, so we
just get what's available and propagate that.

-}

SEM SourcePosStatement
    | Tuple x2.sourcePos = @x1

SEM Root
  | Root statements.sourcePos = ("",0,0)

SEM ExpressionRoot
  | ExpressionRoot expr.sourcePos = ("",0,0)


--bit hacky, used to work with maybe bits in attribute grammar code
SEM MaybeExpression
    | Just lhs.nodeType = @just.nodeType
    | Nothing lhs.nodeType = TypeList []

{-

================================================================================

= some basics

== type names

-}

SEM TypeName
     | SimpleTypeName
          lhs.nodeType = let st = canonicalizeType $ ScalarType @tn
                         in head $ catMaybes
                                [checkTypeExists @lhs.scope @lhs.sourcePos st
                                ,Just st]
--     | PrecTypeName
--          lhs.nodeType = if @tn `elem` defaultTypes
--                           then ScalarType @tn
--                           else TypeError @lhs.sourcePos
--                                  (UnknownTypeError @tn)
     | ArrayTypeName
          lhs.nodeType = let t = ArrayType @typ.nodeType
                         in head $ catMaybes
                                [unkErr @typ.nodeType
                                ,checkTypeExists @lhs.scope @lhs.sourcePos t
                                ,Just t]
     | SetOfTypeName
          lhs.nodeType = head $ catMaybes
                           [unkErr @typ.nodeType
                           ,Just $ SetOfType @typ.nodeType]

{-
== literals
-}

SEM Expression
     | IntegerLit lhs.nodeType = typeInt
     | StringLit lhs.nodeType = UnknownStringLit
     | FloatLit lhs.nodeType = typeNumeric
     | BooleanLit lhs.nodeType = typeBool
     -- I think a null types like an unknown string lit
     | NullLit lhs.nodeType = UnknownStringLit



{-
================================================================================

= expressions

== cast expression

-}

SEM Expression
    | Cast lhs.nodeType = head $ catMaybes
                            [unkErr @expr.nodeType
                            ,Just @tn.nodeType]

{-
== operators and functions
-}

SEM Expression
    | FunCall lhs.nodeType =
        typeCheckFunCall
          @lhs.scope
          @lhs.sourcePos
          @funName
          @args.nodeType



{-
== case expression

check the when expressions are boolean inside the pairs, then collect
the then types to pass to resolveResultSetType

-}

SEM CaseExpressionListExpressionPair
    | Tuple lhs.nodeType = checkTypes
                             @lhs.scope
                             @lhs.sourcePos
                             @x1.nodeType
                             (AllSameType typeBool)
                             (ConstRetType @x2.nodeType)

SEM Expression
    | Case lhs.nodeType =
             resolveResultSetType
               @lhs.scope
               @lhs.sourcePos
               (typesFromTypeList
                (case @els.nodeType of
                   TypeList [] -> @cases.nodeType
                   e -> TypeList $ (typesFromTypeList @cases.nodeType)
                                  ++ [e]))

{-
== identifiers
pull id types out of scope for identifiers

-}

SEM Expression
    | Identifier lhs.nodeType =
               case M.lookup @i (scopeIdentifierTypes @lhs.scope) of
                 Nothing -> TypeError
                              @lhs.sourcePos
                              (UnrecognisedIdentifier @i)
                 Just t -> t

{-
================================================================================

= basic select statements

== nodeTypes

-}

SEM Statement
    | SelectStatement lhs.nodeType = @ex.nodeType

SEM SelectExpression
    --assume we get TypeList (TypeList (Type)) out of vll
    | Values lhs.nodeType = typeCheckValuesExpr
                              @lhs.scope
                              @lhs.sourcePos
                              @vll.nodeType
    | Select
         lhs.nodeType = head $ catMaybes
                          [unkErr @selTref.nodeType
                          ,unkErr @selSelectList.nodeType
                          ,unkErr @selWhere.nodeType
                          ,Just $ SetOfType @selSelectList.nodeType]

SEM TableRef
    | SubTref lhs.nodeType = getCompositeFromSetOf @sel.nodeType
    | TrefAlias Tref lhs.nodeType =
        case getAttrs @lhs.scope [TableComposite, ViewComposite] @tbl of
          Just (_,_,a@(UnnamedCompositeType _)) -> a
          _ -> TypeError @lhs.sourcePos (UnrecognisedRelation @tbl)
    | TrefFun TrefFunAlias
        lhs.nodeType =
            --lhs.nodeType = case @fn.actualValue of
            --              FunCall _ _ -> TypeList []
            --              x -> TypeError @lhs.sourcePos (ContextError "FunCall")
            case @fn.actualValue of
              FunCall (SimpleFun f) _ ->
                  case @fn.nodeType of
                    SetOfType (CompositeType t) -> getCompositeType t
                    SetOfType x -> UnnamedCompositeType [(f,x)]
                    y -> UnnamedCompositeType [(f,y)]
              x -> UnnamedCompositeType []
              where
                getCompositeType t =
                    case getAttrs @lhs.scope [Composite
                                             ,TableComposite
                                             ,ViewComposite] t of
                      Just (_,_,a@(UnnamedCompositeType _)) -> a
                      _ -> UnnamedCompositeType []
    | JoinedTref
        lhs.nodeType =
            head $ catMaybes [unkErr @tbl.nodeType
                             ,unkErr @tbl1.nodeType
                             ,Just ret]
            where
              ret = case (@nat.actualValue, @onExpr.actualValue) of
                      (Natural, _) -> unionJoinList $ commonFieldNames
                                                        @tbl.nodeType
                                                        @tbl1.nodeType
                      (_,Just (JoinUsing s)) -> unionJoinList s
                      _ -> UnnamedCompositeType $ getTypesFromComp
                                                     @tbl.nodeType ++
                                                     getTypesFromComp
                                                       @tbl1.nodeType
              unionJoinList s = combineTableTypesWithUsingList
                                  @lhs.scope
                                  @lhs.sourcePos
                                  s
                                  @tbl.nodeType
                                  @tbl1.nodeType
              commonFieldNames t1 t2 =
                  intersect (fn t1) (fn t2)
              fn (UnnamedCompositeType s) = map fst s
              fn _ = []


SEM MTableRef
    | Nothing lhs.nodeType = TypeList []
    | Just lhs.nodeType = @just.nodeType

SEM Where
    | Nothing lhs.nodeType = typeBool
    | Just lhs.nodeType = head $ catMaybes
                            [unkErr @just.nodeType
                            ,Just $ if @just.nodeType /= typeBool
                                      then TypeError @lhs.sourcePos
                                             ExpressionMustBeBool
                                      else typeBool]

SEM SelectItem
    | SelExp SelectItem lhs.nodeType = @ex.nodeType

SEM SelectItemList
    | Cons lhs.nodeType =
        foldr consCompositeField @tl.nodeType
           (if @hd.columnName == "*"
              then getTypesFromComp @lhs.trefType
              else [(@hd.columnName,@hd.nodeType)])
    | Nil lhs.nodeType = UnnamedCompositeType []

SEM SelectList
    | SelectList lhs.nodeType = @items.nodeType

{-

== scope passing

scope flow:
current simple version:
from tref -> select list
          -> where

(so we take the identifiers and types from the tref part, and send
them into the selectlist and where parts)

-}

SEM SelectExpression
    | Select
         selSelectList.scope = scopeCombineIds
                                 @lhs.scope
                                 (getColumnsAsTypes @selTref.nodeType)
         selWhere.scope =  scopeCombineIds
                             @lhs.scope
                             (getColumnsAsTypes @selTref.nodeType)


{-

== columns

this is where we collect the name,type information from the trefs so
we can pass it on in the scope, and also this info is used to expand *

=== attributes

columns holds the types of the columns retrieved from the tref, this
provides the set of identifiers for the select list, etc., to refer to
(it's type is always unnamedcompositetype).

columnName is used to collect the column names that the select list
produces, it is combined into an unnamedcompositetype in
selectitemlist, which is also where expansion happens.

-}



ATTR SelectItemList
  [
  | trefType : Type
  |
  ]

ATTR SelectList
  [
  | trefType : Type
  |
  ]

ATTR SelectItem
  [
  |
  | columnName : String
  ]

{-
if the select item is just an identifier, then that column is named
after the identifier
e.g. select a, b as c, b + c from d, gives three columns one named
a, one named c, and one unnamed
-}

ATTR Expression
  [
  |
  | liftedColumnName USE {`(fixedValue "")`} {""}: String
  ]

{
fixedValue :: a -> a -> a -> a
fixedValue a _ _ = a
}


{-
=== semantics

pass the type of the tableref into the select list:

-}

SEM SelectExpression
    | Select
         selSelectList.trefType = @selTref.nodeType


{-

collect the column names so that the type of the select list can be
calculated

-}

SEM Expression
  | Identifier lhs.liftedColumnName = @i

SEM SelectItem
    | SelExp lhs.columnName = case @ex.liftedColumnName of
                                "" -> "?column?"
                                s -> s
    | SelectItem lhs.columnName = @name


{-

containment guide for select expressions:
combineselect 2 selects
insert ?select
createtableas 1 select
createview 1 select
return query 1 select
forselect 1 select
select->subselect select
expression->exists select
            scalarsubquery select
            inselect select

containment guide for statements:
forselect [statement]
forinteger [statement]
while [statement]
casestatement [[statement]]
if [[statement]]
createfunction->fnbody [Statement]

TODO

some non type-check checks:
check plpgsql only in plpgsql function
orderby in top level select only
copy followed immediately by copydata iff stdin, copydata only follows
  copy from stdin
count args to raise, etc., check same number as placeholders in string
natural with correct join types
no natural with onexpr in joins
constraint column ref checks?
typename -> setof (& fix parsing), what else like this?
expressions: positionalarg in function, window function only in select
 list top level

review all ast checks, and see if we can also catch them during
parsing (e.g. typeName parses setof, but this should only be allowed
for a function return, and we can make this a parse error when parsing
from source code rather than checking a generated ast. This needs
judgement to say whether a parse error is better than a check error, I
think for setof it is, but e.g. for a continue not in a loop (which
could be caught during parsing) works better as a check error, looking
at the error message the user will get. This might be wrong, haven't
thought too carefully about it yet).




TODO: canonicalize ast process, as part of type checking produces a canonicalized ast which:
all implicit casts appear explicitly in the ast (maybe distinguished from explicit casts?)
all names fully qualified
all types use canonical names
literal values and selectors in one form (use row style?)
nodes are tagged with types
what else?

Canonical form only defined for type consistent asts.

This canonical form should pretty print and parse back to the same
form, and type check correctly.

================================================================================

= static tests

Problem 1: can't have two sem statements for the same node type which
both add messages, and then the messages get combined to provide the
final message list attribute value for that node. Workaround is
instead of having each check in it's own section, to combine them all
into one SEM.

Problem 2: no shorthand to combine what the default rule for messages
would be and then add a bit extra - so if you want all the children
messages, plus possiby an extra message or two, have to write out the
default rule in full explicitly. Can get round this by writing out
loads of code.

Both the workarounds to these seem a bit tedious and error prone, and
will make the code much less readable. Maybe need a preprocessor to
produce the ag file?

================================================================================

= inloop testing

inloop - use to check continue, exit, and other commands that can only
appear inside loops (for, while, loop)

-}

ATTR AllNodes
  [ inLoop: Bool
  |
  |
  ]

SEM Root
  | Root statements.inLoop = False

SEM ExpressionRoot
  | ExpressionRoot expr.inLoop = False

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

-- set the inloop stuff which nests, it's reset inside a create
-- function statement, in case you have a create function inside a
-- loop, seems unlikely you'd do this though

SEM Statement
     | ForSelectStatement ForIntegerStatement WhileStatement sts.inLoop = True
     | CreateFunction body.inLoop = False

-- now we can check when we hit a continue statement if it is in the
-- right context
SEM Statement
    | ContinueStatement  lhs.messages = if not @lhs.inLoop
                                          then [Error @lhs.sourcePos ContinueNotInLoop]
                                          else []
