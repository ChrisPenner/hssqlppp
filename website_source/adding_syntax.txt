# Adding new syntax

This is an example of how to add new syntax to the library. One way to
do it is:

add test(s) to the automated tests under src-extra/tests/

compile and run the tests to check the new test fails

add new datatypes to AstInternal.ag

fix any default uuagc rules if needed

run the build script which processes the ag file into haskell files

add code for parsing and pretty printing the new syntax

compile and run the tests to check that the new test(s) now pass

# Example

Worked through example of adding support for parsing data types with 2
precision components. (This has already been completed).

The parser/syntax currently supports the precision of floating point
types, e.g.

~~~~{.sql}
create table t {
   col float(24);
}
~~~~

We want it to also support two components, for numeric types:

~~~~{.sql}
create table t {
   col numeric(5,3);
}
~~~~

## Add a test

The first step: add a test. At the moment, all the parsing tests go
src-extra/tests/Database/HsSqlPpp/Tests/ParserTest.lhs. You could also
add a new module, and link it in src-extra/tests/Tests.

To add the new test, we have to figure out how the new abstract syntax
will look. We can defer this while we add the test, until we actually
edit the abstract syntax types. The added code:

~~~~{.haskell}
e "245.1::numeric(5,3)" (Cast ea (FloatLit ea 245.1) (PrecTypeName ea "numeric" 5))
~~~~

Now check the test fails, not really that useful at this time, but
good sanity check.

~~~~
$ cd src-extra
$ cabal configure
$ cabal build
$ dist/build/Tests/Tests -t "numeric"
parserTests:
  parse expressions:
    simple operators:
      parse 245.34::numeric(5,3): [Failed]
Failed: (line 1, column 7):
unexpected ((line 1, column 7),SymbolTok "::")
expecting operator or end of input
:1:7:

Context:
245.34::numeric(5,3)
      ^
ERROR HERE



         Test Cases  Total      
 Passed  0           0          
 Failed  1           1          
 Total   1           1          

$
~~~~

You can use -t [string] argument to the tests executable to only run
the tests which match the string.

## Syntax

Editing syntax is currently pretty hairy in hssqlppp. The first place
to go is the AstInternal.ag file, which is not written in haskell
syntax, but in uuagc syntax.

Searching for PrecTypeName in this file should give a good place to
alter the syntax.

You get a block like this:

~~~~{.haskell}
DATA TypeName | SimpleTypeName ann:Annotation tn:String
              | PrecTypeName ann:Annotation tn:String prec:Integer
              | ArrayTypeName ann:Annotation typ:TypeName
              | SetOfTypeName ann:Annotation typ:TypeName
~~~~

Add a new Prec2TypeName constructor with two integer args:

~~~~{.haskell}
DATA TypeName | SimpleTypeName ann:Annotation tn:String
              | PrecTypeName ann:Annotation tn:String prec:Integer
              | Prec2TypeName ann:Annotation tn:String prec:Integer prec1:Integer
              | ArrayTypeName ann:Annotation typ:TypeName
              | SetOfTypeName ann:Annotation typ:TypeName
~~~~

Now we have made changes to an ag file, we need to run uuagc to
produce AstInternal.hs.

You can use the build.sh script to do this.

~~~~
$ ./build.sh
./TypeChecking/Misc.ag:15:18: warning: Missing rule for synthesized attribute namedType in alternative Prec2TypeName of nonterminal TypeName.
~~~~

OK, so this is a bit weird if you don't know uuagc. Looking at the
file, the simplest fix seems to be to copy the style of the
PrecTypeName part. The previous code:

~~~~{.haskell}
SEM TypeName
     | SimpleTypeName ArrayTypeName SetOfTypeName PrecTypeName
         lhs.namedType = etmt @loc.tpe
         lhs.annotatedTree = addTypeErrors (tes @loc.tpe) @loc.backTree

SEM TypeName
     | SimpleTypeName
        loc.tpe = catLookupType @lhs.cat $ canonicalizeTypeName @tn
        loc.backTree = SimpleTypeName @ann @tn
     | ArrayTypeName
        loc.tpe = lmt @typ.namedType >>=  Right . ArrayType
        loc.backTree = ArrayTypeName @ann @typ.annotatedTree
     | SetOfTypeName
        loc.tpe = lmt @typ.namedType >>=  Right . SetOfType
        loc.backTree = SetOfTypeName @ann @typ.annotatedTree
     | PrecTypeName
        loc.tpe = catLookupType @lhs.cat $ canonicalizeTypeName @tn
        loc.backTree = PrecTypeName @ann @tn @prec
~~~~

And the updated code:

~~~~{.haskell}
SEM TypeName
     | SimpleTypeName ArrayTypeName SetOfTypeName PrecTypeName Prec2TypeName
         lhs.namedType = etmt @loc.tpe
         lhs.annotatedTree = addTypeErrors (tes @loc.tpe) @loc.backTree

SEM TypeName
     | SimpleTypeName
        loc.tpe = catLookupType @lhs.cat $ canonicalizeTypeName @tn
        loc.backTree = SimpleTypeName @ann @tn
     | ArrayTypeName
        loc.tpe = lmt @typ.namedType >>=  Right . ArrayType
        loc.backTree = ArrayTypeName @ann @typ.annotatedTree
     | SetOfTypeName
        loc.tpe = lmt @typ.namedType >>=  Right . SetOfType
        loc.backTree = SetOfTypeName @ann @typ.annotatedTree
     | PrecTypeName
        loc.tpe = catLookupType @lhs.cat $ canonicalizeTypeName @tn
        loc.backTree = PrecTypeName @ann @tn @prec
     | Prec2TypeName
        loc.tpe = catLookupType @lhs.cat $ canonicalizeTypeName @tn
        loc.backTree = Prec2TypeName @ann @tn @prec @prec1
~~~~

Now uuagc runs without warnings. You should mostly be able to add new
syntax and parsing without doing any fixes to these rules, so you can
focus on getting the syntax and parsing working first. Patches which
add new syntax/parsing but leave the type checker broken are OK.

If the build.sh script completes successfully, then the .ag files
should be compiled to hs, the AstAnti.hs module should be generated,
and cabal build run.

Time to fix the tests: the line in ParserTests.lhs is now

~~~~{.haskell}
e "(245.1)::numeric(5,3)" (Cast ea (FloatLit ea 245.1) (Prec2TypeName ea "numeric" 5 3))
~~~~

Recompiling works, and running the test fails.

The next job is to add to the parser. The parsing code is mostly in
src/Database/HsSqlPpp/Parsing/ParserInternal.lhs.

Loading this file and searching for PrecTypeName gives the typeName
parser function:

~~~~{.haskell}
> typeName :: SParser TypeName
> typeName =
>   choice [
>      SetOfTypeName <$> pos <*> (keyword "setof" *> typeName)
>     ,otherTypeName]
>   where
>     otherTypeName = do
>        p <- pos
>        s <- map toLower <$> pTypeNameString
>        choice [PrecTypeName p s <$> parens integer
>               ,arrayTypeName p s
>               ,return $ SimpleTypeName p s]
>     arrayTypeName p s = ArrayTypeName p (SimpleTypeName p s)
>                         <$ symbol "[" <* symbol "]"
>     --todo: add special cases for the other type names with spaces in them
>     pTypeNameString = ("double precision" <$ try (keyword "double"
>                                                   <* keyword "precision"))
>                       <|> idString
~~~~

Here is the updated version. It could probably be a bit better
designed but getting a crappily written version working and passing
tests is usually a good first step before trying to make it clean and
elegant.

~~~~{.haskell}
> typeName :: SParser TypeName
> typeName =
>   choice [
>      SetOfTypeName <$> pos <*> (keyword "setof" *> typeName)
>     ,otherTypeName]
>   where
>     otherTypeName = do
>        p <- pos
>        s <- map toLower <$> pTypeNameString
>        choice [try (Prec2TypeName p s
>                     <$> (symbol "(" *> integer)
>                     <*> (symbol "," *> integer <* symbol ")"))
>               ,PrecTypeName p s <$> parens integer
>               ,arrayTypeName p s
>               ,return $ SimpleTypeName p s]
>     arrayTypeName p s = ArrayTypeName p (SimpleTypeName p s)
>                         <$ symbol "[" <* symbol "]"
>     --todo: add special cases for the other type names with spaces in them
>     pTypeNameString = ("double precision" <$ try (keyword "double"
>                                                   <* keyword "precision"))
>                       <|> idString
~~~~

We have to use try with this approach since it Prec2TypeName starts
out the same as PrecTypeName.

## Pretty printing

Compiling and running the tests gives:

~~~~
parserTests:
  parse expressions:
    simple operators:
      parse 245.1::numeric(5,3): [Failed]
ERROR: src/Database/HsSqlPpp/PrettyPrinter.lhs:(565,2)-(568,67): Non-exhaustive patterns in function convTypeName


         Test Cases  Total      
 Passed  0           0          
 Failed  1           1          
 Total   1           1          
~~~~

The issue here is that the pretty printer hasn't also been
updated. The parsing tests all first parse the string given, check it
is the same as the ast given, then pretty print and reparse the pretty
printed string to check it still gives the same result. This is a
reasonably good way of checking the pretty printing routines, and that
parse then pretty print gives the same sql (and pretty print then
parse gives the same ast).

The pretty printing routines are in
'src/Database/HsSqlPpp.PrettyPrinter'. Here is the line I added
after the PrecTypeName pretty printer:

~~~~{.haskell}
> convTypeName (PrecTypeName _ s i) = text s <> parens(integer i)
> convTypeName (Prec2TypeName _ s i i1) = text s <> parens (hcatCsv [integer i, integer i1])
~~~~

## Finished

Now the test passes and the only thing left is to run all the tests to
check nothing else has been broken.

This is just a sketch guide, please email me if you have any questions.
