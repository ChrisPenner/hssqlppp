
sem Statement
  | QueryStatement DeclareStatement If
    Insert Update Delete CopyFrom CopyTo Truncate
    Assignment ExecStatement CreateIndexTSQL
    DropSomething DropTrigger Into
    ann.tpe = Left []

  | QueryStatement
    ex.expectedType = liftM (map snd) @ex.upType
    ex.expectedCast = True
  | Insert
    insData.expectedType = do
                           let tnm = nameComponents @table.originalTree
                           (_,pub,_) <- eitherToMaybe $ catLookupTableAndAttrs @lhs.cat tnm
                           case @targetCols of
                                []  -> return $ map snd pub
                                tcs -> do
                                       tcs' <- mapM nmcString tcs
                                       mapM (`lookup` pub) tcs'
    insData.expectedCast = True
  | CreateTableAs CreateView
    expr.expectedType = liftM (map snd) @expr.upType
    expr.expectedCast = True
  | ReturnQuery ForQueryStatement
    sel.expectedType = liftM (map snd) @sel.upType
    sel.expectedCast = True

  | Assignment
    target.tpe = Left []
    value.downEnv = emptyEnvironment

{
eitherToMaybe :: Either a b -> Maybe b
eitherToMaybe = either (const Nothing) Just

nmcString :: NameComponent -> Maybe Text
nmcString (QNmc n) = Just $ T.pack n
nmcString (Nmc n) = Just $ T.pack $ map toLower n
nmcString (AntiNameComponent _) = Nothing
}
